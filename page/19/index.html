<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/19/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-html+css+js+ts/4-Symbol" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/12/html+css+js+ts/4-Symbol/" class="article-date">
  <time class="dt-published" datetime="2018-04-12T13:42:25.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/12/html+css+js+ts/4-Symbol/">ES6 Symbol</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><blockquote>
<p><code>ES6</code>新加入了一种原始数据类型<code>Symbol</code>，表示独一无二的值，这是<code>js</code>的第七种数据类型，前六种是：<code>Undefined</code>、<code>Null</code>、布尔值（<code>Boolean</code>）、字符串（<code>String</code>）、数值（<code>Number</code>）、对象（<code>Object</code>）</p>
</blockquote>
<ul>
<li>对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的<code>Symbol</code>类型。凡是属性名属于<code>Symbol</code>类型，就都是独一无二的，可以保证不会与其他属性名产生冲突</li>
</ul>
<h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Symbol([description])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数 <code>description</code> 是一个可选参数，是一个字符串，可以用于调试，但不能访问<code>Symbol</code> 自身</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sym1 = Symbol();</span><br><span class="line">var sym2 = Symbol(&#x27;foo&#x27;);</span><br><span class="line">var sym3 = Symbol(&#x27;foo&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-值唯一性"><a href="#1-2-值唯一性" class="headerlink" title="1.2 值唯一性"></a>1.2 值唯一性</h3><blockquote>
<p>每一个 <code>Symbol()</code>返回的值都是唯一的。一个<code>Symbol</code> 值能作为对象属性的标识符，这是改数据类型仅有的目的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Symbol(&quot;yuan&quot;) === Symbol(&quot;yuan&quot;); // false</span><br></pre></td></tr></table></figure>

<h3 id="1-3-不可以使用-new-操作符"><a href="#1-3-不可以使用-new-操作符" class="headerlink" title="1.3 不可以使用 new 操作符"></a>1.3 不可以使用 new 操作符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sym = new Symbol(); // TypeError报错</span><br></pre></td></tr></table></figure>

<h3 id="1-4-结合-Object-函数"><a href="#1-4-结合-Object-函数" class="headerlink" title="1.4 结合 Object() 函数"></a>1.4 结合 Object() 函数</h3><blockquote>
<p>结合 <code>Object()</code> 函数，创建一个 <code>Symbol</code> 包装器对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var sym = Symbol();</span><br><span class="line">typeof sym;  // &quot;symbol“”</span><br><span class="line">var symobj = Object(sym);</span><br><span class="line">typeof symobj; // &quot;object&quot;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-全局共享-Symbol"><a href="#1-5-全局共享-Symbol" class="headerlink" title="1.5 全局共享 Symbol"></a>1.5 全局共享 Symbol</h3><blockquote>
<p>使用<code>Symbol.for()</code> 方法会根据给定的键 <code>key</code>，来从运行时的 <code>symbol</code> 注册表中找到对应的 <code>symbol</code>，如果找到了，则返回它，否则，新建一个与该键关联的 <code>symbol</code>，并放入全局 <code>symbol</code> 注册表中</p>
</blockquote>
<h3 id="1-6-在对象中查找-Symbol-属性"><a href="#1-6-在对象中查找-Symbol-属性" class="headerlink" title="1.6 在对象中查找 Symbol 属性"></a>1.6 在对象中查找 Symbol 属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var a = Symbol(&quot;a&quot;);</span><br><span class="line">var b = Symbol.for(&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">obj[a] = &quot;localSymbol&quot;;</span><br><span class="line">obj[b] = &quot;globalSymbol&quot;;</span><br><span class="line"></span><br><span class="line">var objectSymbols = Object.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">console.log(objectSymbols)         // [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure>

<h2 id="二、静态属性"><a href="#二、静态属性" class="headerlink" title="二、静态属性"></a>二、静态属性</h2><h3 id="2-1-length-属性"><a href="#2-1-length-属性" class="headerlink" title="2.1 length 属性"></a>2.1 length 属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Symbol 的长度属性值为0.</span><br><span class="line">Symbol.length // 0</span><br></pre></td></tr></table></figure>

<h3 id="2-2-迭代-Symbols"><a href="#2-2-迭代-Symbols" class="headerlink" title="2.2 迭代 Symbols"></a>2.2 迭代 Symbols</h3><blockquote>
<p><code>Symbol.iterator</code> 该方法为每一个对象定义了默认的迭代器。该迭代器可以被 <code>for.. of</code> 循环使用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 自定义迭代器</span><br><span class="line">var myIterator = &#123;&#125;;</span><br><span class="line">myIterator[Symbol.iterator] = function* () &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterator] // [1, 2, 3]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Symbols</code> 与 <code>for... in</code> 迭代</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj[Symbol(&quot;a&quot;)] = &quot;a&quot;;</span><br><span class="line">obj[Symbol.for(&quot;b&quot;)] = &quot;b&quot;;</span><br><span class="line">obj[&quot;c&quot;] = &quot;c&quot;;</span><br><span class="line">obj.d = &quot;d&quot;;</span><br><span class="line"></span><br><span class="line">for (var i in obj) &#123;</span><br><span class="line">   console.log(i); </span><br><span class="line">&#125;</span><br><span class="line">// &quot;c&quot;</span><br><span class="line">// &quot;d&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Symbol的正则表达式"><a href="#2-3-Symbol的正则表达式" class="headerlink" title="2.3 Symbol的正则表达式"></a>2.3 Symbol的正则表达式</h3><blockquote>
<p>用于标识对象是否具有正则表达式的行为。<code>Symbol.match</code>:对象是否具有指定的匹配的正则表达式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;/bar/&quot;.startsWith(/bar/); </span><br><span class="line">// Throws TypeError, 因为 /bar/ 是一个正则表达式</span><br><span class="line">// 且 Symbol.match 没有修改。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你将 <code>Symbol.match</code> 置为 <code>false</code>，使用 <code>match</code> 属性的表达式检查会认为该象不是正则表达式对象。<code>startsWith</code> 和 <code>endsWith</code> 方法将不会抛出 <code>TypeError</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var re = /foo/;</span><br><span class="line">re[Symbol.match] = false;</span><br><span class="line"></span><br><span class="line">&quot;/foo/&quot;.startsWith(re); // true</span><br><span class="line">&quot;/baz/&quot;.endsWith(re);   // false</span><br></pre></td></tr></table></figure>

<p><strong>Symbol.replace</strong></p>
<blockquote>
<p>这个属性指定了当一个字符串替换所匹配字符串时所调用的方法。<code>String.prototype.replace()</code> 方法会调用此方法。</p>
</blockquote>
<p><strong>Symbol.search</strong></p>
<blockquote>
<p>指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回该正则表达式在字符串中匹配到的下标，这个方法由以下的方法来调用 <code>String.prototype.search()</code></p>
</blockquote>
<p><strong>Symbol.split</strong></p>
<blockquote>
<p>指向 一个正则表达式的索引处分割字符串的方法。 这个方法通过<code>String.prototype.split()</code> 调用</p>
</blockquote>
<h3 id="2-4-其他属性"><a href="#2-4-其他属性" class="headerlink" title="2.4 其他属性"></a>2.4 其他属性</h3><p><strong>Symbol.hasInstance</strong></p>
<blockquote>
<p>一个确定一个构造器对象识别的对象是否为它的实例的方法</p>
</blockquote>
<p><strong>Symbol.toStringTag</strong></p>
<blockquote>
<p>用于对象的默认描述的字符串值。使用<code>Object.prototype.toString().</code></p>
</blockquote>
<h2 id="三、静态方法"><a href="#三、静态方法" class="headerlink" title="三、静态方法"></a>三、静态方法</h2><h3 id="3-1-Symbol-for-key"><a href="#3-1-Symbol-for-key" class="headerlink" title="3.1 Symbol.for(key)"></a>3.1 Symbol.for(key)</h3><blockquote>
<p>根据给定的键 <code>key</code>， 从运行时的 <code>symbol</code> 注册表中找到对应的 <code>symbol</code>，如果找到了，则返回它，否则，新建一个与该键关联的 <code>symbol</code>，并放入全局 <code>symbol</code> 注册表</p>
</blockquote>
<ul>
<li>这里的参数<code>key</code>，是一个字符串，作为 <code>symbol</code> 注册表中与某 <code>symbol</code> 关联的键</li>
<li>和 <code>Symbol()</code> 不同的是，用<code>Symbol.for()</code> 方法创建的 <code>symbol</code> 会被放入一个全局 symbol 注册表中</li>
<li><code>Symbol.for()</code> 并不是每次都会创建一个新的 symbol，它会首先检查给定的 <code>key</code> 是否已经在注册表中了，如果是，则会直接返回上次存储的那个。否则，会再新建一个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Symbol.for(&quot;foo&quot;); // 创建一个 symbol 并放入 symbol 注册表中，键为 &quot;foo&quot;</span><br><span class="line">Symbol.for(&quot;foo&quot;); // 从 symbol 注册表中读取键为&quot;foo&quot;的 symbol</span><br><span class="line"></span><br><span class="line">Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;); // true，证明了上面说的</span><br><span class="line">Symbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;); // false，Symbol() 函数每次都会返回新的一个 symbol</span><br><span class="line"></span><br><span class="line">var sym = Symbol.for(&quot;mario&quot;);</span><br><span class="line">sym.toString(); </span><br><span class="line">// &quot;Symbol(mario)&quot;，mario 既是该 symbol 在 symbol 注册表中的键名，又是该 symbol 自身的描述字符串</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Symbol-keyFor-sym"><a href="#3-2-Symbol-keyFor-sym" class="headerlink" title="3.2 Symbol.keyFor(sym)"></a>3.2 Symbol.keyFor(sym)</h3><ul>
<li>该方法用来获取 <code>symbol</code> 注册表中与某个 <code>symbol</code> 关联的键。</li>
<li>参数 <code>sym</code> 是指存储在 <code>symbol</code> 注册表中的某个 <code>symbol</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 symbol 并放入 Symbol 注册表，key 为 &quot;foo&quot;</span><br><span class="line">var globalSym = Symbol.for(&quot;foo&quot;); </span><br><span class="line">Symbol.keyFor(globalSym); // &quot;foo&quot;</span><br><span class="line"></span><br><span class="line">// 创建一个 symbol，但不放入 symbol 注册表中</span><br><span class="line">var localSym = Symbol(); </span><br><span class="line">Symbol.keyFor(localSym); // undefined，所以是找不到 key 的</span><br></pre></td></tr></table></figure>

<h2 id="四、遍历"><a href="#四、遍历" class="headerlink" title="四、遍历"></a>四、遍历</h2><blockquote>
<p><code>Symbol</code>定义的属性不会出现在下面循环中</p>
</blockquote>
<ul>
<li><code>for in</code>:可获取原型属性，不可获取不可枚举属性</li>
<li><code>for of</code>:不可遍历对象，可遍历数组</li>
<li><code>Object.keys</code>：原型属性和不可枚举属性都不能获取</li>
<li><code>Object.getOwnPropertyByNames</code>：不可获取原型属性，可获取不可枚举属性</li>
<li><code>JSON.stringify</code>：原型属性和不可枚举属性都不能获取</li>
<li><code>Reflect.ownKeys</code>：可获取不可枚举和<code>Symbol</code>，不可获取原型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var p = &#123;w:2&#125;;</span><br><span class="line">var obj = Object.create(p);</span><br><span class="line">obj.a = 1;</span><br><span class="line">Object.defineProperty(obj,&quot;b&quot;,&#123;</span><br><span class="line">    value:123</span><br><span class="line">&#125;)</span><br><span class="line">var a = Symbol(&#x27;a&#x27;);</span><br><span class="line">var b = Symbol(&#x27;b&#x27;);</span><br><span class="line"></span><br><span class="line">obj[a] = &#x27;Hello&#x27;;</span><br><span class="line">obj[b] = &#x27;World&#x27;;</span><br><span class="line"></span><br><span class="line">Reflect.ownKeys(obj);// [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者使用<code>Object.getOwnPropertySymbols(obj)</code>遍历</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/12/html+css+js+ts/4-Symbol/" data-id="cl7ibzolc0081ugun30qi34o9" data-title="ES6 Symbol" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-set+map" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/10/html+css+js+ts/4-set+map/" class="article-date">
  <time class="dt-published" datetime="2018-04-10T03:21:26.000Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/10/html+css+js+ts/4-set+map/">ES6 Set-Map</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><code>Set</code> 和 <code>Map</code> 主要的应用场景在于 <strong>数据重组</strong> 和 <strong>数据储存</strong></li>
<li><code>Set</code> 是一种叫做<strong>集合</strong>的数据结构，Map 是一种叫做<strong>字典</strong>的数据结构</li>
</ul>
<h3 id="1-集合（Set）"><a href="#1-集合（Set）" class="headerlink" title="1. 集合（Set）"></a>1. 集合（Set）</h3><blockquote>
<p><code>ES6</code> 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</p>
</blockquote>
<p><strong>Set 本身是一种构造函数，用来生成 Set 数据结构。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Set([iterable])</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set()</span><br><span class="line">[1, 2, 3, 4, 3, 2, 1].forEach(x =&gt; s.add(x))</span><br><span class="line"></span><br><span class="line">for (let i of s) &#123;</span><br><span class="line">    console.log(i)	// 1 2 3 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 去重数组的重复对象</span><br><span class="line">let arr = [1, 2, 3, 2, 1, 1]</span><br><span class="line">[... new Set(arr)]	// [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。</p>
<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于<strong>精确相等</strong>运算符（<code>===</code>），主要的区别是 <strong>Set 认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set();</span><br><span class="line">let a = NaN;</span><br><span class="line">let b = NaN;</span><br><span class="line">set.add(a);</span><br><span class="line">set.add(b);</span><br><span class="line">set // Set &#123;NaN&#125;</span><br><span class="line"></span><br><span class="line">let set1 = new Set()</span><br><span class="line">set1.add(5)</span><br><span class="line">set1.add(&#x27;5&#x27;)</span><br><span class="line">console.log([...set1])	// [5, &quot;5&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Set 实例属性</p>
<ul>
<li><p>constructor： 构造函数</p>
</li>
<li><p>size：元素数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3, 2, 1])</span><br><span class="line"></span><br><span class="line">console.log(set.length)	// undefined</span><br><span class="line">console.log(set.size)	// 3</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Set 实例方法</p>
<ul>
<li><p>操作方法</p>
<ul>
<li><p>add(value)：新增，相当于 array里的push</p>
</li>
<li><p>delete(value)：存在即删除集合中value</p>
</li>
<li><p>has(value)：判断集合中是否存在 value</p>
</li>
<li><p>clear()：清空集合</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set()</span><br><span class="line">set.add(1).add(2).add(1)</span><br><span class="line"></span><br><span class="line">set.has(1)	// true</span><br><span class="line">set.has(3)	// false</span><br><span class="line">set.delete(1)	</span><br><span class="line">set.has(1)	// false</span><br></pre></td></tr></table></figure>

<p><code>Array.from</code> 方法可以将 Set 结构转为数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const items = new Set([1, 2, 3, 2])</span><br><span class="line">const array = Array.from(items)</span><br><span class="line">console.log(array)	// [1, 2, 3]</span><br><span class="line">// 或</span><br><span class="line">const arr = [...items]</span><br><span class="line">console.log(arr)	// [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>遍历方法（遍历顺序为插入顺序）</p>
<ul>
<li><p>keys()：返回一个包含集合中所有键的迭代器</p>
</li>
<li><p>values()：返回一个包含集合中所有值得迭代器</p>
</li>
<li><p>entries()：返回一个包含Set对象中所有元素得键值对迭代器</p>
</li>
<li><p>forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，<strong>没有返回值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3])</span><br><span class="line">console.log(set.keys())	// SetIterator &#123;1, 2, 3&#125;</span><br><span class="line">console.log(set.values())	// SetIterator &#123;1, 2, 3&#125;</span><br><span class="line">console.log(set.entries())	// SetIterator &#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">for (let item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;	// 1	2	 3</span><br><span class="line">for (let item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;	// [1, 1]	[2, 2]	[3, 3]</span><br><span class="line"></span><br><span class="line">set.forEach((value, key) =&gt;  &#123;</span><br><span class="line">    console.log(key + &#x27; : &#x27; + value)</span><br><span class="line">&#125;)	// 1 : 1	2 : 2		3 : 3</span><br><span class="line">console.log([...set])	// [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>Set 可默认遍历，默认迭代器生成函数是 values() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set.prototype[Symbol.iterator] === Set.prototype.values	// true</span><br></pre></td></tr></table></figure>

<p>所以， Set可以使用 map、filter 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3])</span><br><span class="line">set = new Set([...set].map(item =&gt; item * 2))</span><br><span class="line">console.log([...set])	// [2, 4, 6]</span><br><span class="line"></span><br><span class="line">set = new Set([...set].filter(item =&gt; (item &gt;= 4)))</span><br><span class="line">console.log([...set])	//[4, 6]</span><br></pre></td></tr></table></figure>

<p>因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let set1 = new Set([1, 2, 3])</span><br><span class="line">let set2 = new Set([4, 3, 2])</span><br><span class="line"></span><br><span class="line">let intersect = new Set([...set1].filter(value =&gt; set2.has(value)))</span><br><span class="line">let union = new Set([...set1, ...set2])</span><br><span class="line">let difference = new Set([...set1].filter(value =&gt; !set2.has(value)))</span><br><span class="line"></span><br><span class="line">console.log(intersect)	// Set &#123;2, 3&#125;</span><br><span class="line">console.log(union)		// Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">console.log(difference)	// Set &#123;1&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2. WeakSet"></a>2. WeakSet</h3><p>WeakSet 对象允许你将<strong>弱引用对象</strong>储存在一个集合中</p>
<p>WeakSet 与 Set 的区别：</p>
<ul>
<li>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</li>
<li>WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素</li>
</ul>
<p>属性：</p>
<ul>
<li><p>constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [[1, 2], [3, 4]]</span><br><span class="line">const weakset = new WeakSet(arr)</span><br><span class="line">console.log(weakset)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/19721451/54000905-3d36c980-4184-11e9-9ccf-0f13bc6dd414.png" alt="2019-03-08 9 24 34"></p>
<p>方法：</p>
<ul>
<li>add(value)：在WeakSet 对象中添加一个元素value</li>
<li>has(value)：判断 WeakSet 对象中是否包含value</li>
<li>delete(value)：删除元素 value</li>
<li>clear()：清空所有元素，<strong>注意该方法已废弃</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WeakSet()</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">var foo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">ws.add(window)</span><br><span class="line">ws.add(obj)</span><br><span class="line"></span><br><span class="line">ws.has(window)	// true</span><br><span class="line">ws.has(foo)	// false</span><br><span class="line"></span><br><span class="line">ws.delete(window)	// true</span><br><span class="line">ws.has(window)	// false</span><br></pre></td></tr></table></figure>

<h3 id="3-字典（Map）"><a href="#3-字典（Map）" class="headerlink" title="3. 字典（Map）"></a>3. 字典（Map）</h3><p>集合 与 字典 的区别：</p>
<ul>
<li>共同点：集合、字典 可以储存不重复的值</li>
<li>不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map()</span><br><span class="line">const o = &#123;p: &#x27;haha&#x27;&#125;</span><br><span class="line">m.set(o, &#x27;content&#x27;)</span><br><span class="line">m.get(o)	// content</span><br><span class="line"></span><br><span class="line">m.has(o)	// true</span><br><span class="line">m.delete(o)	// true</span><br><span class="line">m.has(o)	// false</span><br></pre></td></tr></table></figure>

<p><strong>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构</strong>都可以当作<code>Map</code>构造函数的参数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([</span><br><span class="line">  [&#x27;foo&#x27;, 1],</span><br><span class="line">  [&#x27;bar&#x27;, 2]</span><br><span class="line">]);</span><br><span class="line">const m1 = new Map(set);</span><br><span class="line">m1.get(&#x27;foo&#x27;) // 1</span><br><span class="line"></span><br><span class="line">const m2 = new Map([[&#x27;baz&#x27;, 3]]);</span><br><span class="line">const m3 = new Map(m2);</span><br><span class="line">m3.get(&#x27;baz&#x27;) // 3</span><br></pre></td></tr></table></figure>

<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Map().get(&#x27;asfddfsasadf&#x27;)</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure>

<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([&#x27;a&#x27;], 555);</span><br><span class="line">map.get([&#x27;a&#x27;]) // undefined</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>
<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line"></span><br><span class="line">map.set(-0, 123);</span><br><span class="line">map.get(+0) // 123</span><br><span class="line"></span><br><span class="line">map.set(true, 1);</span><br><span class="line">map.set(&#x27;true&#x27;, 2);</span><br><span class="line">map.get(true) // 1</span><br><span class="line"></span><br><span class="line">map.set(undefined, 3);</span><br><span class="line">map.set(null, 4);</span><br><span class="line">map.get(undefined) // 3</span><br><span class="line"></span><br><span class="line">map.set(NaN, 123);</span><br><span class="line">map.get(NaN) // 123</span><br></pre></td></tr></table></figure>

<p>Map 的属性及方法</p>
<p>属性：</p>
<ul>
<li><p>constructor：构造函数</p>
</li>
<li><p>size：返回字典中所包含的元素个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [&#x27;name&#x27;, &#x27;An&#x27;],</span><br><span class="line">  [&#x27;des&#x27;, &#x27;JS&#x27;]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br></pre></td></tr></table></figure></li>
</ul>
<p>操作方法：</p>
<ul>
<li>set(key, value)：向字典中添加新元素</li>
<li>get(key)：通过键查找特定的数值并返回</li>
<li>has(key)：判断字典中是否存在键key</li>
<li>delete(key)：通过键 key 从字典中移除对应的数据</li>
<li>clear()：将这个字典中的所有元素删除</li>
</ul>
<p>遍历方法</p>
<ul>
<li>Keys()：将字典中包含的所有键名以迭代器形式返回</li>
<li>values()：将字典中包含的所有数值以迭代器形式返回</li>
<li>entries()：返回所有成员的迭代器</li>
<li>forEach()：遍历字典的所有成员</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">            [&#x27;name&#x27;, &#x27;An&#x27;],</span><br><span class="line">            [&#x27;des&#x27;, &#x27;JS&#x27;]</span><br><span class="line">        ]);</span><br><span class="line">console.log(map.entries())	// MapIterator &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span><br><span class="line">console.log(map.keys()) // MapIterator &#123;&quot;name&quot;, &quot;des&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[Symbol.iterator] === map.entries</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>

<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p>
<p>对于 forEach ，看一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const reporter = &#123;</span><br><span class="line">  report: function(key, value) &#123;</span><br><span class="line">    console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let map = new Map([</span><br><span class="line">    [&#x27;name&#x27;, &#x27;An&#x27;],</span><br><span class="line">    [&#x27;des&#x27;, &#x27;JS&#x27;]</span><br><span class="line">])</span><br><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  this.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br><span class="line">// Key: name, Value: An</span><br><span class="line">// Key: des, Value: JS</span><br></pre></td></tr></table></figure>

<p>在这个例子中， forEach 方法的回调函数的 this，就指向 reporter</p>
<p><strong>与其他数据结构的相互转换</strong></p>
<ol>
<li><p>Map 转 Array</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([[1, 1], [2, 2], [3, 3]])</span><br><span class="line">console.log([...map])	// [[1, 1], [2, 2], [3, 3]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Array 转 Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([[1, 1], [2, 2], [3, 3]])</span><br><span class="line">console.log(map)	// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map 转 Object</p>
<p>因为 Object 的键名都为字符串，而Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function mapToObj(map) &#123;</span><br><span class="line">    let obj = Object.create(null)</span><br><span class="line">    for (let [key, value] of map) &#123;</span><br><span class="line">        obj[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line">const map = new Map().set(&#x27;name&#x27;, &#x27;An&#x27;).set(&#x27;des&#x27;, &#x27;JS&#x27;)</span><br><span class="line">mapToObj(map) // &#123;name: &quot;An&quot;, des: &quot;JS&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object 转 Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function objToMap(obj) &#123;</span><br><span class="line">    let map = new Map()</span><br><span class="line">    for (let key of Object.keys(obj)) &#123;</span><br><span class="line">        map.set(key, obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">    return map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToMap(&#123;&#x27;name&#x27;: &#x27;An&#x27;, &#x27;des&#x27;: &#x27;JS&#x27;&#125;) // Map &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map 转 JSON</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function mapToJson(map) &#123;</span><br><span class="line">    return JSON.stringify([...map])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let map = new Map().set(&#x27;name&#x27;, &#x27;An&#x27;).set(&#x27;des&#x27;, &#x27;JS&#x27;)</span><br><span class="line">mapToJson(map)	// [[&quot;name&quot;,&quot;An&quot;],[&quot;des&quot;,&quot;JS&quot;]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON 转 Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function jsonToStrMap(jsonStr) &#123;</span><br><span class="line">  return objToMap(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(&#x27;&#123;&quot;name&quot;: &quot;An&quot;, &quot;des&quot;: &quot;JS&quot;&#125;&#x27;) // Map &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4. WeakMap"></a>4. WeakMap</h3><p>WeakMap 对象是一组键值对的集合，其中的<strong>键是弱引用对象，而值可以是任意</strong>。</p>
<p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong></p>
<p>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。</p>
<p>属性：</p>
<ul>
<li>constructor：构造函数</li>
</ul>
<p>方法：</p>
<ul>
<li>has(key)：判断是否有 key 关联对象</li>
<li>get(key)：返回key关联对象（没有则则返回 undefined）</li>
<li>set(key)：设置一组key关联对象</li>
<li>delete(key)：移除 key 的关联对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let myElement = document.getElementById(&#x27;logo&#x27;);</span><br><span class="line">let myWeakmap = new WeakMap();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);</span><br><span class="line"></span><br><span class="line">myElement.addEventListener(&#x27;click&#x27;, function() &#123;</span><br><span class="line">  let logoData = myWeakmap.get(myElement);</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li>Set<ul>
<li>成员唯一、无序且不重复</li>
<li>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）</li>
<li>可以遍历，方法有：add、delete、has</li>
</ul>
</li>
<li>WeakSet<ul>
<li>成员都是对象</li>
<li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏</li>
<li>不能遍历，方法有add、delete、has</li>
</ul>
</li>
<li>Map<ul>
<li>本质上是键值对的集合，类似集合</li>
<li>可以遍历，方法很多可以跟各种数据格式转换</li>
</ul>
</li>
<li>WeakMap<ul>
<li>只接受对象作为键名（null除外），不接受其他类型的值作为键名</li>
<li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li>
<li>不能遍历，方法有get、set、has、delete</li>
</ul>
</li>
</ul>
<h3 id="6-扩展：Object与Set、Map"><a href="#6-扩展：Object与Set、Map" class="headerlink" title="6. 扩展：Object与Set、Map"></a>6. 扩展：Object与Set、Map</h3><ol>
<li><p>Object 与 Set</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Object</span><br><span class="line">const properties1 = &#123;</span><br><span class="line">    &#x27;width&#x27;: 1,</span><br><span class="line">    &#x27;height&#x27;: 1</span><br><span class="line">&#125;</span><br><span class="line">console.log(properties1[&#x27;width&#x27;]? true: false) // true</span><br><span class="line"></span><br><span class="line">// Set</span><br><span class="line">const properties2 = new Set()</span><br><span class="line">properties2.add(&#x27;width&#x27;)</span><br><span class="line">properties2.add(&#x27;height&#x27;)</span><br><span class="line">console.log(properties2.has(&#x27;width&#x27;)) // true</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object 与 Map</p>
</li>
</ol>
<p>JS 中的对象（Object），本质上是键值对的集合（hash 结构）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;&#125;;</span><br><span class="line">const element = document.getElementsByClassName(&#x27;App&#x27;);</span><br><span class="line"></span><br><span class="line">data[element] = &#x27;metadata&#x27;;</span><br><span class="line">console.log(data[&#x27;[object HTMLCollection]&#x27;]) // &quot;metadata&quot;</span><br></pre></td></tr></table></figure>

<p>但当以一个DOM节点作为对象 data 的键，对象会被自动转化为字符串[Object HTMLCollection]，所以说，Object 结构提供了 <strong>字符串-值</strong> 对应，Map则提供了 <strong>值-值</strong> 的对应</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/10/html+css+js+ts/4-set+map/" data-id="cl7ibzolb007wugunf6boh47x" data-title="ES6 Set-Map" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-Reflect" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/07/html+css+js+ts/4-Reflect/" class="article-date">
  <time class="dt-published" datetime="2018-04-07T06:32:15.000Z" itemprop="datePublished">2018-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/07/html+css+js+ts/4-Reflect/">ES6 Reflect</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-1-什么是Reflect"><a href="#1-1-什么是Reflect" class="headerlink" title="1.1 什么是Reflect"></a>1.1 什么是Reflect</h3><blockquote>
<p>为操作对象而提供的新<code>API</code></p>
</blockquote>
<h3 id="1-2-为什么要设计Reflect"><a href="#1-2-为什么要设计Reflect" class="headerlink" title="1.2 为什么要设计Reflect"></a>1.2 为什么要设计Reflect</h3><ol>
<li>将<code>Object</code>对象的属于语言内部的方法放到<code>Reflect</code>对象上，即从<code>Reflect</code>对象上拿<code>Object</code>对象内部方法</li>
<li>将用老<code>Object</code>方法报错的情况，改为返回<code>false</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 旧写法</span><br><span class="line">try &#123;</span><br><span class="line">  Object.defineProperty(target, property, attributes);</span><br><span class="line">  // success</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;</span><br><span class="line">// 新写法</span><br><span class="line">if (Reflect.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>让<code>Object</code>操作变成函数行为</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 旧写法</span><br><span class="line">&#x27;name&#x27; in Object //true</span><br><span class="line">// 新写法</span><br><span class="line">Reflect.has(Object,&#x27;name&#x27;) //true</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Reflect</code>与<code>Proxy</code>是相辅相成的，在<code>Proxy</code>上有的方法，在<code>Reflect</code>就一定有</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let target=&#123;&#125;</span><br><span class="line">let handler=&#123;</span><br><span class="line">  set(target,proName,proValue,receiver)&#123;</span><br><span class="line">    //确认对象的属性赋值成功</span><br><span class="line">    let isSuccess=Reflect.set(target,proName,proValue,receiver)</span><br><span class="line">    if(isSuccess)&#123;</span><br><span class="line">      console.log(&quot;成功&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return isSuccess</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let proxy=new Proxy(target,handler)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>确保对象的属性能正确赋值，广义上讲，即确保对象的原生行为能够正常进行，这就是<code>Reflect</code>的作用</p>
</blockquote>
<h2 id="二、Reflect的API"><a href="#二、Reflect的API" class="headerlink" title="二、Reflect的API"></a>二、Reflect的API</h2><blockquote>
<p>注：和<code>Proxy</code>的<code>API</code>一致</p>
</blockquote>
<h3 id="2-1-Reflect-get-target-property-receiver"><a href="#2-1-Reflect-get-target-property-receiver" class="headerlink" title="2.1 Reflect.get(target,property,receiver)"></a>2.1 Reflect.get(target,property,receiver)</h3><blockquote>
<p>查找并返回<code>target</code>对象的<code>property</code>属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">  name:&quot;poetries&quot;,</span><br><span class="line">&#125;</span><br><span class="line">let result=Reflect.get(obj,&quot;name&quot;)</span><br><span class="line">console.log(result) //poetries</span><br><span class="line">let obj=&#123;</span><br><span class="line">  //属性yu部署了getter读取函数</span><br><span class="line">  get yu()&#123;</span><br><span class="line">    //this返回的是Reflect.get的receiver参数对象</span><br><span class="line">    return this.name+this.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let receiver=&#123;</span><br><span class="line">  name:&quot;shen&quot;,</span><br><span class="line">  age:&quot;18&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let result=Reflect.get(obj,&quot;yu&quot;,receiver)</span><br><span class="line">console.log(result) //shen18</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果<code>Reflect.get()</code>的第一个参数不是对象，则会报错</p>
</blockquote>
<h3 id="2-2-Reflect-set-target-propName-propValue-receiver"><a href="#2-2-Reflect-set-target-propName-propValue-receiver" class="headerlink" title="2.2 Reflect.set(target,propName,propValue,receiver)"></a>2.2 Reflect.set(target,propName,propValue,receiver)</h3><blockquote>
<p>设置<code>target</code>对象的<code>propName</code>属性为<code>propValue</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">  name:&quot;poetries&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let result=Reflect.set(obj,&quot;name&quot;,&quot;静观流叶&quot;)</span><br><span class="line">console.log(result) //true</span><br><span class="line">console.log(obj.name) //静观流叶</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Reflect-set与Proxy-set"><a href="#2-3-Reflect-set与Proxy-set" class="headerlink" title="2.3 Reflect.set与Proxy.set"></a>2.3 Reflect.set与Proxy.set</h3><blockquote>
<p><code>Reflect.set</code>与<code>Proxy.set</code>联合使用,并且传入<code>receiver</code>，则会进行定义属性操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">  name:&quot;chen&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let handler=&#123;</span><br><span class="line">  set(target,key,value,receiver)&#123;</span><br><span class="line">    console.log(&quot;Proxy拦截赋值操作&quot;)</span><br><span class="line">    //Reflect完成赋值操作</span><br><span class="line">    Reflect.set(target,key,value,receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  defineProperty(target,key,attribute)&#123;</span><br><span class="line">    console.log(&quot;Proxy拦截定义属性操作&quot;)</span><br><span class="line">    //Reflect完成定义属性操作</span><br><span class="line">    Reflect.defineProperty(target,key,attribute)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let proxy=new Proxy(obj,handler)</span><br><span class="line">proxy.name=&quot;ya&quot;</span><br><span class="line">//Proxy拦截赋值操作</span><br><span class="line">//Proxy拦截定义属性操作</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么Reflect.set()传入receiver参数，就会触发定义属性的操作？</p>
</blockquote>
<p>因为<code>Proxy.set()</code>中的<code>receiver</code>是<code>Proxy</code>的实例，即<code>obj</code>，而<code>Reflect.set</code>一旦传入<code>receiver</code>，就会将属性赋值到<code>receiver</code>上面，也是<code>obj</code>，所以就会触发<code>defineProperty</code>拦截</p>
<h3 id="2-4-Reflect-has-obj-name"><a href="#2-4-Reflect-has-obj-name" class="headerlink" title="2.4 Reflect.has(obj,name)"></a>2.4 Reflect.has(obj,name)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj= &#123;</span><br><span class="line">  name: &quot;poetries&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">//旧写法</span><br><span class="line">&#x27;name&#x27; in obj // true</span><br><span class="line">//新写法</span><br><span class="line">Reflect.has(obj, &#x27;name&#x27;) // true</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Reflect-deleteProperty-obj-name"><a href="#2-5-Reflect-deleteProperty-obj-name" class="headerlink" title="2.5 Reflect.deleteProperty(obj, name)"></a>2.5 Reflect.deleteProperty(obj, name)</h3><blockquote>
<p>删除对象的属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 旧写法</span><br><span class="line">delete obj.name;</span><br><span class="line">// 新写法</span><br><span class="line">Reflect.deleteProperty(obj, &#x27;name&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="2-6-Reflect-construct-target-args"><a href="#2-6-Reflect-construct-target-args" class="headerlink" title="2.6 Reflect.construct(target, args)"></a>2.6 Reflect.construct(target, args)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">// 旧 new写法</span><br><span class="line">let person= new Person(&#x27;poetries&#x27;)</span><br><span class="line">// 新写法：Reflect.construct 的写法</span><br><span class="line">let person = Reflect.construct(Person, [&#x27;poetries&#x27;]);</span><br></pre></td></tr></table></figure>

<h3 id="2-7-Reflect-getPrototypeOf-obj"><a href="#2-7-Reflect-getPrototypeOf-obj" class="headerlink" title="2.7 Reflect.getPrototypeOf(obj)"></a>2.7 Reflect.getPrototypeOf(obj)</h3><blockquote>
<p>用于读取对象的<code>proto</code>属性，对应<code>Object.getPrototypeOf(obj)</code></p>
</blockquote>
<h3 id="2-8-Reflect-setPrototypeOf-obj-newProto"><a href="#2-8-Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="2.8 Reflect.setPrototypeOf(obj, newProto)"></a>2.8 Reflect.setPrototypeOf(obj, newProto)</h3><blockquote>
<p>设置目标对象的原型（<code>prototype</code>），对应<code>Object.setPrototypeOf(obj, newProto)</code>方法</p>
</blockquote>
<h3 id="2-9-Reflect-apply-func-thisArg-args"><a href="#2-9-Reflect-apply-func-thisArg-args" class="headerlink" title="2.9 Reflect.apply(func, thisArg, args)"></a>2.9 Reflect.apply(func, thisArg, args)</h3><blockquote>
<p>继承目标对象的特定方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let array=[1,2,3,4,5,6]</span><br><span class="line">// 旧写法</span><br><span class="line">let small= Math.min.apply(Math, array) //1</span><br><span class="line">let big = Math.max.apply(Math, array) //6</span><br><span class="line">let type = Object.prototype.toString.call(small) //&quot;[object Number]&quot;</span><br><span class="line">// 新写法</span><br><span class="line">const small= Reflect.apply(Math.min, Math, array)</span><br><span class="line">const big = Reflect.apply(Math.max, Math, array)</span><br><span class="line">//第三个参数是Object类型的就好，因为调用的是Object的原型方法toString</span><br><span class="line">const type = Reflect.apply(Object.prototype.toString, small, [])</span><br></pre></td></tr></table></figure>

<h3 id="2-10-Reflect-defineProperty-target-propertyKey-attributes"><a href="#2-10-Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="2.10 Reflect.defineProperty(target, propertyKey, attributes)"></a>2.10 Reflect.defineProperty(target, propertyKey, attributes)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function MyDate() &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">// 旧写法</span><br><span class="line">Object.defineProperty(MyDate, &#x27;now&#x27;, &#123;</span><br><span class="line">  value: () =&gt; Date.now()</span><br><span class="line">&#125;);</span><br><span class="line">// 新写法</span><br><span class="line">Reflect.defineProperty(MyDate, &#x27;now&#x27;, &#123;</span><br><span class="line">  value: () =&gt; Date.now()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与<code>Proxy.defineProperty</code>配合使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  defineProperty(target, prop, descriptor) &#123;</span><br><span class="line">    console.log(descriptor);</span><br><span class="line">    return Reflect.defineProperty(target, prop, descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy .name= &#x27;chen&#x27;;</span><br><span class="line">// &#123;value: &quot;chen&quot;, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">p.name // &quot;chen&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上，<code>Proxy.defineProperty</code>对属性赋值设置拦截，然后使用<code>Reflect.defineProperty</code>完成赋值</p>
</blockquote>
<h3 id="2-11-Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#2-11-Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="2.11 Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>2.11 Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3><blockquote>
<p>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象</p>
</blockquote>
<h3 id="2-12-Reflect-isExtensible-target"><a href="#2-12-Reflect-isExtensible-target" class="headerlink" title="2.12 Reflect.isExtensible (target)"></a>2.12 Reflect.isExtensible (target)</h3><blockquote>
<p>对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展</p>
</blockquote>
<h3 id="2-13-Reflect-preventExtensions-target"><a href="#2-13-Reflect-preventExtensions-target" class="headerlink" title="2.13 Reflect.preventExtensions(target)"></a>2.13 Reflect.preventExtensions(target)</h3><blockquote>
<p>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功</p>
</blockquote>
<h3 id="2-14-Reflect-ownKeys-target"><a href="#2-14-Reflect-ownKeys-target" class="headerlink" title="2.14 Reflect.ownKeys (target)"></a>2.14 Reflect.ownKeys (target)</h3><blockquote>
<p>用于返回对象的所有属性</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/07/html+css+js+ts/4-Reflect/" data-id="cl7ibzolb007yugunawfygyhi" data-title="ES6 Reflect" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-Proxy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/05/html+css+js+ts/4-Proxy/" class="article-date">
  <time class="dt-published" datetime="2018-04-05T12:13:50.000Z" itemprop="datePublished">2018-04-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/05/html+css+js+ts/4-Proxy/">ES6 Proxy</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、proxy概述"><a href="#一、proxy概述" class="headerlink" title="一、proxy概述"></a>一、proxy概述</h2><p><strong>Proxy的兼容性</strong></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/55.png" alt="img"></p>
<blockquote>
<p><code>proxy</code>在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(target, handler);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123;</span><br><span class="line">   name: &#x27;poetries&#x27;</span><br><span class="line"> &#125;;</span><br><span class="line"> var logHandler = &#123;</span><br><span class="line">   get: function(target, key) &#123;</span><br><span class="line">     console.log(`$&#123;key&#125; 被读取`);</span><br><span class="line">     return target[key];</span><br><span class="line">   &#125;,</span><br><span class="line">   set: function(target, key, value) &#123;</span><br><span class="line">     console.log(`$&#123;key&#125; 被设置为 $&#123;value&#125;`);</span><br><span class="line">     target[key] = value;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> var targetWithLog = new Proxy(target, logHandler);</span><br><span class="line"> </span><br><span class="line"> targetWithLog.name; // 控制台输出：name 被读取</span><br><span class="line"> targetWithLog.name = &#x27;others&#x27;; // 控制台输出：name 被设置为 others</span><br><span class="line"> </span><br><span class="line"> console.log(target.name); // 控制台输出: others</span><br></pre></td></tr></table></figure>

<ul>
<li><code>targetWithLog</code> 读取属性的值时，实际上执行的是 <code>logHandler.get</code> ：在控制台输出信息，并且读取被代理对象 <code>target</code> 的属性。</li>
<li>在 <code>targetWithLog</code> 设置属性值时，实际上执行的是 <code>logHandler.set</code> ：在控制台输出信息，并且设置被代理对象 <code>target</code> 的属性的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 由于拦截函数总是返回35，所以访问任何属性都得到35</span><br><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time // 35</span><br><span class="line">proxy.name // 35</span><br><span class="line">proxy.title // 35</span><br></pre></td></tr></table></figure>

<p><strong>Proxy 实例也可以作为其他对象的原型对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let obj = Object.create(proxy);</span><br><span class="line">obj.time // 35</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截</p>
</blockquote>
<p><strong>Proxy的作用</strong></p>
<blockquote>
<p>对于代理模式 <code>Proxy</code> 的作用主要体现在三个方面</p>
</blockquote>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<h2 id="二、Proxy所能代理的范围–handler"><a href="#二、Proxy所能代理的范围–handler" class="headerlink" title="二、Proxy所能代理的范围–handler"></a>二、Proxy所能代理的范围–handler</h2><blockquote>
<p>实际上 <code>handler</code> 本身就是<code>ES6</code>所新设计的一个对象.它的作用就是用来 自定义代理对象的各种可代理操作 。它本身一共有<code>13</code>中方法,每种方法都可以代理一种操作.其<code>13</code>种方法如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span><br><span class="line">handler.getPrototypeOf()</span><br><span class="line"></span><br><span class="line">// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span><br><span class="line">handler.setPrototypeOf()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span><br><span class="line">handler.isExtensible()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span><br><span class="line">handler.preventExtensions()</span><br><span class="line"></span><br><span class="line">// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。</span><br><span class="line">handler.getOwnPropertyDescriptor()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。</span><br><span class="line">andler.defineProperty()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。</span><br><span class="line">handler.has()</span><br><span class="line"></span><br><span class="line">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span><br><span class="line">handler.get()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span><br><span class="line">handler.set()</span><br><span class="line"></span><br><span class="line">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span><br><span class="line">handler.deleteProperty()</span><br><span class="line"></span><br><span class="line">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span><br><span class="line">handler.ownKeys()</span><br><span class="line"></span><br><span class="line">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span><br><span class="line">handler.apply()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span><br><span class="line">handler.construct()</span><br></pre></td></tr></table></figure>

<h2 id="三、Proxy场景"><a href="#三、Proxy场景" class="headerlink" title="三、Proxy场景"></a>三、Proxy场景</h2><h3 id="3-1-实现私有变量"><a href="#3-1-实现私有变量" class="headerlink" title="3.1 实现私有变量"></a>3.1 实现私有变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123;</span><br><span class="line">   name: &#x27;poetries&#x27;,</span><br><span class="line">   _age: 22</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logHandler = &#123;</span><br><span class="line">  get: function(target,key)&#123;</span><br><span class="line">    if(key.startsWith(&#x27;_&#x27;))&#123;</span><br><span class="line">      console.log(&#x27;私有变量age不能被访问&#x27;)</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    return target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function(target, key, value) &#123;</span><br><span class="line">     if(key.startsWith(&#x27;_&#x27;))&#123;</span><br><span class="line">      console.log(&#x27;私有变量age不能被修改&#x27;)</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">     target[key] = value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line">var targetWithLog = new Proxy(target, logHandler);</span><br><span class="line"> </span><br><span class="line">// 私有变量age不能被访问</span><br><span class="line">targetWithLog.name; </span><br><span class="line"> </span><br><span class="line">// 私有变量age不能被修改</span><br><span class="line">targetWithLog.name = &#x27;others&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在下面的代码中，我们声明了一个私有的 <code>apiKey</code>，便于 <code>api</code> 这个对象内部的方法调用，但不希望从外部也能够访问 <code>api._apiKey</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var api = &#123;  </span><br><span class="line">    _apiKey: &#x27;123abc456def&#x27;,</span><br><span class="line">    /* mock methods that use this._apiKey */</span><br><span class="line">    getUsers: function()&#123;&#125;, </span><br><span class="line">    getUser: function(userId)&#123;&#125;, </span><br><span class="line">    setUser: function(userId, config)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// logs &#x27;123abc456def&#x27;;</span><br><span class="line">console.log(&quot;An apiKey we want to keep private&quot;, api._apiKey);</span><br><span class="line"></span><br><span class="line">// get and mutate _apiKeys as desired</span><br><span class="line">var apiKey = api._apiKey;  </span><br><span class="line">api._apiKey = &#x27;987654321&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很显然，约定俗成是没有束缚力的。使用 <code>ES6 Proxy</code> 我们就可以实现真实的私有变量了，下面针对不同的读取方式演示两个不同的私有化方法。第一种方法是使用 <code>set / get</code> 拦截读写请求并返回 <code>undefined</code>:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let api = &#123;  </span><br><span class="line">    _apiKey: &#x27;123abc456def&#x27;,</span><br><span class="line">    getUsers: function()&#123; &#125;, </span><br><span class="line">    getUser: function(userId)&#123; &#125;, </span><br><span class="line">    setUser: function(userId, config)&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const RESTRICTED = [&#x27;_apiKey&#x27;];</span><br><span class="line">api = new Proxy(api, &#123;  </span><br><span class="line">    get(target, key, proxy) &#123;</span><br><span class="line">        if(RESTRICTED.indexOf(key) &gt; -1) &#123;</span><br><span class="line">            throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`);</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.get(target, key, proxy);</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, value, proxy) &#123;</span><br><span class="line">        if(RESTRICTED.indexOf(key) &gt; -1) &#123;</span><br><span class="line">            throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`);</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.get(target, key, value, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 以下操作都会抛出错误</span><br><span class="line">console.log(api._apiKey);</span><br><span class="line">api._apiKey = &#x27;987654321&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二种方法是使用 <code>has</code> 拦截 <code>in</code> 操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var api = &#123;  </span><br><span class="line">    _apiKey: &#x27;123abc456def&#x27;,</span><br><span class="line">    getUsers: function()&#123; &#125;, </span><br><span class="line">    getUser: function(userId)&#123; &#125;, </span><br><span class="line">    setUser: function(userId, config)&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const RESTRICTED = [&#x27;_apiKey&#x27;];</span><br><span class="line">api = new Proxy(api, &#123;  </span><br><span class="line">    has(target, key) &#123;</span><br><span class="line">        return (RESTRICTED.indexOf(key) &gt; -1) ?</span><br><span class="line">            false :</span><br><span class="line">            Reflect.has(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// these log false, and `for in` iterators will ignore _apiKey</span><br><span class="line">console.log(&quot;_apiKey&quot; in api);</span><br><span class="line"></span><br><span class="line">for (var key in api) &#123;  </span><br><span class="line">    if (api.hasOwnProperty(key) &amp;&amp; key === &quot;_apiKey&quot;) &#123;</span><br><span class="line">        console.log(&quot;This will never be logged because the proxy obscures _apiKey...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-抽离校验模块"><a href="#3-2-抽离校验模块" class="headerlink" title="3.2 抽离校验模块"></a>3.2 抽离校验模块</h3><blockquote>
<p>让我们从一个简单的类型校验开始做起，这个示例演示了如何使用 <code>Proxy</code> 保障数据类型的准确性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let numericDataStore = &#123;  </span><br><span class="line">    count: 0,</span><br><span class="line">    amount: 1234,</span><br><span class="line">    total: 14</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">numericDataStore = new Proxy(numericDataStore, &#123;  </span><br><span class="line">    set(target, key, value, proxy) &#123;</span><br><span class="line">        if (typeof value !== &#x27;number&#x27;) &#123;</span><br><span class="line">            throw Error(&quot;Properties in numericDataStore can only be numbers&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.set(target, key, value, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 抛出错误，因为 &quot;foo&quot; 不是数值</span><br><span class="line">numericDataStore.count = &quot;foo&quot;;</span><br><span class="line"></span><br><span class="line">// 赋值成功</span><br><span class="line">numericDataStore.count = 333;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果要直接为对象的所有属性开发一个校验器可能很快就会让代码结构变得臃肿，使用 <code>Proxy</code> 则可以将校验器从核心逻辑分离出来自成一体</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function createValidator(target, validator) &#123;  </span><br><span class="line">    return new Proxy(target, &#123;</span><br><span class="line">        _validator: validator,</span><br><span class="line">        set(target, key, value, proxy) &#123;</span><br><span class="line">            if (target.hasOwnProperty(key)) &#123;</span><br><span class="line">                let validator = this._validator[key];</span><br><span class="line">                if (!!validator(value)) &#123;</span><br><span class="line">                    return Reflect.set(target, key, value, proxy);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw Error(`Cannot set $&#123;key&#125; to $&#123;value&#125;. Invalid.`);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw Error(`$&#123;key&#125; is not a valid property`)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const personValidators = &#123;  </span><br><span class="line">    name(val) &#123;</span><br><span class="line">        return typeof val === &#x27;string&#x27;;</span><br><span class="line">    &#125;,</span><br><span class="line">    age(val) &#123;</span><br><span class="line">        return typeof age === &#x27;number&#x27; &amp;&amp; age &gt; 18;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;  </span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        return createValidator(this, personValidators);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const bill = new Person(&#x27;Bill&#x27;, 25);</span><br><span class="line"></span><br><span class="line">// 以下操作都会报错</span><br><span class="line">bill.name = 0;  </span><br><span class="line">bill.age = &#x27;Bill&#x27;;  </span><br><span class="line">bill.age = 15;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过校验器和主逻辑的分离，你可以无限扩展 <code>personValidators</code> 校验器的内容，而不会对相关的类或函数造成直接破坏。更复杂一点，我们还可以使用 <code>Proxy</code> 模拟类型检查，检查函数是否接收了类型和数量都正确的参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;  </span><br><span class="line">    pickyMethodOne: function(obj, str, num) &#123; /* ... */ &#125;,</span><br><span class="line">    pickyMethodTwo: function(num, obj) &#123; /*... */ &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const argTypes = &#123;  </span><br><span class="line">    pickyMethodOne: [&quot;object&quot;, &quot;string&quot;, &quot;number&quot;],</span><br><span class="line">    pickyMethodTwo: [&quot;number&quot;, &quot;object&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj = new Proxy(obj, &#123;  </span><br><span class="line">    get: function(target, key, proxy) &#123;</span><br><span class="line">        var value = target[key];</span><br><span class="line">        return function(...args) &#123;</span><br><span class="line">            var checkArgs = argChecker(key, args, argTypes[key]);</span><br><span class="line">            return Reflect.apply(value, target, args);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function argChecker(name, args, checkers) &#123;  </span><br><span class="line">    for (var idx = 0; idx &lt; args.length; idx++) &#123;</span><br><span class="line">        var arg = args[idx];</span><br><span class="line">        var type = checkers[idx];</span><br><span class="line">        if (!arg || typeof arg !== type) &#123;</span><br><span class="line">            console.warn(`You are incorrectly implementing the signature of $&#123;name&#125;. Check param $&#123;idx + 1&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.pickyMethodOne();  </span><br><span class="line">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 1</span><br><span class="line">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 2</span><br><span class="line">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 3</span><br><span class="line"></span><br><span class="line">obj.pickyMethodTwo(&quot;wopdopadoo&quot;, &#123;&#125;);  </span><br><span class="line">// &gt; You are incorrectly implementing the signature of pickyMethodTwo. Check param 1</span><br><span class="line"></span><br><span class="line">// No warnings logged</span><br><span class="line">obj.pickyMethodOne(&#123;&#125;, &quot;a little string&quot;, 123);  </span><br><span class="line">obj.pickyMethodOne(123, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-访问日志"><a href="#3-3-访问日志" class="headerlink" title="3.3 访问日志"></a>3.3 访问日志</h3><blockquote>
<p>对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，开发者会希望记录它们的使用情况或性能表现，这个时候就可以使用 <code>Proxy</code> 充当中间件的角色，轻而易举实现日志功能</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let api = &#123;  </span><br><span class="line">    _apiKey: &#x27;123abc456def&#x27;,</span><br><span class="line">    getUsers: function() &#123; /* ... */ &#125;,</span><br><span class="line">    getUser: function(userId) &#123; /* ... */ &#125;,</span><br><span class="line">    setUser: function(userId, config) &#123; /* ... */ &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function logMethodAsync(timestamp, method) &#123;  </span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`);</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api = new Proxy(api, &#123;  </span><br><span class="line">    get: function(target, key, proxy) &#123;</span><br><span class="line">        var value = target[key];</span><br><span class="line">        return function(...arguments) &#123;</span><br><span class="line">            logMethodAsync(new Date(), key);</span><br><span class="line">            return Reflect.apply(value, target, arguments);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">api.getUsers();</span><br></pre></td></tr></table></figure>

<h3 id="3-4-预警和拦截"><a href="#3-4-预警和拦截" class="headerlink" title="3.4 预警和拦截"></a>3.4 预警和拦截</h3><blockquote>
<p>假设你不想让其他开发者删除 <code>noDelete</code> 属性，还想让调用 <code>oldMethod</code> 的开发者了解到这个方法已经被废弃了，或者告诉开发者不要修改 <code>doNotChange</code> 属性，那么就可以使用 <code>Proxy</code> 来实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">let dataStore = &#123;  </span><br><span class="line">    noDelete: 1235,</span><br><span class="line">    oldMethod: function() &#123;/*...*/ &#125;,</span><br><span class="line">    doNotChange: &quot;tried and true&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const NODELETE = [&#x27;noDelete&#x27;];  </span><br><span class="line">const NOCHANGE = [&#x27;doNotChange&#x27;];</span><br><span class="line">const DEPRECATED = [&#x27;oldMethod&#x27;];  </span><br><span class="line"></span><br><span class="line">dataStore = new Proxy(dataStore, &#123;  </span><br><span class="line">    set(target, key, value, proxy) &#123;</span><br><span class="line">        if (NOCHANGE.includes(key)) &#123;</span><br><span class="line">            throw Error(`Error! $&#123;key&#125; is immutable.`);</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.set(target, key, value, proxy);</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteProperty(target, key) &#123;</span><br><span class="line">        if (NODELETE.includes(key)) &#123;</span><br><span class="line">            throw Error(`Error! $&#123;key&#125; cannot be deleted.`);</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.deleteProperty(target, key);</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    get(target, key, proxy) &#123;</span><br><span class="line">        if (DEPRECATED.includes(key)) &#123;</span><br><span class="line">            console.warn(`Warning! $&#123;key&#125; is deprecated.`);</span><br><span class="line">        &#125;</span><br><span class="line">        var val = target[key];</span><br><span class="line"></span><br><span class="line">        return typeof val === &#x27;function&#x27; ?</span><br><span class="line">            function(...args) &#123;</span><br><span class="line">                Reflect.apply(target[key], target, args);</span><br><span class="line">            &#125; :</span><br><span class="line">            val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// these will throw errors or log warnings, respectively</span><br><span class="line">dataStore.doNotChange = &quot;foo&quot;;  </span><br><span class="line">delete dataStore.noDelete;  </span><br><span class="line">dataStore.oldMethod();</span><br></pre></td></tr></table></figure>

<h3 id="3-5-过滤操作"><a href="#3-5-过滤操作" class="headerlink" title="3.5 过滤操作"></a>3.5 过滤操作</h3><blockquote>
<p>某些操作会非常占用资源，比如传输大文件，这个时候如果文件已经在分块发送了，就不需要在对新的请求作出相应（非绝对），这个时候就可以使用 <code>Proxy</code> 对当请求进行特征检测，并根据特征过滤出哪些是不需要响应的，哪些是需要响应的。下面的代码简单演示了过滤特征的方式，并不是完整代码，相信大家会理解其中的妙处</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;  </span><br><span class="line">    getGiantFile: function(fileId) &#123;/*...*/ &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj = new Proxy(obj, &#123;  </span><br><span class="line">    get(target, key, proxy) &#123;</span><br><span class="line">        return function(...args) &#123;</span><br><span class="line">            const id = args[0];</span><br><span class="line">            let isEnroute = checkEnroute(id);</span><br><span class="line">            let isDownloading = checkStatus(id);      </span><br><span class="line">            let cached = getCached(id);</span><br><span class="line"></span><br><span class="line">            if (isEnroute || isDownloading) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cached) &#123;</span><br><span class="line">                return cached;</span><br><span class="line">            &#125;</span><br><span class="line">            return Reflect.apply(target[key], target, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-6-中断代理"><a href="#3-6-中断代理" class="headerlink" title="3.6 中断代理"></a>3.6 中断代理</h3><blockquote>
<p><code>Proxy</code> 支持随时取消对 <code>target</code> 的代理，这一操作常用于完全封闭对数据或接口的访问。在下面的示例中，我们使用了 <code>Proxy.revocable</code> 方法创建了可撤销代理的代理对象：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let sensitiveData = &#123; username: &#x27;devbryce&#x27; &#125;;</span><br><span class="line">const &#123;sensitiveData, revokeAccess&#125; = Proxy.revocable(sensitiveData, handler);</span><br><span class="line">function handleSuspectedHack()&#123;  </span><br><span class="line">    revokeAccess();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// logs &#x27;devbryce&#x27;</span><br><span class="line">console.log(sensitiveData.username);</span><br><span class="line">handleSuspectedHack();</span><br><span class="line">// TypeError: Revoked</span><br><span class="line">console.log(sensitiveData.username);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/05/html+css+js+ts/4-Proxy/" data-id="cl7ibzola007uuguneujz5xpa" data-title="ES6 Proxy" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-module" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/02/html+css+js+ts/4-module/" class="article-date">
  <time class="dt-published" datetime="2018-04-02T01:14:49.000Z" itemprop="datePublished">2018-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/02/html+css+js+ts/4-module/">ES6 module</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的<strong>集合（即程序代码和数据结构的集合体）</strong>。</p>
<p>两个基本的特征：外部特征和内部特征</p>
<ul>
<li>外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能</li>
<li>内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）</li>
</ul>
<h3 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h3><ul>
<li>代码抽象</li>
<li>代码封装</li>
<li>代码复用</li>
<li>依赖管理</li>
</ul>
<p>如果没有模块化，我们代码会怎样？</p>
<ul>
<li>变量和方法不容易维护，容易污染全局作用域</li>
<li>加载资源的方式通过script标签从上到下。</li>
<li>依赖的环境主观逻辑偏重，代码较多就会比较复杂。</li>
<li>大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃</li>
</ul>
<p>因此，需要一种将<code>JavaScript</code>程序模块化的机制，如</p>
<ul>
<li>CommonJs (典型代表：node.js早期)</li>
<li>AMD (典型代表：require.js)</li>
<li>CMD (典型代表：sea.js)</li>
</ul>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p><code>Asynchronous ModuleDefinition</code>（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p>
<p>代表库为<code>require.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.<span class="title function_">config</span>(&#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&quot;js/lib&quot;</span>,</span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;jquery&quot;</span>,<span class="string">&quot;underscore&quot;</span>],<span class="keyword">function</span>(<span class="params">$,_</span>)&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h3><p><code>CommonJS</code> 是一套 <code>Javascript</code> 模块规范，用于服务端</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123; foo , bar&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; foo,bar &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>其有如下特点：</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域</li>
<li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li>
<li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>
<li><code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li>
</ul>
<p>既然存在了<code>AMD</code>以及<code>CommonJs</code>机制，<code>ES6</code>的<code>Module</code>又有什么不一样？</p>
<p>ES6 在语言标准的层面上，实现了<code>Module</code>，即模块功能，完全可以取代 <code>CommonJS</code>和 <code>AMD</code>规范，成为浏览器和服务器通用的模块解决方案</p>
<p><code>CommonJS</code> 和<code>AMD</code> 模块，都只能在运行时确定这些东西。比如，<code>CommonJS</code>模块就是对象，输入时必须查找对象属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.<span class="property">stat</span>;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.<span class="property">exists</span>;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.<span class="property">readfile</span>;</span><br></pre></td></tr></table></figure>

<p><code>ES6</code>设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上述代码，只加载3个方法，其他方法不加载，即 <code>ES6</code> 可以在编译时就完成模块加载</p>
<p>由于编译加载，使得静态分析成为可能。包括现在流行的<code>typeScript</code>也是依靠静态分析实现功能</p>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p><code>ES6</code>模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是<code>ES5</code>之前就已经规定好</p>
<p>模块功能主要由两个命令构成：</p>
<ul>
<li><code>export</code>：用于规定模块的对外接口</li>
<li><code>import</code>：用于输入其他模块提供的功能</li>
</ul>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line">或 </span><br><span class="line"><span class="comment">// 建议使用下面写法，这样能瞬间确定输出了哪些变量</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure>

<p>输出函数或类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过<code>as</code>可以进行输出变量的重命名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">v1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">v2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  element.<span class="property">textContent</span> = firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样如果想要输入变量起别名，通过<code>as</code>关键字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>当加载整个模块的时候，需要用到星号<code>*</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">area</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">circumference</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">&#x27;./circle&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle)   <span class="comment">// &#123;area:area,circumference:circumference&#125;</span></span><br></pre></td></tr></table></figure>

<p>输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 合法操作</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// Syntax Error : &#x27;a&#x27; is read-only;</span></span><br></pre></td></tr></table></figure>

<p>不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错</p>
<p><code>import</code>后面我们常接着<code>from</code>关键字，<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果只有一个模块名，需要有配置文件，告诉引擎模块的位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在编译阶段，<code>import</code>会提升到整个模块的头部，首先执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>多次重复执行同样的导入，只会执行一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载</p>
<p>如果不需要知道变量名或函数就完成加载，就要用到<code>export default</code>命令，为模块指定默认输出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载该模块的时候，<code>import</code>命令可以为该函数指定任意名字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line"><span class="title function_">customName</span>(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势</p>
<p>这个新功能允许您将<code>import()</code>作为函数调用，将其作为参数传递给模块的路径。 它返回一个 <code>promise</code>，它用一个模块对象来实现，让你可以访问该对象的导出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">import</span>(<span class="string">&#x27;/modules/myModule.mjs&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Do something with the module.</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="复合写法"><a href="#复合写法" class="headerlink" title="复合写法"></a>复合写法</h3><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure>

<p>同理能够搭配<code>as</code>、<code>*</code>搭配使用</p>
<h2 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h2><p>如今，<code>ES6</code>模块化已经深入我们日常项目开发中，像<code>vue</code>、<code>react</code>项目搭建项目，组件化开发处处可见，其也是依赖模块化实现</p>
<p><code>vue</code>组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      组件化开发 ---- 模块化</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">msg</span>: <span class="title class_">String</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><code>react</code>组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		组件化开发 ---- 模块化</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>包括完成一些复杂应用的时候，我们也可以拆分成各个模块</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/02/html+css+js+ts/4-module/" data-id="cl7ibzol9007tugun8cm08mq0" data-title="ES6 module" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-Generator" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/01/html+css+js+ts/4-Generator/" class="article-date">
  <time class="dt-published" datetime="2018-04-01T14:53:15.000Z" itemprop="datePublished">2018-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/01/html+css+js+ts/4-Generator/">ES6 Generator</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、什么是Generator-函数"><a href="#一、什么是Generator-函数" class="headerlink" title="一、什么是Generator 函数"></a>一、什么是Generator 函数</h2><h3 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h3><blockquote>
<p>学习 <code>Generator</code> 语法，你需要了解<code>function*</code> 、<code>yield</code>、<code>next</code>三个基本概念。</p>
</blockquote>
<ul>
<li><code>function*</code> 用来声明一个函数是生成器函数，它比普通的函数声明多了一个<code>*</code>,<code>*</code>的位置比较随意可以挨着 <code>function</code> 关键字，也可以挨着函数名</li>
<li><code>yield</code> 产出的意思，这个关键字只能出现在生成器函数体内，但是生成器中也可以没有<code>yield</code> 关键字，函数遇到 <code>yield</code> 的时候会暂停，并把 <code>yield</code> 后面的表达式结果抛出去</li>
<li><code>next</code>作用是将代码的控制权交还给生成器函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 声明生成器函数</span><br><span class="line">function* generator() &#123;</span><br><span class="line">    // A</span><br><span class="line">    yield &#x27;foo&#x27;</span><br><span class="line">    // B</span><br><span class="line">&#125;</span><br><span class="line">// 获取生成器对象</span><br><span class="line">let g = generator();</span><br><span class="line">// 第一个 next()，首次启动生成器</span><br><span class="line">g.next(); // &#123;value: &quot;foo&quot;, done: false&#125;</span><br><span class="line">// 唤醒被 yield 暂停的状态</span><br><span class="line">g.next();</span><br><span class="line">// &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-过程分析"><a href="#1-2-过程分析" class="headerlink" title="1.2 过程分析"></a>1.2 过程分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 分析一个简单例子</span><br><span class="line">function* helloGenerator() &#123;</span><br><span class="line">   yield &quot;hello&quot;;</span><br><span class="line">   yield &quot;generator&quot;;</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var h = helloGenerator();</span><br><span class="line"></span><br><span class="line">console.log(h.next());//&#123; value: &#x27;hello&#x27;, done: false &#125;</span><br><span class="line">console.log(h.next());//&#123; value: &#x27;generator&#x27;, done: false &#125;</span><br><span class="line">console.log(h.next());//&#123; value: &#x27;undefined&#x27;, done: true &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建了<code>h</code>对象，指向<code>helloGenerator</code>的句柄</li>
<li>第一次调用<code>next()</code>，执行到<code>&quot;yield hello&quot;</code>，暂缓执行,并返回了<code>&quot;hello&quot;</code></li>
<li>第二次调用<code>next()</code>，继续上一次的执行，执行到<code>&quot;yield generator&quot;</code>,暂缓执行，并返回了<code>&quot;generator&quot;</code>。</li>
<li>第三次调用<code>next()</code>,直接执行<code>return</code>，并返回<code>done:true</code>，表明结束</li>
</ul>
<blockquote>
<p>经过上面的分析，<code>yield</code>实际就是暂缓执行的标示，每执行一次<code>next()</code>，相当于指针移动到下一个<code>yield</code>位置</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/54.png" alt="img"></p>
<p><strong>总结一下</strong>，<code>Generator</code>函数是<code>ES6</code>提供的一种异步编程解决方案。通过<code>yield</code>标识位和<code>next()</code>方法调用，实现函数的分段执行</p>
<h3 id="1-3-yield-表达式"><a href="#1-3-yield-表达式" class="headerlink" title="1.3 yield 表达式"></a>1.3 yield 表达式</h3><blockquote>
<p><code>yield</code>是<code>Generator</code>函数的暂缓执行的标识，对于<code>yield</code>只能配合<code>Generator</code>函数使用，在普通的函数中使用会报错</p>
</blockquote>
<p><code>Generator</code>函数中还有一种<code>yield*</code>这个表达方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* foo()&#123;</span><br><span class="line">   	yield &quot;a&quot;;</span><br><span class="line">   	yield &quot;b&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   function* gen(x,y)&#123;</span><br><span class="line">   	  yield 1;</span><br><span class="line">   	  yield 2;</span><br><span class="line">   	  yield* foo();</span><br><span class="line">   	  yield 3;</span><br><span class="line">   &#125;</span><br><span class="line">   var g = gen();</span><br><span class="line">   console.log(g.next());//&#123;value: 1, done: false&#125;</span><br><span class="line">   console.log(g.next());//&#123;value: 2, done: false&#125;</span><br><span class="line">   console.log(g.next());//&#123;value: &quot;a&quot;, done: true&#125;</span><br><span class="line">   console.log(g.next());//&#123;value: &quot;b&quot;, done: true&#125;</span><br><span class="line">   console.log(g.next());//&#123;value: &quot;3&quot;, done: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当执行<code>yield*</code>时，实际是遍历后面的<code>Generator</code>函数，等价于下面的写法：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* foo()&#123;</span><br><span class="line">   	yield &quot;a&quot;;</span><br><span class="line">   	yield &quot;b&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function* gen(x,y)&#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    </span><br><span class="line">    for(var value of foo())&#123;</span><br><span class="line">      yield value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    yield 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>yield</code> 后面只能适配<code>Generator</code>函数</p>
<h2 id="二、Generator应用场景"><a href="#二、Generator应用场景" class="headerlink" title="二、Generator应用场景"></a>二、Generator应用场景</h2><h3 id="2-1-异步操作的同步化表达"><a href="#2-1-异步操作的同步化表达" class="headerlink" title="2.1 异步操作的同步化表达"></a>2.1 异步操作的同步化表达</h3><blockquote>
<p><code>Generator</code>函数的暂停执行的效果，意味着可以把异步操作写在<code>yield</code>表达式里面，等到调用<code>next</code>方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<code>yield</code>表达式下面，反正要等到调用<code>next</code>方法时再执行。所以，<code>Generator</code>函数的一个重要实际意义就是用来处理异步操作，改写回调函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* loadUI() &#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  yield loadUIDataAsynchronously();</span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line">var loader = loadUI();</span><br><span class="line">// 加载UI</span><br><span class="line">loader.next()</span><br><span class="line"></span><br><span class="line">// 卸载UI</span><br><span class="line">loader.next()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰</p>
</blockquote>
<ul>
<li>通过<code>Generator</code>函数部署<code>Ajax</code>操作，可以用同步的方式表达。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* main() &#123;</span><br><span class="line">  var result = yield request(&quot;http://some.url&quot;);</span><br><span class="line">  var resp = JSON.parse(result);</span><br><span class="line">    console.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function request(url) &#123;</span><br><span class="line">  makeAjaxCall(url, function(response)&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure>

<h3 id="2-2-控制流管理"><a href="#2-2-控制流管理" class="headerlink" title="2.2 控制流管理"></a>2.2 控制流管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 异步函数</span><br><span class="line"></span><br><span class="line">function getDataAsync (url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            var res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: Math.random()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>Generator</code> 函数可以这样写</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function * getData () &#123;</span><br><span class="line">    var res1 = yield getDataAsync(&#x27;/page/1?param=123&#x27;)</span><br><span class="line">    console.log(res1)</span><br><span class="line">    var res2 = yield getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)</span><br><span class="line">    console.log(res2)</span><br><span class="line">    var res3 = yield getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)</span><br><span class="line">    console.log(res3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后我们这样逐步执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var g = getData()</span><br><span class="line">g.next().value.then(res1 =&gt; &#123;</span><br><span class="line">    g.next(res1).value.then(res2 =&gt; &#123;</span><br><span class="line">        g.next(res2).value.then(() =&gt; &#123;</span><br><span class="line">            g.next()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码，我们逐步调用遍历器的 <code>next()</code>方法，由于每一个 <code>next()</code> 方法返回值的 <code>value</code> 属性为一个 <code>Promise</code> 对象，所以我们为其添加 <code>then</code>方法， 在 <code>then</code> 方法里面接着运行 <code>next</code> 方法挪移遍历器指针，直到 <code>Generator</code> 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function run (gen) &#123;</span><br><span class="line">    var g = gen()</span><br><span class="line"></span><br><span class="line">    function next (data) &#123;</span><br><span class="line">        var res = g.next(data)</span><br><span class="line">        if (res.done) return res.value</span><br><span class="line">        res.value.then((data) =&gt; &#123;</span><br><span class="line">            next(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>run</code>方法用来自动运行异步的 <code>Generator</code> 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 <code>Generator</code> 函数了。 有了 <code>run</code> 方法，我们只需要这样运行 <code>getData</code> 方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(getData)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样，我们就可以把异步操作封装到 <code>Generator</code> 函数内部，使用 <code>run</code>方法作为 <code>Generator</code> 函数的自执行器，来处理异步。其实我们不难发现， <code>async/await</code> 方法相比于 <code>Generator</code> 处理异步的方式，有很多相似的地方，只不过 async&#x2F;await 在语义化方面更加明显，同时 <code>async/await</code> 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 <code>async/await</code>是 <code>Generator</code>函数处理异步的语法糖了</p>
</blockquote>
<h3 id="2-3-部署-Iterator-接口"><a href="#2-3-部署-Iterator-接口" class="headerlink" title="2.3 部署 Iterator 接口"></a>2.3 部署 Iterator 接口</h3><blockquote>
<p>利用 <code>Generator</code> 函数，可以在任意对象上部署 <code>Iterator</code> 接口。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function* iterEntries(obj) &#123;</span><br><span class="line">  let keys = Object.keys(obj);</span><br><span class="line">  for (let i=0; i &lt; keys.length; i++) &#123;</span><br><span class="line">    let key = keys[i];</span><br><span class="line">    yield [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObj = &#123; foo: 3, bar: 7 &#125;;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of iterEntries(myObj)) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// foo 3</span><br><span class="line">// bar 7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中，<code>myObj</code>是一个普通对象，通过<code>iterEntries</code>函数，就有了 <code>Iterator</code> 接口。也就是说，可以在任意对象上部署<code>next</code>方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口</span><br><span class="line"></span><br><span class="line">function* makeSimpleGenerator(array)&#123;</span><br><span class="line">  var nextIndex = 0;</span><br><span class="line"></span><br><span class="line">  while(nextIndex &lt; array.length)&#123;</span><br><span class="line">    yield array[nextIndex++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen = makeSimpleGenerator([&#x27;yo&#x27;, &#x27;ya&#x27;]);</span><br><span class="line"></span><br><span class="line">gen.next().value // &#x27;yo&#x27;</span><br><span class="line">gen.next().value // &#x27;ya&#x27;</span><br><span class="line">gen.next().done  // true</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/01/html+css+js+ts/4-Generator/" data-id="cl7ibzokz007kugun909f0392" data-title="ES6 Generator" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/4-asyncawait" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/20/html+css+js+ts/4-asyncawait/" class="article-date">
  <time class="dt-published" datetime="2018-03-20T01:21:42.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/20/html+css+js+ts/4-asyncawait/">ES async/await</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a>一、含义</h2><blockquote>
<p><code>async</code> 函数是什么？一句话，它就是 <code>Generator</code> 函数的语法糖</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 有一个 Generator 函数，依次读取两个文件</span><br><span class="line"></span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">const readFile = function (fileName) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    fs.readFile(fileName, function(error, data) &#123;</span><br><span class="line">      if (error) return reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const gen = function* () &#123;</span><br><span class="line">  const f1 = yield readFile(&#x27;/etc/fstab&#x27;);</span><br><span class="line">  const f2 = yield readFile(&#x27;/etc/shells&#x27;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const asyncReadFile = async function () &#123;</span><br><span class="line">  const f1 = await readFile(&#x27;/etc/fstab&#x27;);</span><br><span class="line">  const f2 = await readFile(&#x27;/etc/shells&#x27;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>async</code>函数就是将 <code>Generator</code> 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已</p>
</blockquote>
<p><strong>async函数对 Generator 函数的改进，体现在以下四点</strong></p>
<ol>
<li>内置执行器</li>
</ol>
<blockquote>
<p><code>Generator</code>函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 <code>Generator</code>函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果</p>
</blockquote>
<ol>
<li>更好的语义</li>
</ol>
<blockquote>
<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果</p>
</blockquote>
<ol>
<li>更广的适用性</li>
</ol>
<blockquote>
<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 <code>Promise</code> 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</p>
</blockquote>
<ol>
<li>返回值是 <code>Promise</code></li>
</ol>
<blockquote>
<p><code>async</code>函数的返回值是 <code>Promise</code> 对象，这比 <code>Generator</code> 函数的返回值是 <code>Iterator</code> 对象方便多了。你可以用<code>then</code>方法指定下一步的操作</p>
</blockquote>
<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 <code>Promise</code> 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖</p>
<h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><blockquote>
<p><code>async</code>函数返回一个 <code>Promise</code> 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/53.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 调用该函数时，会立即返回一个Promise对象</span><br><span class="line">async function getStockPriceByName(name) &#123;</span><br><span class="line">  const symbol = await getStockSymbol(name);</span><br><span class="line">  const stockPrice = await getStockPrice(symbol);</span><br><span class="line">  return stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(&#x27;goog&#x27;).then(function (result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>async 函数有多种使用形式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">async function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">const foo = async function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 对象的方法</span><br><span class="line">let obj = &#123; async foo() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line">// Class 的方法</span><br><span class="line">class Storage &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.cachePromise = caches.open(&#x27;avatars&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getAvatar(name) &#123;</span><br><span class="line">    const cache = await this.cachePromise;</span><br><span class="line">    return cache.match(`/avatars/$&#123;name&#125;.jpg`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const storage = new Storage();</span><br><span class="line">storage.getAvatar(&#x27;jake&#x27;).then(…);</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const foo = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><blockquote>
<p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制</p>
</blockquote>
<h3 id="3-1-返回-Promise-对象"><a href="#3-1-返回-Promise-对象" class="headerlink" title="3.1 返回 Promise 对象"></a>3.1 返回 Promise 对象</h3><ul>
<li><code>async</code>函数返回一个 <code>Promise</code> 对象</li>
<li><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 函数f内部return命令返回的值，会被then方法回调函数接收到</span><br><span class="line">async function f() &#123;</span><br><span class="line">  return &#x27;hello world&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(v =&gt; console.log(v))</span><br><span class="line">// &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>async</code>函数内部抛出错误，会导致返回的 <code>Promise</code> 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  throw new Error(&#x27;出错了&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">  v =&gt; console.log(v),</span><br><span class="line">  e =&gt; console.log(e)</span><br><span class="line">)</span><br><span class="line">// Error: 出错了</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Promise-对象的状态变化"><a href="#3-2-Promise-对象的状态变化" class="headerlink" title="3.2 Promise 对象的状态变化"></a>3.2 Promise 对象的状态变化</h3><blockquote>
<p><code>async</code>函数返回的 <code>Promise</code> 对象，必须等到内部所有<code>await</code>命令后面的 <code>Promise</code> 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function getTitle(url) &#123;</span><br><span class="line">  let response = await fetch(url);</span><br><span class="line">  let html = await response.text();</span><br><span class="line">  return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(&#x27;https://tc39.github.io/ecma262/&#x27;).then(console.log)</span><br><span class="line">// &quot;ECMAScript 2017 Language Specification&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-await-命令"><a href="#3-3-await-命令" class="headerlink" title="3.3 await 命令"></a>3.3 await 命令</h3><blockquote>
<p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code> 对象，返回该对象的结果。如果不是 <code>Promise</code> 对象，就直接返回对应的值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  // 等同于</span><br><span class="line">  // return 123;</span><br><span class="line">  return await 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(v =&gt; console.log(v))</span><br><span class="line">// 123</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 <code>Promise</code> 对象</p>
</blockquote>
<ul>
<li><code>await</code>命令后面的 <code>Promise</code> 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  await Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</li>
<li>任何一个<code>await</code>语句后面的 <code>Promise</code> 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  await Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">  await Promise.resolve(&#x27;hello world&#x27;); // 不会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  return await Promise.resolve(&#x27;hello world&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另一种方法是<code>await</code>后面的 <code>Promise</code> 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  await Promise.reject(&#x27;出错了&#x27;)</span><br><span class="line">    .catch(e =&gt; console.log(e));</span><br><span class="line">  return await Promise.resolve(&#x27;hello world&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">// 出错了</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure>

<h3 id="3-4-错误处理"><a href="#3-4-错误处理" class="headerlink" title="3.4 错误处理"></a>3.4 错误处理</h3><blockquote>
<p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 <code>Promise</code> 对象被<code>reject</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  await new Promise(function (resolve, reject) &#123;</span><br><span class="line">    throw new Error(&#x27;出错了&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// Error：出错了</span><br></pre></td></tr></table></figure>

<blockquote>
<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await new Promise(function (resolve, reject) &#123;</span><br><span class="line">      throw new Error(&#x27;出错了&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  return await(&#x27;hello world&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function main() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const val1 = await firstStep();</span><br><span class="line">    const val2 = await secondStep(val1);</span><br><span class="line">    const val3 = await thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;Final: &#x27;, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (err) &#123;</span><br><span class="line">    console.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-使用注意点"><a href="#3-5-使用注意点" class="headerlink" title="3.5 使用注意点"></a>3.5 使用注意点</h3><blockquote>
<p>第一点：<code>await</code>命令后面的Promise对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async function myFunction() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一种写法</span><br><span class="line"></span><br><span class="line">async function myFunction() &#123;</span><br><span class="line">  await somethingThatReturnsAPromise()</span><br><span class="line">  .catch(function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发</span><br><span class="line"></span><br><span class="line">let foo = await getFoo();</span><br><span class="line">let bar = await getBar();</span><br><span class="line">// 两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。</span><br><span class="line"></span><br><span class="line">// 写法一</span><br><span class="line">let [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">let fooPromise = getFoo();</span><br><span class="line">let barPromise = getBar();</span><br><span class="line">let foo = await fooPromise;</span><br><span class="line">let bar = await barPromise;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function dbFuc(db) &#123;</span><br><span class="line">  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 报错</span><br><span class="line">  docs.forEach(function (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、async-函数的实现原理"><a href="#四、async-函数的实现原理" class="headerlink" title="四、async 函数的实现原理"></a>四、async 函数的实现原理</h2><blockquote>
<p><code>async</code> 函数的实现原理，就是将 <code>Generator</code> 函数和自动执行器，包装在一个函数里</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function fn(args) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">function fn(args) &#123;</span><br><span class="line">  return spawn(function* () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// spawn函数的实现，基本就是前文自动执行器的翻版</span><br><span class="line"></span><br><span class="line">function spawn(genF) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    const gen = genF();</span><br><span class="line">    function step(nextF) &#123;</span><br><span class="line">      let next;</span><br><span class="line">      try &#123;</span><br><span class="line">        next = nextF();</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        return reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      if(next.done) &#123;</span><br><span class="line">        return resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      Promise.resolve(next.value).then(function(v) &#123;</span><br><span class="line">        step(function() &#123; return gen.next(v); &#125;);</span><br><span class="line">      &#125;, function(e) &#123;</span><br><span class="line">        step(function() &#123; return gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(function() &#123; return gen.next(undefined); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/20/html+css+js+ts/4-asyncawait/" data-id="cl7ibzokv0076ugun06t3faj2" data-title="ES async/await" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/3-原型链" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/18/html+css+js+ts/3-%E5%8E%9F%E5%9E%8B%E9%93%BE/" class="article-date">
  <time class="dt-published" datetime="2018-03-18T12:16:43.000Z" itemprop="datePublished">2018-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/18/html+css+js+ts/3-%E5%8E%9F%E5%9E%8B%E9%93%BE/">js-原型链</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、JS内置对象"><a href="#一、JS内置对象" class="headerlink" title="一、JS内置对象"></a>一、JS内置对象</h2><blockquote>
<p>所谓的内置对象 指的是：<code>JavaScript</code>本身就自己有的对象 可以直接拿来就用。例如<code>Array</code> <code>String</code> 等等。<code>JavaScript</code>一共有12内置对象</p>
</blockquote>
<p><strong>函数类型(10个)</strong></p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Array</code></li>
<li><code>Function</code></li>
<li><code>Date</code></li>
<li><code>RegExp</code></li>
<li><code>Error</code></li>
<li><code>Object</code></li>
<li><code>Event</code></li>
</ul>
<blockquote>
<p>函数类型 有 <code>__proto__</code>和 <code>prototype</code> 属性</p>
</blockquote>
<p><strong>对象类型(2个)</strong></p>
<ul>
<li><code>Math</code></li>
<li><code>JSON</code></li>
</ul>
<blockquote>
<p>对象类型只有<code>__proto__</code>属性</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1480597-9b6c5ca4a84f967c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="二、JS原型链"><a href="#二、JS原型链" class="headerlink" title="二、JS原型链"></a>二、JS原型链</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p><img src="https://upload-images.jianshu.io/upload_images/1480597-86427eafb257f868.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。</li>
<li>每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>__proto__</code> 来访问</li>
<li>对象可以通过 <strong>proto</strong> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链</li>
</ul>
<blockquote>
<p>打开浏览器的控制面板，随便输入一个<code>JS</code>内置的构造器函数，比如<code>Array</code>，控制台输出的是一个名为<code>Array</code>的函数体，这好像并没有什么稀奇的，但是，当你接着输入<code>Array.prototype</code>，控制面板输出了一堆我们经常用到的<code>Array</code>构造器的方法，把目光转移到最下方，有一个叫<code>__proto__</code>的属性，好奇的点开。列表列出的不是<code>Object</code>构造器的方法么，里边有我们非常熟悉的<code>hasOwnProperty</code>还有<code>toString</code>等方法。如果<code>Array</code>是构造器，那么控制面板输出的<code>Array.prototype</code>的所有属性中<code>constructor</code>又是什么构造器？点开看看，之后就像身处德罗斯特效应中一样，<code>__proto__</code>和<code>constructor</code>，还有<code>Array</code>构造器中常用的方法名不断的出现，一层套一层，一层层展开，没有尽头</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/343.png" alt="img"></p>
<blockquote>
<p>拿<code>Array</code>举例，<code>Array.prototype</code>中有一个<code>constructor</code>属性，这个属性的值就是<code>Array</code>构造器自己</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.constructor === Array //true</span><br></pre></td></tr></table></figure>

<h3 id="2-2-prototype"><a href="#2-2-prototype" class="headerlink" title="2.2 prototype"></a>2.2 prototype</h3><blockquote>
<p>这是一个显式原型属性，只有函数才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fun = Function.prototype.bind()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你以上述方法创建一个函数，那么可以发现这个函数是不具有 <code>prototype</code> 属性的</p>
</blockquote>
<h4 id="2-2-1-prototype-如何产生的"><a href="#2-2-1-prototype-如何产生的" class="headerlink" title="2.2.1 prototype 如何产生的"></a>2.2.1 prototype 如何产生的</h4><blockquote>
<p>当我们声明一个函数时，这个属性就被自动创建了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>并且这个属性的值是一个对象（也就是原型），只有一个属性 <code>constructor</code></p>
</blockquote>
<ul>
<li><code>constructor</code> 对应着构造函数，也就是 <code>Foo</code></li>
</ul>
<h4 id="2-2-2-constructor"><a href="#2-2-2-constructor" class="headerlink" title="2.2.2 constructor"></a>2.2.2 constructor</h4><blockquote>
<p><code>constructor</code>是一个公有且不可枚举的属性。一旦我们改变了函数的 <code>prototype</code> ，那么新对象就没有这个属性了（当然可以通过原型链取到 <code>constructor</code>）</p>
</blockquote>
<p>那么你肯定也有一个疑问，这个属性到底有什么用呢？其实这个属性可以说是一个历史遗留问题，在大部分情况下是没用的，在我的理解里，我认为他有两个作用：</p>
<ul>
<li>让实例对象知道是什么函数构造了它</li>
<li>如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 <code>xx.constructor.method</code> 来扩展</li>
</ul>
<h3 id="2-3-proto"><a href="#2-3-proto" class="headerlink" title="2.3 __proto__"></a>2.3 <code>__proto__</code></h3><blockquote>
<p>这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>__proto__</code> 来访问</p>
</blockquote>
<ul>
<li>因为在 <code>JS</code> 中是没有类的概念的，为了实现类似继承的方式，通过 <code>__proto__</code> 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性</li>
</ul>
<h4 id="2-3-1-实例对象的-proto-如何产生的"><a href="#2-3-1-实例对象的-proto-如何产生的" class="headerlink" title="2.3.1 实例对象的 _proto_ 如何产生的"></a>2.3.1 实例对象的 <code>_proto_</code> 如何产生的</h4><blockquote>
<p>当我们使用 <code>new</code> 操作符时，生成的实例对象拥有了 <code>__proto__</code>属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line">// 这个函数是 Function 的实例对象</span><br><span class="line">// function 就是一个语法糖</span><br><span class="line">// 内部调用了 new Function(...)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以可以说，在 <code>new</code> 的过程中，新对象被添加了 <code>__proto__</code> 并且链接到构造函数的原型上</p>
</blockquote>
<h4 id="2-3-2-new-的过程"><a href="#2-3-2-new-的过程" class="headerlink" title="2.3.2 new 的过程"></a>2.3.2 new 的过程</h4><ul>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 <code>this</code></li>
<li>返回新对象</li>
</ul>
<blockquote>
<p>在调用 <code>new</code> 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 <code>new</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function create() &#123;</span><br><span class="line">    // 创建一个空的对象</span><br><span class="line">    let obj = new Object()</span><br><span class="line">    // 获得构造函数</span><br><span class="line">    let Con = [].shift.call(arguments)</span><br><span class="line">    // 链接到原型</span><br><span class="line">	obj.__proto__ = Con.prototype</span><br><span class="line">    // 绑定 this，执行构造函数</span><br><span class="line">    let result = Con.apply(obj, arguments)</span><br><span class="line">    // 确保 new 出来的是个对象</span><br><span class="line">    return typeof result === &#x27;object&#x27; ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于实例对象来说，都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = &#123; b : 1 &#125;</code></li>
<li>对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 <code>new Object()</code>的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// function 就是个语法糖</span><br><span class="line">// 内部等同于 new Function()</span><br><span class="line">let a = &#123; b: 1 &#125;</span><br><span class="line">// 这个字面量内部也是使用了 new Object()</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1480597-e4a91031a78eb153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>这里<code>Array</code> 内置对象 且是函数类型。所以<code>Array</code>有<code>__proto__</code>属性 指向的是函数类型 <code>(function（）&#123;&#125;)</code>。所以当我们在输出<code>Array.__proto__.proto__</code>;就会返回对象类型<code>(Object&#123;&#125;)</code>.但是再向上就<code>null</code>。因为<code>Object</code>就是父类了。所有的继承自<code>Object</code>。</p>
</blockquote>
<ul>
<li><code>JS</code>内置构造器其中之一的<code>Array</code>原本就是一个函数，而这个函数就是<code>Function</code>的<code>prototype</code>，所以<code>Function.prototype</code>有的方法，<code>JS</code>内置构造器都有，比如<code>call()</code>、<code>apply()</code>、<code>bind()</code>等（其实我们自定义的函数也是继承自<code>Function.prototype</code>，所以我们自己也可以定义构造器）。而<code>Function.prototype</code>的进化链指针又指向了<code>Object.prototype</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 数组实例的__proto__指向构造器的原型</span><br><span class="line"></span><br><span class="line">[].__proto__ === Array.prototype</span><br></pre></td></tr></table></figure>

<h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><ul>
<li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function.prototype</code> 和 <code>Object.prototype</code> 是两个特殊的对象，他们由引擎来创建</li>
<li>除了以上两个特殊对象，其他对象都是通过构造器 <code>new</code> 出来的</li>
<li>函数的 <code>prototype</code> 是一个对象，也就是原型</li>
<li>对象的 <code>__proto__</code> 指向原型， <code>__proto__</code>将对象和原型连接起来组成了原型链</li>
</ul>
<p><strong>关于原型有3个相关的概</strong>念:</p>
<ul>
<li>函数对象的<code>prototype</code>属性, 可以称之为显式原型属性(简称: 显式原型)</li>
<li>实例对象的<code>__proto__</code>属性, 可以称之为隐式原型属性(简称: 隐式原型)</li>
<li>原型对象: 也就是<code>prototype</code>属性和<code>_proto__</code>属性指向的对象</li>
</ul>
<p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt="img"></p>
<blockquote>
<p>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线</p>
</blockquote>
<h2 id="三、JSON和Math"><a href="#三、JSON和Math" class="headerlink" title="三、JSON和Math"></a>三、JSON和Math</h2><blockquote>
<p><code>JS</code>内置的构造器函数都可以使用<code>new</code>关键字实例化一个对象，我们称实例化后的这个对象就是某某构造器的一个实例</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/344.png" alt="img"></p>
<blockquote>
<p>我们试试<code>JSON</code> 和<code>Math</code> 能不能实例化对象</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/345.png" alt="img"></p>
<blockquote>
<p><code>JSON</code>和<code>Math</code>不是构造器函数，他们是普通的对象。只有构造器函数才能使用<code>new</code>关键字实例化一个对象，而<code>JSON</code>和<code>Math</code>已经是对象了，所以我们可以不用实例化直接使用<code>JSON</code>和<code>Math</code>中的属性和方法</p>
</blockquote>
<ul>
<li>所以<code>JSON</code>和<code>Math</code>不属于<code>10</code>个构造器函数，但他们<code>12</code>个共同属于<code>Javascript</code>的内置对象</li>
</ul>
<h2 id="四、更多参考"><a href="#四、更多参考" class="headerlink" title="四、更多参考"></a>四、更多参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/2">JavaScript深入之从原型到原型链</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/18/html+css+js+ts/3-%E5%8E%9F%E5%9E%8B%E9%93%BE/" data-id="cl7ibzokg006zugung4568chv" data-title="js-原型链" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/3-异步-axios" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/16/html+css+js+ts/3-%E5%BC%82%E6%AD%A5-axios/" class="article-date">
  <time class="dt-published" datetime="2018-03-16T12:46:35.000Z" itemprop="datePublished">2018-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/16/html+css+js+ts/3-%E5%BC%82%E6%AD%A5-axios/">异步-axios</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、axios-简介"><a href="#一、axios-简介" class="headerlink" title="一、axios 简介"></a>一、axios 简介</h2><blockquote>
<p><code>axios</code> 是一个基于<code>Promise</code>用于浏览器和 <code>nodejs</code> 的 <code>HTTP</code> 客户端，它本身具有以下特征：</p>
</blockquote>
<ul>
<li>从浏览器中创建 <code>XMLHttpRequest</code></li>
<li>从 <code>node.js</code> 发出 <code>http</code> 请求</li>
<li>支持<code>Promise API</code></li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换<code>JSON</code>数据</li>
<li>客户端支持防止<code>CSRF/XSRF</code></li>
</ul>
<h2 id="二、axios基础"><a href="#二、axios基础" class="headerlink" title="二、axios基础"></a>二、axios基础</h2><ul>
<li><code>axios.request（config）</code></li>
<li><code>axios.get（url [，config]）</code></li>
<li><code>axios.delete（url [，config]）</code></li>
<li><code>axios.head（url [，config]）</code></li>
<li><code>axios.options（url [，config]）</code></li>
<li><code>axios.post（url [，data [，config]]</code>）</li>
<li><code>axios.put（url [，data [，config]]）</code></li>
<li><code>axios.patch（url [，data [，config]]）</code></li>
</ul>
<h2 id="三、执行-GET-请求"><a href="#三、执行-GET-请求" class="headerlink" title="三、执行 GET 请求"></a>三、执行 GET 请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 向具有指定ID的用户发出请求</span><br><span class="line">axios.get(&#x27;/user?ID=12345&#x27;)</span><br><span class="line">.then(function (res) &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">// 也可以通过 params 对象传递参数</span><br><span class="line">axios.get(&#x27;/user&#x27;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">        ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="四、执行-POST-请求"><a href="#四、执行-POST-请求" class="headerlink" title="四、执行 POST 请求"></a>四、执行 POST 请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&#x27;/user&#x27;, &#123;</span><br><span class="line">    userId:&quot;123&quot;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    headers:&#123;</span><br><span class="line">        token:&quot;abc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (res) &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="五、通过配置方式发送请求"><a href="#五、通过配置方式发送请求" class="headerlink" title="五、通过配置方式发送请求"></a>五、通过配置方式发送请求</h2><blockquote>
<p><code>get</code>请求是发送参数，在<code>params</code>中定义。而<code>POST</code>请求是发送<code>request body</code>,需要在<code>data</code>中定义</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// get 在params中定义</span><br><span class="line">axios(&#123;</span><br><span class="line">    url:&quot;pakage.json&quot;,</span><br><span class="line">    method:&quot;get&quot;,</span><br><span class="line">    params:&#123;</span><br><span class="line">        userId:&quot;123&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    headers:&#123;</span><br><span class="line">        token:&quot;http-test&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    console.log(res.data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// post 在data中定义</span><br><span class="line">axios(&#123;</span><br><span class="line">    url:&quot;pakage.json&quot;,</span><br><span class="line">    method:&quot;post&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        userId:&quot;123&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    headers:&#123;</span><br><span class="line">        token:&quot;http-test&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    console.log(res.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="六、执行多个并发请求"><a href="#六、执行多个并发请求" class="headerlink" title="六、执行多个并发请求"></a>六、执行多个并发请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getUserAcount()&#123;</span><br><span class="line">    // 返回一个promise对象</span><br><span class="line">    return axios.get(&quot;/user/1234&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function getUserPermissions()&#123;</span><br><span class="line">    // 返回一个promise对象</span><br><span class="line">    return axios.get(&quot;/user/1234/getUserPermissions&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//一次性返回两个接口</span><br><span class="line">axios.all([getUserAccount(),getUserPerssions()]).then(axios.spread((acct, perms) =&gt; &#123;</span><br><span class="line">    // spread展开两个返回的结果</span><br><span class="line">    //两个请求现已完成</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h2 id="七、在react的应用"><a href="#七、在react的应用" class="headerlink" title="七、在react的应用"></a>七、在react的应用</h2><blockquote>
<p>组件首次“挂载”（<code>mount</code>）时，该方法就会执行。在组件生命周期中，该方法只会执行一次</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    axios.get(`http://www.reddit.com/r/$&#123;this.props.subreddit&#125;.json`)</span><br><span class="line">      .then(res =&gt; &#123;</span><br><span class="line">        const posts = res.data.data.children.map(obj =&gt; obj.data);</span><br><span class="line">        this.setState(&#123; posts &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/axios/axios">https://github.com/axios/axios</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/16/html+css+js+ts/3-%E5%BC%82%E6%AD%A5-axios/" data-id="cl7ibzokw0077ugun0ou2hslb" data-title="异步-axios" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/3-js-原生JS与jQuery操作DOM对比" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/08/html+css+js+ts/3-js-%E5%8E%9F%E7%94%9FJS%E4%B8%8EjQuery%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E6%AF%94/" class="article-date">
  <time class="dt-published" datetime="2018-03-07T22:46:34.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/08/html+css+js+ts/3-js-%E5%8E%9F%E7%94%9FJS%E4%B8%8EjQuery%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E6%AF%94/">js 原生js与jquery操作dom的对比</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、创建元素节点"><a href="#一、创建元素节点" class="headerlink" title="一、创建元素节点"></a>一、创建元素节点</h3><hr>
<h4 id="1-1-原生JS创建元素节点"><a href="#1-1-原生JS创建元素节点" class="headerlink" title="1.1 原生JS创建元素节点"></a>1.1 原生<code>JS</code>创建元素节点</h4><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.createElement(&quot;p&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="1-2-jQuery创建元素节点"><a href="#1-2-jQuery创建元素节点" class="headerlink" title="1.2 jQuery创建元素节点"></a>1.2 <code>jQuery</code>创建元素节点</h4><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;&lt;p&gt;&lt;/p&gt;&#x27;);`</span><br></pre></td></tr></table></figure>

<h3 id="二、创建并添加文本节点"><a href="#二、创建并添加文本节点" class="headerlink" title="二、创建并添加文本节点"></a>二、创建并添加文本节点</h3><hr>
<h4 id="2-1-原生JS创建文本节点"><a href="#2-1-原生JS创建文本节点" class="headerlink" title="2.1 原生JS创建文本节点"></a>2.1 原生JS创建文本节点</h4><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`document.createTextNode(&quot;Text Content&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>通常创建文本节点和创建元素节点配合使用，比如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var textEl = document.createTextNode(&quot;Hello World.&quot;);</span><br><span class="line">var pEl = document.createElement(&quot;p&quot;);</span><br><span class="line">pEl.appendChild(textEl);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-jQuery创建并添加文本节点："><a href="#2-2-jQuery创建并添加文本节点：" class="headerlink" title="2.2 jQuery创建并添加文本节点："></a>2.2 <code>jQuery</code>创建并添加文本节点：</h4><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var $p = $(&#x27;&lt;p&gt;Hello World.&lt;/p&gt;&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="三、复制节点"><a href="#三、复制节点" class="headerlink" title="三、复制节点"></a>三、复制节点</h3><hr>
<h4 id="3-1-原生JS复制节点"><a href="#3-1-原生JS复制节点" class="headerlink" title="3.1 原生JS复制节点:"></a>3.1 原生<code>JS</code>复制节点:</h4><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newEl = pEl.cloneNode(true);  `</span><br></pre></td></tr></table></figure>

<ul>
<li>&#96;&#96;&#96;<br>true和false的区别：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `true` ：克隆整个`&#x27;Hello World.&#x27;`节点</span><br><span class="line">  - `false`：只克隆`&#x27;&#x27;` ，不克隆文本`Hello World.&#x27;`</span><br><span class="line"></span><br><span class="line">#### 3.2 `jQuery`复制节点</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$newEl &#x3D; $(‘#pEl’).clone(true);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注意：克隆节点要避免`ID重复</span><br><span class="line"></span><br><span class="line">### 四、 插入节点</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">#### 4.1 原生JS向子节点列表的末尾添加新的子节点</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
El.appendChild(newNode);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 原生JS在节点的已有子节点之前插入一个新的子节点：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
El.insertBefore(newNode, targetNode);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 4.2 在jQuery中，插入节点的方法比原生JS多的多</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 在匹配元素子节点列表结尾添加内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(‘#El’).append(‘<p>Hello World.</p>‘);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 把匹配元素添加到目标元素子节点列表结尾</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(‘<p>Hello World.</p>‘).appendTo(‘#El’);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在匹配元素子节点列表开头添加内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(‘#El’).prepend(‘<p>Hello World.</p>‘);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 把匹配元素添加到目标元素子节点列表开头</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(‘<p>Hello World.</p>‘).prependTo(‘#El’);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在匹配元素之前添加目标内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(‘#El’).before(‘<p>Hello World.</p>‘);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 把匹配元素添加到目标元素之前</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(‘<p>Hello World.</p>‘).insertBefore(‘#El’);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在匹配元素之后添加目标内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(‘#El’).after(‘<p>Hello World.</p>‘);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 把匹配元素添加到目标元素之后</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(‘<p>Hello World.</p>‘).insertAfter(‘#El’);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 五、删除节点</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">#### 5.1 原生JS删除节点</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
El.parentNode.removeChild(El);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 5.2 jQuery删除节点</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(‘#El’).remove();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 六、替换节点</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">#### 6.1 原生JS替换节点</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
El.repalceChild(newNode, oldNode);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注意：`oldNode`必须是`parentEl`真实存在的一个子节点</span><br><span class="line"></span><br><span class="line">#### 6.2 jQuery替换节点</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(‘p’).replaceWith(‘<p>Hello World.</p>‘);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 七、设置属性/获取属性</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">#### 7.1 原生JS设置属性/获取属性</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
imgEl.setAttribute(“title”, “logo”);<br>imgEl.getAttribute(“title”);<br>checkboxEl.checked &#x3D; true;<br>checkboxEl.checked;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 7.2 jQuery设置属性/获取属性:</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(“#logo”).attr({“title”: “logo”});<br>$(“#logo”).attr(“title”);<br>$(“#checkbox”).prop({“checked”: true});<br>$(“#checkbox”).prop(“checked”);</li>
</ul>
<p>&#96;&#96;&#96;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/08/html+css+js+ts/3-js-%E5%8E%9F%E7%94%9FJS%E4%B8%8EjQuery%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E6%AF%94/" data-id="cl7ibzogy003pugun3hwq5x60" data-title="js 原生js与jquery操作dom的对比" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/18/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><a class="page-number" href="/page/21/">21</a><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/20/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/liunx/">liunx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">问题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%9F%E7%90%86/">原理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%9F%E7%90%86/React/">React</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/">框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/">算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">架构模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%A1%86%E6%9E%B6/">框架</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/React/">React</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event-Loop/" rel="tag">Event Loop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mock/" rel="tag">Mock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/async-await/" rel="tag">async&#x2F;await</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echart/" rel="tag">echart</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/" rel="tag">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/" rel="tag">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glup/" rel="tag">glup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/" rel="tag">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vs-code/" rel="tag">vs code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue3/" rel="tag">vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/" rel="tag">xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" rel="tag">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Event-Loop/" style="font-size: 10px;">Event Loop</a> <a href="/tags/Mock/" style="font-size: 10px;">Mock</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/React/" style="font-size: 20px;">React</a> <a href="/tags/Redux/" style="font-size: 11.67px;">Redux</a> <a href="/tags/async-await/" style="font-size: 10px;">async/await</a> <a href="/tags/css/" style="font-size: 11.67px;">css</a> <a href="/tags/echart/" style="font-size: 10px;">echart</a> <a href="/tags/es6/" style="font-size: 15.83px;">es6</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/git/" style="font-size: 16.67px;">git</a> <a href="/tags/glup/" style="font-size: 10.83px;">glup</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/http/" style="font-size: 17.5px;">http</a> <a href="/tags/javascript/" style="font-size: 18.33px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10.83px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 13.33px;">nodejs</a> <a href="/tags/python/" style="font-size: 10.83px;">python</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/typescript/" style="font-size: 12.5px;">typescript</a> <a href="/tags/vs-code/" style="font-size: 11.67px;">vs code</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/vue3/" style="font-size: 10px;">vue3</a> <a href="/tags/webpack/" style="font-size: 19.17px;">webpack</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 14.17px;">优化</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10.83px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15.83px;">小程序</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 13.33px;">浏览器</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" style="font-size: 10.83px;">移动端</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10.83px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/25/Js%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">变量类型</a>
          </li>
        
          <li>
            <a href="/2022/08/25/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/01/12/%E5%B7%A5%E5%85%B7/git-stach/">git-stach</a>
          </li>
        
          <li>
            <a href="/2021/10/16/Vue/vue3%E4%BC%98%E5%8C%96/">vue3优化</a>
          </li>
        
          <li>
            <a href="/2021/10/11/Vue/Vue3-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E3%80%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/">Vue3-设计目标、做了哪些优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>