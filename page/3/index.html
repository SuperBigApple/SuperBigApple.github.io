<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="John Doe">
    
    
    
    
    
    
    <title>Hexo</title>
    <!-- inject:style -->
    <link href="/css/style.css" rel="stylesheet" type="text/css">
    <!-- endinject -->
    <style>
        .cube-loading {
            top: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('/images/lg/loading.gif') no-repeat center center;
            background-color: rgba(0,0,0,.7);
        }

        .cube-loading.out {
            display: none;
        }

        .cube-loading:before {
            display: block;
            content: 'Loading';
            position: relative;
            width: 100%;
            top: 50%;
            right: -50%;
            color: #fff;
        }

        @media(max-width: 768px) {
            .cube-loading:before {
                font-size: 1.2em;
                transform: translate(-24px,20px);
                -webkit-transform: translate(-24px,20px);
                -o-transform: translate(-24px,20px);
                -ms-transform: translate(-24px,20px);
            }
        }

        @media(min-width: 768px) {
            .cube-loading:before {

            }
        }
    </style>
    
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
<div class="cube-body">
    <nav id="cube-top-memu" class="cube-menu">
    <ul class="cube-menu-collapse">
        
        <li>
            <i class="cube-icon cube-icon-home" aria-hidden="true"></i>
            <a href="/">首页</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-archive" aria-hidden="true"></i>
            <a href="/archives">归档</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-categories" aria-hidden="true"></i>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-tags" aria-hidden="true"></i>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-about" aria-hidden="true"></i>
            <a href="/about-me">关于我</a>
        </li>
        
    </ul>
</nav>
<nav class="cube-side-menu" id="cube-side-menu">
    <ul class="cube-menu-list">
        
        <li>
            <a class="lrc-control">Open Lyrics</a>
        </li>
        
        <li>
            <a class="scroll-to-top">Top</a>
        </li>
    </ul>
</nav>
    <header class="cube-header" id="cube-header">
    <img src=" https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201502%2F28%2F20150228220759_zaP3N.png&amp;refer=http%3A%2F%2Fb-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664943562&amp;t=f546331d7d5aee27ceb7af09c60899f2 " alt="头部背景图片">
    
    <div class="cube-type">
        <span class="cube-typed-title">🍍的个人博客 ^_^</span>
        <span class="cube-typed-cursor">|</span>
    </div>
    
</header>

    <style>
        nav.cube-menu:before {
            content: '';
            visibility: hidden;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 44px;
        
            filter: blur(5px);
            -webkit-filter: blur(5px);
        
            z-index: -1;
            background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201502%2F28%2F20150228220759_zaP3N.png&amp;refer=http%3A%2F%2Fb-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664943562&amp;t=f546331d7d5aee27ceb7af09c60899f2');
            background-repeat: no-repeat;
            background-position: center -356px;
            background-size: cover;
            background-color: transparent;
        }

        header.cube-background.cube-header-background {
            visibility: hidden;
            background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201502%2F28%2F20150228220759_zaP3N.png&amp;refer=http%3A%2F%2Fb-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664943562&amp;t=f546331d7d5aee27ceb7af09c60899f2');
            background-position: center -400px;
        }
    </style>
    <header class="cube-background cube-header-background">
        
        <div class="cube-type">
            <span class="cube-typed-title">🍍的个人博客 ^_^</span>
            <span class="cube-typed-cursor">|</span>
        </div>
        
    </header>
    <div class="load-header-background"></div>
    <script>
        (function (window) {

            window.headerModule = {}
            window.headerModule.image = {
                width: '2000',
                height: '1414'
            }

        })(window)
    </script>
    
    <div class="cube-content">
        <div class="cube-left">
            
<div class="cube-excerpt" id="cube-excerpt-vue3-Composition Api 与  Options Api 有什么不同">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/09/02/Vue/vue3-Composition%20Api%20%E4%B8%8E%20%20Options%20Api%20%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/">vue3-Composition Api 与  Options Api 有什么不同</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-09-02
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/vue3/" class="cube-excerpt-tag-link">#vue3</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p><code>Composition API</code> 可以说是<code>Vue3</code>的最大特点，那么为什么要推出<code>Composition Api</code>，解决了什么问题？</p>
<p>通常使用<code>Vue2</code>开发的项目，普遍会存在以下问题：</p>
<ul>
<li>代码的可读性随着组件变大而变差</li>
<li>每一种代码复用的方式，都存在缺点</li>
<li>TypeScript支持有限</li>
</ul>
<p>以上通过使用<code>Composition Api</code>都能迎刃而解</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一、Options-Api"><a href="#一、Options-Api" class="headerlink" title="一、Options Api"></a>一、Options Api</h3><p><code>Options API</code>，即大家常说的选项API，即以<code>vue</code>为后缀的文件，通过定义<code>methods</code>，<code>computed</code>，<code>watch</code>，<code>data</code>等属性与方法，共同处理页面逻辑</p>
<p>如下图：</p>
<p><img src="https://static.vue-js.com/9bf6d9d0-6048-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>可以看到<code>Options</code>代码编写方式，如果是组件状态，则写在<code>data</code>属性上，如果是方法，则写在<code>methods</code>属性上…</p>
<p>用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有效</p>
<p>然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</p>
<h3 id="二、Composition-Api"><a href="#二、Composition-Api" class="headerlink" title="二、Composition Api"></a>二、Composition Api</h3><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p>
<p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p>
<p><img src="https://static.vue-js.com/acee9200-6048-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<h3 id="三、对比"><a href="#三、对比" class="headerlink" title="三、对比"></a>三、对比</h3><p>下面对<code>Composition Api</code>与<code>Options Api</code>进行两大方面的比较</p>
<ul>
<li>逻辑组织</li>
<li>逻辑复用</li>
</ul>
<h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><h5 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h5><p>假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）</p>
<p><img src="https://static.vue-js.com/dc83d070-6048-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>可以看到，这种碎片化使得理解和维护复杂组件变得困难</p>
<p>选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块</p>
<h5 id="Compostion-API"><a href="#Compostion-API" class="headerlink" title="Compostion API"></a>Compostion API</h5><p>而<code>Compositon API</code>正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去</p>
<p>下面举个简单例子，将处理<code>count</code>属性相关的代码放在同一个函数了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleConut</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        count.<span class="property">value</span> = count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count,</span><br><span class="line">        double,</span><br><span class="line">        handleConut,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件上中使用<code>count</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count, double, handleConut &#125; = <span class="title function_">useCount</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            handleConut</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>再来一张图进行对比，可以很直观地感受到 <code>Composition API</code>在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可</p>
<p><img src="https://static.vue-js.com/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在<code>Vue2</code>中，我们是用过<code>mixin</code>去复用相同的逻辑</p>
<p>下面举个例子，我们会另起一个<code>mixin.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MoveMixin</span> = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handleKeyup</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">      <span class="comment">// 上下左右 x y</span></span><br><span class="line">      <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在组件中使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> mousePositionMixin <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mixins</span>: [mousePositionMixin]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mixins</span>: [mousePositionMixin, fooMixin, barMixin, otherMixin]</span><br></pre></td></tr></table></figure>

<p>会存在两个非常明显的问题：</p>
<ul>
<li>命名冲突</li>
<li>数据来源不清晰</li>
</ul>
<p>现在通过<code>Compositon API</code>这种方式改写上面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyup</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">    <span class="comment">// 上下左右 x y</span></span><br><span class="line">    <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value--;</span></span><br><span class="line">        position.<span class="property">y</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value++;</span></span><br><span class="line">        position.<span class="property">y</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value--;</span></span><br><span class="line">        position.<span class="property">x</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value++;</span></span><br><span class="line">        position.<span class="property">x</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; position &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件中使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; useMove &#125; <span class="keyword">from</span> <span class="string">&quot;./useMove&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; position &#125; = <span class="title function_">useMove</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">toRefs</span>(position);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      x,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      y,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在逻辑组织和逻辑复用方面，<code>Composition API</code>是优于<code>Options API</code></li>
<li>因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li>
<li><code>Composition API</code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li>
<li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li>
<li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li>
</ul>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/09/02/Vue/vue3-Composition%20Api%20%E4%B8%8E%20%20Options%20Api%20%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-Typescript总结">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/08/23/html+css+js+ts/5-Typescript%E6%80%BB%E7%BB%93/">Typescript总结</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-08-23
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/typescript/" class="cube-excerpt-tag-link">#typescript</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-1-什么是-TypeScript"><a href="#1-1-什么是-TypeScript" class="headerlink" title="1.1 什么是 TypeScript"></a>1.1 什么是 TypeScript</h2><ul>
<li><code>TypeScript</code> 是 <code>JavaScript</code> 的一个超集，主要提供了类型系统和对 <code>ES6</code>的支持</li>
<li><code>TypeScript</code> 是由微软开发的一款开源的编程语言</li>
<li><code>TypeScript</code> 是 <code>Javascript</code> 的超级，遵循最新的 <code>ES6</code>、<code>Es5</code> 规范。<code>TypeScript</code> 扩展了 <code>JavaScript</code> 的语法</li>
<li><code>TypeScript</code> 更像后端 <code>java</code>、<code>C#</code>这样的面向对象语言可以让 <code>js</code> 开发大型企业项目</li>
</ul>
<h2 id="1-2-为什么选择-TypeScript"><a href="#1-2-为什么选择-TypeScript" class="headerlink" title="1.2 为什么选择 TypeScript"></a>1.2 为什么选择 TypeScript</h2><blockquote>
<p><code>Typescript</code>和<code>es6</code>、<code>es5</code>关系</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/583.png" alt="img"></p>
<p><strong>TypeScript 增加了代码的可读性和可维护性</strong></p>
<ul>
<li>类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了</li>
<li>可以在编译阶段就发现大部分错误，这总比在运行时候出错好</li>
<li>增强了编辑器和 <code>IDE</code> 的功能，包括代码补全、接口提示、跳转到定义、重构等</li>
</ul>
<p><strong>TypeScript 非常包容</strong></p>
<ul>
<li><code>TypeScript</code> 是 <code>JavaScript</code> 的超集，<code>.js</code> 文件可以直接重命名为 <code>.ts</code> 即可</li>
<li>即使不显式的定义类型，也能够自动做出类型推论</li>
<li>可以定义从简单到复杂的几乎一切类型</li>
<li>即使 <code>TypeScript</code> 编译报错，也可以生成 <code>JavaScript</code> 文件</li>
<li>兼容第三方库，即使第三方库不是用 <code>TypeScript</code> 写的，也可以编写单独的类型文件供 <code>TypeScript</code> 读取</li>
</ul>
<p><strong>TypeScript 拥有活跃的社区</strong></p>
<ul>
<li>大部分第三方库都有提供给 <code>TypeScript</code> 的类型定义文件</li>
<li><code>Google</code> 开发的<code>Angular2</code> 就是使用 <code>TypeScript</code> 编写的</li>
<li><code>TypeScript</code> 拥抱了 <code>ES6</code> 规范，也支持部分 <code>ESNext</code> 草案的规范</li>
<li>最新的 <code>Vue</code> 、<code>React</code> 也可以集成 <code>TypeScript</code></li>
</ul>
<p><strong>TypeScript 的缺点</strong></p>
<ul>
<li>有一定的学习成本，需要理解接口（<code>Interfaces</code>）、泛型（<code>Generics</code>）、类（<code>Classes</code>）、枚举类型（<code>Enums</code>）等前端工程师可能不是很熟悉的概念</li>
<li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，<code>TypeScript</code> 能够减少其维护成本</li>
<li>集成到构建流程需要一些工作量</li>
<li>可能和一些库结合的不是很完美</li>
</ul>
<h2 id="1-3-安装-TypeScript"><a href="#1-3-安装-TypeScript" class="headerlink" title="1.3 安装 TypeScript"></a>1.3 安装 TypeScript</h2><p><strong>typescript 安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局安装完成后，我们新建一个<code>hello.ts</code>的<code>ts</code>文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.ts内容</span><br><span class="line">let a = &quot;poet&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来我们在命令行输入<code>tsc hello.ts</code>来编译这个<code>ts</code>文件，然后会在同级目录生成一个编译好了的<code>hello.js</code>文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.js内容</span><br><span class="line">var = &quot;poet&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么我们每次都要输<code>tsc hello.ts</code>命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，使用<code>vscode</code>来开发，需要配置一下<code>vscode</code>就可以。</p>
</blockquote>
<blockquote>
<p>首先我们在命令行执行<code>tsc --init</code>来生成配置文件，然后我们在目录下看到生成了一个<code>tsconfig.json</code>文件</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/584.png" alt="img"></p>
<blockquote>
<p>这个<code>json</code>文件里有很多选项</p>
</blockquote>
<ul>
<li><code>target</code>是选择编译到什么语法</li>
<li><code>module</code>则是模块类型</li>
<li><code>outDir</code>则是输出目录，可以指定这个参数到指定目录</li>
</ul>
<blockquote>
<p>更多细节 <a target="_blank" rel="noopener" href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html</a></p>
</blockquote>
<blockquote>
<p>接下来我们需要开启监控了，在<code>vscode</code>任务栏中</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/585.png" alt="img"></p>
<h2 id="1-4-Hello-TypeScript"><a href="#1-4-Hello-TypeScript" class="headerlink" title="1.4 Hello TypeScript"></a>1.4 Hello TypeScript</h2><blockquote>
<p>将以下代码复制到 <code>hello.ts</code> 中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(person: string) &#123;</span><br><span class="line">    return &#x27;Hello, &#x27; + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = &#x27;poetries&#x27;;</span><br><span class="line">console.log(sayHello(user));</span><br><span class="line">tsc hello.ts</span><br><span class="line">//这时候会生成一个编译好的文件 hello.js：</span><br><span class="line"></span><br><span class="line">function sayHello(person) &#123;</span><br><span class="line">    return &#x27;Hello, &#x27; + person;</span><br><span class="line">&#125;</span><br><span class="line">var user = &#x27;poetries&#x27;;</span><br><span class="line">console.log(sayHello(user));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>TypeScript</code> 中，使用 <code>:</code> 指定变量的类型，<code>:</code> 的前后有没有空格都可以</p>
</blockquote>
<ul>
<li><code>TypeScript</code> 只会进行静态检查，如果发现有错误，编译的时候就会报错</li>
<li><code>TypeScript</code> 编译的时候即使报错了，还是会生成编译结果，我们仍然可以使用这个编译之后的文件</li>
</ul>
<h1 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h1><h2 id="2-1-原始数据类型"><a href="#2-1-原始数据类型" class="headerlink" title="2.1 原始数据类型"></a>2.1 原始数据类型</h2><blockquote>
<p><code>JavaScript</code> 的类型分为两种：原始数据类型（<code>Primitive data types</code>）和对象类型（<code>Object types</code>）。</p>
</blockquote>
<ul>
<li>原始数据类型包括：<code>布尔值</code>、<code>数值</code>、<code>字符串</code>、<code>null</code>、<code>undefined</code> 以及 <code>ES6</code>中的新类型 <code>Symbol</code>。</li>
</ul>
<blockquote>
<p>本节主要介绍前五种原始数据类型在 <code>TypeScript</code> 中的应用</p>
</blockquote>
<h3 id="2-1-1-布尔值"><a href="#2-1-1-布尔值" class="headerlink" title="2.1.1 布尔值"></a>2.1.1 布尔值</h3><blockquote>
<p>布尔值是最基础的数据类型，在 <code>TypeScript</code> 中，使用 <code>boolean</code> 定义布尔值类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let isDone: boolean = false;</span><br><span class="line"></span><br><span class="line">// 编译通过</span><br><span class="line">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，使用构造函数 <code>Boolean</code> 创造的对象不是布尔值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let createdByNewBoolean: boolean = new Boolean(1);</span><br><span class="line"></span><br><span class="line">// index.ts(1,5): error TS2322: Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.</span><br><span class="line">// 后面约定，注释中标出了编译报错的代码片段，表示编译未通过</span><br></pre></td></tr></table></figure>

<ul>
<li>事实上 <code>new Boolean()</code> 返回的是一个 <code>Boolean</code> 对象：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let createdByNewBoolean: Boolean = new Boolean(1);</span><br></pre></td></tr></table></figure>

<ul>
<li>直接调用 <code>Boolean</code> 也可以返回一个 <code>boolean</code> 类型：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let createdByBoolean: boolean = Boolean(1);</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>TypeScript</code> 中，<code>boolean</code>是 <code>JavaScript</code> 中的基本类型，而 <code>Boolean</code> 是 <code>JavaScript</code>中的构造函数。其他基本类型（除了 <code>null</code> 和 <code>undefined</code>）一样</li>
</ul>
<h3 id="2-1-2-数值"><a href="#2-1-2-数值" class="headerlink" title="2.1.2 数值"></a>2.1.2 数值</h3><blockquote>
<p>使用 <code>number</code> 定义数值类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line"></span><br><span class="line">// ES6 中的二进制表示法</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line"></span><br><span class="line">// ES6 中的八进制表示法</span><br><span class="line">let octalLiteral: number = 0o744;</span><br><span class="line">let notANumber: number = NaN;</span><br><span class="line">let infinityNumber: number = Infinity;</span><br><span class="line">//编译结果：</span><br><span class="line"></span><br><span class="line">var decLiteral = 6;</span><br><span class="line">var hexLiteral = 0xf00d;</span><br><span class="line">// ES6 中的二进制表示法</span><br><span class="line">var binaryLiteral = 10;</span><br><span class="line">// ES6 中的八进制表示法</span><br><span class="line">var octalLiteral = 484;</span><br><span class="line">var notANumber = NaN;</span><br><span class="line">var infinityNumber = Infinity;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中 <code>0b101</code>0 和 <code>0o744</code>是 <code>ES6</code> 中的二进制和八进制表示法，它们会被编译为十进制数字</p>
</blockquote>
<h3 id="2-1-3-字符串"><a href="#2-1-3-字符串" class="headerlink" title="2.1.3 字符串"></a>2.1.3 字符串</h3><blockquote>
<p>使用 <code>string</code> 定义字符串类型：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let myName: string = &#x27;Tom&#x27;;</span><br><span class="line">let myAge: number = 25;</span><br><span class="line"></span><br><span class="line">// 模板字符串</span><br><span class="line">let sentence: string = `Hello, my name is $&#123;myName&#125;.</span><br><span class="line">I&#x27;ll be $&#123;myAge + 1&#125; years old next month.`;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-空值"><a href="#2-1-4-空值" class="headerlink" title="2.1.4 空值"></a>2.1.4 空值</h3><blockquote>
<p><code>JavaScript</code> 没有空值（<code>Void</code>）的概念，在 <code>TypeScript</code> 中，可以用 <code>void</code> 表示没有任何返回值的函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function alertName(): void &#123;</span><br><span class="line">    alert(&#x27;My name is Tom&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code>和 <code>null</code>：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-Null-和-Undefined"><a href="#2-1-5-Null-和-Undefined" class="headerlink" title="2.1.5 Null 和 Undefined"></a>2.1.5 Null 和 Undefined</h3><blockquote>
<p>在 <code>TypeScript</code> 中，可以使用 <code>null</code> 和 <code>undefined</code>来定义这两个原始数据类型：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined` 类型的变量只能被赋值为 `undefined`，`null` 类型的变量只能被赋值为 `null</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>与 <code>void</code> 的区别是，<code>undefined</code>和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 这样不会报错</span><br><span class="line">let num: number = undefined;</span><br><span class="line"></span><br><span class="line">// 这样也不会报错</span><br><span class="line">let u: undefined;</span><br><span class="line">let num: number = u;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而 <code>void</code> 类型的变量不能赋值给 <code>number</code> 类型的变量：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let u: void;</span><br><span class="line">let num: number = u;</span><br><span class="line"></span><br><span class="line">// index.ts(2,5): error TS2322: Type &#x27;void&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="2-2-任意值Any"><a href="#2-2-任意值Any" class="headerlink" title="2.2 任意值Any"></a>2.2 任意值Any</h2><blockquote>
<p>如果是一个普通类型，在赋值过程中改变类型是不被允许的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: any = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure>

<p><strong>任意值的属性和方法</strong></p>
<p>在任意值上访问任何属性都是允许的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let anyThing: any = &#x27;hello&#x27;;</span><br><span class="line"></span><br><span class="line">console.log(anyThing.myName);</span><br><span class="line">console.log(anyThing.myName.firstName);</span><br></pre></td></tr></table></figure>

<p><strong>也允许调用任何方法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let anyThing: any = &#x27;Tom&#x27;;</span><br><span class="line"></span><br><span class="line">anyThing.setName(&#x27;Jerry&#x27;);</span><br><span class="line">anyThing.setName(&#x27;Jerry&#x27;).sayHello();</span><br><span class="line">anyThing.myName.setFirstName(&#x27;Cat&#x27;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</p>
</blockquote>
<p><strong>未声明类型的变量</strong></p>
<blockquote>
<p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let something;</span><br><span class="line">something = &#x27;seven&#x27;;</span><br><span class="line">something = 7;</span><br><span class="line"></span><br><span class="line">something.setName(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let something: any;</span><br><span class="line">something = &#x27;seven&#x27;;</span><br><span class="line">something = 7;</span><br><span class="line"></span><br><span class="line">something.setName(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="2-3-类型推论"><a href="#2-3-类型推论" class="headerlink" title="2.3 类型推论"></a>2.3 类型推论</h2><blockquote>
<p>如果没有明确的指定类型，那么 <code>TypeScript</code> 会依照类型推论（<code>Type Inference</code>）的规则推断出一个类型</p>
</blockquote>
<p><strong>什么是类型推论</strong></p>
<p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>

<p>事实上，它等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>

<p><code>TypeScript</code> 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论</p>
<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber;</span><br><span class="line"></span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-联合类型"><a href="#2-4-联合类型" class="headerlink" title="2.4 联合类型"></a>2.4 联合类型</h2><blockquote>
<p>联合类型（<code>Union Types</code>）表示取值可以为多种类型中的一种</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 简单例子</span><br><span class="line"></span><br><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = true;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;boolean&#x27; is not assignable to type &#x27;string | number&#x27;.</span><br><span class="line">//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<ul>
<li>联合类型使用 <code>|</code> 分隔每个类型。</li>
<li>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型</li>
</ul>
<p><strong>访问联合类型的属性或方法</strong></p>
<blockquote>
<p>当 <code>TypeScript</code> 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// length 不是 string 和 number 的共有属性，所以会报错</span><br><span class="line">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getString(something: string | number): string &#123;</span><br><span class="line">    return something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line"></span><br><span class="line">console.log(myFavoriteNumber.length); // 5</span><br><span class="line"></span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line">console.log(myFavoriteNumber.length); // 编译时报错</span><br><span class="line"></span><br><span class="line">// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</li>
<li>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了</li>
</ul>
<h2 id="2-5-对象的类型——接口"><a href="#2-5-对象的类型——接口" class="headerlink" title="2.5 对象的类型——接口"></a>2.5 对象的类型——接口</h2><h3 id="2-5-1-简单例子"><a href="#2-5-1-简单例子" class="headerlink" title="2.5.1 简单例子"></a>2.5.1 简单例子</h3><blockquote>
<p>在 <code>TypeScript</code> 中，我们使用接口（<code>Interfaces</code>）来定义对象的类型</p>
</blockquote>
<p><strong>什么是接口</strong></p>
<ul>
<li>在面向对象语言中，接口（<code>Interfaces</code>）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（<code>classes</code>）去实现（<code>implements</code>）。</li>
<li><code>TypeScript</code> 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（<code>Shape</code>）」进行描述。</li>
</ul>
<p>接口一般首字母大写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致</p>
</blockquote>
<p><strong>定义的变量比接口少了一些属性是不允许的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(6,5): error TS2322: Type &#x27;&#123; name: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27;.</span><br></pre></td></tr></table></figure>

<p><strong>多一些属性也是不允许的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(9,5): error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见，赋值的时候，变量的形状必须和接口的形状保持一致。</p>
</blockquote>
<h3 id="2-5-2-可选属性"><a href="#2-5-2-可选属性" class="headerlink" title="2.5.2 可选属性"></a>2.5.2 可选属性</h3><blockquote>
<p>有时我们希望不要完全匹配一个形状，那么可以用可选属性</p>
</blockquote>
<p>可选属性的含义是该属性可以不存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-3-任意属性"><a href="#2-5-3-任意属性" class="headerlink" title="2.5.3 任意属性"></a>2.5.3 任意属性</h3><blockquote>
<p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值</li>
<li>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span><br><span class="line">// index.ts(7,5): error TS2322: Type &#x27;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Index signatures are incompatible.</span><br><span class="line">//     Type &#x27;string | number&#x27; is not assignable to type &#x27;string&#x27;.</span><br><span class="line">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code>不是 <code>string</code> 的子属性，所以报错了。</li>
<li>另外，在报错信息中可以看出，此时 <code>&#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;</code>的类型被推断成了 <code>&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;</code>，这是联合类型和接口的结合</li>
</ul>
<h3 id="2-5-4-只读属性"><a href="#2-5-4-只读属性" class="headerlink" title="2.5.4 只读属性"></a>2.5.4 只读属性</h3><blockquote>
<p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code>定义只读属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    id: 89757,</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 9527;</span><br><span class="line"></span><br><span class="line">// index.ts(14,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了</p>
</blockquote>
<p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 89757;</span><br><span class="line"></span><br><span class="line">// index.ts(8,5): error TS2322: Type &#x27;&#123; name: string; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; gender: string; &#125;&#x27;.</span><br><span class="line">// index.ts(13,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</li>
<li>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了</li>
</ul>
<h2 id="2-6-数组的类型"><a href="#2-6-数组的类型" class="headerlink" title="2.6 数组的类型"></a>2.6 数组的类型</h2><blockquote>
<p>在 <code>TypeScript</code> 中，数组类型有多种定义方式，比较灵活。</p>
</blockquote>
<h3 id="2-6-1「类型-方括号」表示法"><a href="#2-6-1「类型-方括号」表示法" class="headerlink" title="2.6.1「类型 + 方括号」表示法"></a>2.6.1「类型 + 方括号」表示法</h3><blockquote>
<p>最简单的方法是使用「类型 + 方括号」来表示数组：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组的项中不允许出现其他的类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, &#x27;1&#x27;, 2, 3, 5];</span><br><span class="line"></span><br><span class="line">// index.ts(1,5): error TS2322: Type &#x27;(number | string)[]&#x27; is not assignable to type &#x27;number[]&#x27;.</span><br><span class="line">//   Type &#x27;number | string&#x27; is not assignable to type &#x27;number&#x27;.</span><br><span class="line">//     Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，<code>[1, &#39;1&#39;, 2, 3, 5]</code> 的类型被推断为 <code>(number | string)[]</code>，这是联合类型和数组的结合。</li>
<li>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br><span class="line">fibonacci.push(&#x27;8&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(2,16): error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>string</code> 类型的参数，所以报错了</p>
</blockquote>
<h3 id="2-6-2-数组泛型"><a href="#2-6-2-数组泛型" class="headerlink" title="2.6.2 数组泛型"></a>2.6.2 数组泛型</h3><blockquote>
<p>也可以使用数组泛型（<code>Array Generic</code>）<code>Array</code>来表示数组</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure>

<h3 id="2-6-3-用接口表示数组"><a href="#2-6-3-用接口表示数组" class="headerlink" title="2.6.3 用接口表示数组"></a>2.6.3 用接口表示数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index: number]: number;</span><br><span class="line">&#125;</span><br><span class="line">let fibonacci: NumberArray = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NumberArray` 表示：只要 `index` 的类型是 `number`，那么值的类型必须是 `number</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-6-4-any-在数组中的应用"><a href="#2-6-4-any-在数组中的应用" class="headerlink" title="2.6.4 any 在数组中的应用"></a>2.6.4 any 在数组中的应用</h3><blockquote>
<p>一个比较常见的做法是，用 <code>any</code> 表示数组中允许出现任意类型：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] = [&#x27;poetries&#x27;, 22, &#123; website: &#x27;http://blog.poetries.top&#x27; &#125;];</span><br></pre></td></tr></table></figure>

<h3 id="2-6-5-类数组"><a href="#2-6-5-类数组" class="headerlink" title="2.6.5 类数组"></a>2.6.5 类数组</h3><blockquote>
<p>类数组（<code>Array-like Object</code>）不是数组类型，比如 <code>arguments</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let args: number[] = arguments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,7): error TS2322: Type &#x27;IArguments&#x27; is not assignable to type &#x27;number[]&#x27;.</span><br><span class="line">//   Property &#x27;push&#x27; is missing in type &#x27;IArguments&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上常见的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let args: IArguments = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-函数的类型"><a href="#2-7-函数的类型" class="headerlink" title="2.7 函数的类型"></a>2.7 函数的类型</h2><h3 id="2-7-1-函数声明"><a href="#2-7-1-函数声明" class="headerlink" title="2.7.1 函数声明"></a>2.7.1 函数声明</h3><blockquote>
<p>在 <code>JavaScript</code> 中，有两种常见的定义函数的方式——函数声明（<code>Function Declaration</code>）和函数表达式（<code>Function Expression</code>）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明（Function Declaration）</span><br><span class="line">function sum(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式（Function Expression）</span><br><span class="line">let mySum = function (x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个函数有输入和输出，要在 <code>TypeScript</code> 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，输入多余的（或者少于要求的）参数，是不被允许的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1, 2, 3);</span><br><span class="line"></span><br><span class="line">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1);</span><br><span class="line"></span><br><span class="line">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-函数表达式"><a href="#2-7-2-函数表达式" class="headerlink" title="2.7.2 函数表达式"></a>2.7.2 函数表达式</h3><blockquote>
<p>如果要我们现在写一个对函数表达式（<code>Function Expression</code>）的定义，可能会写成这样</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let mySum = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// =&gt;左边 (x: number, y: number) 是输入类型 </span><br><span class="line">// =&gt;右边number是输出类型</span><br><span class="line">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意不要混淆了 TypeScript 中的 &#x3D;&gt; 和 ES6 中的 &#x3D;&gt;</strong></p>
<blockquote>
<p>在 <code>TypeScript</code> 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>
</blockquote>
<h3 id="2-7-3-用接口定义函数的形状"><a href="#2-7-3-用接口定义函数的形状" class="headerlink" title="2.7.3 用接口定义函数的形状"></a>2.7.3 用接口定义函数的形状</h3><blockquote>
<p>我们也可以使用接口的方式来定义一个函数需要符合的形状</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必须参数了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName?: string, lastName: string) &#123;</span><br><span class="line">    if (firstName) &#123;</span><br><span class="line">        return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(undefined, &#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span><br></pre></td></tr></table></figure>

<h3 id="2-7-4-参数默认值"><a href="#2-7-4-参数默认值" class="headerlink" title="2.7.4 参数默认值"></a>2.7.4 参数默认值</h3><blockquote>
<p>在 <code>ES6</code>中，我们允许给函数的参数添加默认值，<code>TypeScript</code> 会将添加了默认值的参数识别为可选参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName: string = &#x27;Cat&#x27;) &#123;</span><br><span class="line">    return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>此时就不受「可选参数必须接在必需参数后面」的限制了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string = &#x27;Tom&#x27;, lastName: string) &#123;</span><br><span class="line">    return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let cat = buildName(undefined, &#x27;Cat&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="2-7-5-剩余参数"><a href="#2-7-5-剩余参数" class="headerlink" title="2.7.5 剩余参数"></a>2.7.5 剩余参数</h3><blockquote>
<p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（<code>rest</code> 参数）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上，items 是一个数组。所以我们可以用数组的类型来定义它</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function push(array: any[], ...items: any[]) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，rest 参数只能是最后一个参数</p>
</blockquote>
<h3 id="2-7-6-函数重载"><a href="#2-7-6-函数重载" class="headerlink" title="2.7.6 函数重载"></a>2.7.6 函数重载</h3><ul>
<li>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</li>
</ul>
<blockquote>
<p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code></p>
</blockquote>
<p><strong>利用联合类型，我们可以这么实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串</p>
</blockquote>
<p><strong>这时，我们可以使用重载定义多个 reverse 的函数类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line"></span><br><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</li>
</ul>
<blockquote>
<p><strong>注意</strong>，<code>TypeScript</code> 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面</p>
</blockquote>
<h2 id="2-8-类型断言"><a href="#2-8-类型断言" class="headerlink" title="2.8 类型断言"></a>2.8 类型断言</h2><blockquote>
<p>类型断言（<code>Type Assertion</code>）可以用来手动指定一个值的类型。</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">值 as 类型</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>tsx</code> 语法（<code>React</code> 的 <code>jsx</code> 语法的 <code>ts</code> 版）中必须用后一种</p>
</blockquote>
<p><strong>例子：将一个联合类型的变量指定为一个更加具体的类型</strong></p>
<blockquote>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if (something.length) &#123;</span><br><span class="line">        return something.length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br><span class="line">// index.ts(3,26): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，获取 <code>something.length</code>的时候会报错</p>
</blockquote>
<p><strong>此时可以使用类型断言，将 something 断言成 string</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if ((&lt;string&gt;something).length) &#123;</span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类型断言的用法如上，在需要断言的变量前加上 &#96;&#96; 即可</p>
</blockquote>
<p><strong>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function toBoolean(something: string | number): boolean &#123;</span><br><span class="line">    return &lt;boolean&gt;something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,10): error TS2352: Type &#x27;string | number&#x27; cannot be converted to type &#x27;boolean&#x27;.</span><br><span class="line">//   Type &#x27;number&#x27; is not comparable to type &#x27;boolean&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="2-9-声明文件"><a href="#2-9-声明文件" class="headerlink" title="2.9 声明文件"></a>2.9 声明文件</h2><blockquote>
<p>当使用第三方库时，我们需要引用它的声明文件</p>
</blockquote>
<h3 id="2-9-1-声明-declare-语句"><a href="#2-9-1-声明-declare-语句" class="headerlink" title="2.9.1 声明(declare)语句"></a>2.9.1 声明(declare)语句</h3><blockquote>
<p>假如我们想使用第三方库，比如 <code>jQuery</code>，我们通常这样获取一个 <code>id</code> 是 <code>foo</code> 的元素</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;#foo&#x27;);</span><br><span class="line">// or</span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是在 <code>TypeScript</code> 中，我们并不知道 <code>$</code> 或 <code>jQuery</code>是什么东西</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery(&#x27;#foo&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(1,1): error TS2304: Cannot find name &#x27;jQuery&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这时，我们需要使用 <code>declare</code> 关键字来定义它的类型，帮助<code>TypeScript</code> 判断我们传入的参数类型对不对</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare var jQuery: (selector: string) =&gt; any;</span><br><span class="line"></span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//上例的编译结果是：</span><br><span class="line"></span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="2-9-2-声明文件-约定-d-ts后缀"><a href="#2-9-2-声明文件-约定-d-ts后缀" class="headerlink" title="2.9.2 声明文件(约定.d.ts后缀)"></a>2.9.2 声明文件(约定.d.ts后缀)</h3><blockquote>
<p>通常我们会把类型声明放到一个单独的文件中，这就是声明文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// jQuery.d.ts</span><br><span class="line"></span><br><span class="line">declare var jQuery: (string) =&gt; any;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们约定声明文件以 <code>.d.ts</code> 为后缀。</li>
<li>然后在使用到的文件的开头，用<code>「三斜线指令」///</code>表示引用了声明文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;reference path=&quot;./jQuery.d.ts&quot; /&gt;</span><br><span class="line"></span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="2-9-3-第三方声明文件"><a href="#2-9-3-第三方声明文件" class="headerlink" title="2.9.3 第三方声明文件"></a>2.9.3 第三方声明文件</h3><blockquote>
<p>当然，<code>jQuery</code> 的声明文件不需要我们定义了，已经有人帮我们定义好了：<a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/index.d.ts">jQuery in DefinitelyTyped</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/index.d.ts</span><br><span class="line"></span><br><span class="line">// Type definitions for jquery 3.3</span><br><span class="line">// Project: https://jquery.com</span><br><span class="line">// Definitions by: Leonard Thieu &lt;https://github.com/leonard-thieu&gt;</span><br><span class="line">//                 Boris Yankov &lt;https://github.com/borisyankov&gt;</span><br><span class="line">//                 Christian Hoffmeister &lt;https://github.com/choffmeister&gt;</span><br><span class="line">//                 Steve Fenton &lt;https://github.com/Steve-Fenton&gt;</span><br><span class="line">//                 Diullei Gomes &lt;https://github.com/Diullei&gt;</span><br><span class="line">//                 Tass Iliopoulos &lt;https://github.com/tasoili&gt;</span><br><span class="line">//                 Jason Swearingen &lt;https://github.com/jasons-novaleaf&gt;</span><br><span class="line">//                 Sean Hill &lt;https://github.com/seanski&gt;</span><br><span class="line">//                 Guus Goossens &lt;https://github.com/Guuz&gt;</span><br><span class="line">//                 Kelly Summerlin &lt;https://github.com/ksummerlin&gt;</span><br><span class="line">//                 Basarat Ali Syed &lt;https://github.com/basarat&gt;</span><br><span class="line">//                 Nicholas Wolverson &lt;https://github.com/nwolverson&gt;</span><br><span class="line">//                 Derek Cicerone &lt;https://github.com/derekcicerone&gt;</span><br><span class="line">//                 Andrew Gaspar &lt;https://github.com/AndrewGaspar&gt;</span><br><span class="line">//                 Seikichi Kondo &lt;https://github.com/seikichi&gt;</span><br><span class="line">//                 Benjamin Jackman &lt;https://github.com/benjaminjackman&gt;</span><br><span class="line">//                 Poul Sorensen &lt;https://github.com/s093294&gt;</span><br><span class="line">//                 Josh Strobl &lt;https://github.com/JoshStrobl&gt;</span><br><span class="line">//                 John Reilly &lt;https://github.com/johnnyreilly&gt;</span><br><span class="line">//                 Dick van den Brink &lt;https://github.com/DickvdBrink&gt;</span><br><span class="line">//                 Thomas Schulz &lt;https://github.com/King2500&gt;</span><br><span class="line">//                 Terry Mun &lt;https://github.com/terrymun&gt;</span><br><span class="line">// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped</span><br><span class="line">// TypeScript Version: 2.3</span><br><span class="line"></span><br><span class="line">// 引入声明文件</span><br><span class="line">/// &lt;reference types=&quot;sizzle&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;</span><br><span class="line"></span><br><span class="line">export = jQuery;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以直接下载下来使用，但是更推荐的是使用工具统一管理第三方库的声明文件- 社区已经有多种方式引入声明文件，不过 <code>TypeScript 2.0</code>推荐使用 <code>@types</code> 来管理。</li>
<li><code>@types</code> 的使用方式很简单，直接用 <code>npm</code> 安装对应的声明模块即可，以 <code>jQuery</code> 举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure>

<p><strong>可以在这个页面搜索你需要的声明文件</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://microsoft.github.io/TypeSearch/">http://microsoft.github.io/TypeSearch/</a></p>
</blockquote>
<h2 id="2-10-内置对象"><a href="#2-10-内置对象" class="headerlink" title="2.10 内置对象"></a>2.10 内置对象</h2><blockquote>
<p><code>JavaScript</code> 中有很多内置对象，它们可以直接在 <code>TypeScript</code> 中当做定义好了的类型</p>
</blockquote>
<blockquote>
<p>内置对象是指根据标准在全局作用域（<code>Global</code>）上存在的对象。这里的标准是指 <code>ECMAScript</code> 和其他环境（比如 <code>DOM</code>）的标准</p>
</blockquote>
<h3 id="2-10-1-ECMAScript-的内置对象"><a href="#2-10-1-ECMAScript-的内置对象" class="headerlink" title="2.10.1 ECMAScript 的内置对象"></a>2.10.1 ECMAScript 的内置对象</h3><p><strong>ECMAScript 标准提供的内置对象有</strong></p>
<blockquote>
<p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等</p>
</blockquote>
<p>我们可以在 <code>TypeScript</code> 中将变量定义为这些类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let b: Boolean = new Boolean(1);</span><br><span class="line"></span><br><span class="line">let e: Error = new Error(&#x27;Error occurred&#x27;);</span><br><span class="line"></span><br><span class="line">let d: Date = new Date();</span><br><span class="line"></span><br><span class="line">let r: RegExp = /[a-z]/;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多的内置对象，可以查看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">MDN 的文档</a></p>
</blockquote>
<blockquote>
<p>而他们的定义文件，则在 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件中</a></p>
</blockquote>
<h3 id="2-10-2-DOM-和-BOM-的内置对象"><a href="#2-10-2-DOM-和-BOM-的内置对象" class="headerlink" title="2.10.2 DOM 和 BOM 的内置对象"></a>2.10.2 DOM 和 BOM 的内置对象</h3><p><strong>DOM 和 BOM 提供的内置对象有</strong></p>
<blockquote>
<p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p>
</blockquote>
<blockquote>
<p>TypeScript 中会经常用到这些类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let body: HTMLElement = document.body;</span><br><span class="line">let allDiv: NodeList = document.querySelectorAll(&#x27;div&#x27;);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#x27;click&#x27;, function(e: MouseEvent) &#123;</span><br><span class="line">  // Do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>它们的定义文件同样在 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件中</a></p>
</blockquote>
<h3 id="2-10-3-TypeScript-核心库的定义文件"><a href="#2-10-3-TypeScript-核心库的定义文件" class="headerlink" title="2.10.3 TypeScript 核心库的定义文件"></a>2.10.3 TypeScript 核心库的定义文件</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库</a>的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的</p>
</blockquote>
<blockquote>
<p>当你在使用一些常用的方法的时候，<code>TypeScript</code> 实际上已经帮你做了很多类型判断的工作了，比如</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(10, &#x27;2&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(1,14): error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code>的类型定义如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Math &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the value of a base expression taken to a specified power.</span><br><span class="line">     * @param x The base value of the expression.</span><br><span class="line">     * @param y The exponent value of the expression.</span><br><span class="line">     */</span><br><span class="line">    pow(x: number, y: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再举一个 <code>DOM</code> 中的例子</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;click&#x27;, function(e) &#123;</span><br><span class="line">    console.log(e.targetCurrent);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// index.ts(2,17): error TS2339: Property &#x27;targetCurrent&#x27; does not exist on type &#x27;MouseEvent&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，<code>addEventListener</code> 方法是在 <code>TypeScript</code> 核心库中定义的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;</span><br><span class="line">    addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?: boolean): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了</p>
</blockquote>
<p><strong>注意，TypeScript 核心库的定义中不包含 Node.js 部分</strong></p>
<h3 id="2-10-4-用-TypeScript-写-Node-js"><a href="#2-10-4-用-TypeScript-写-Node-js" class="headerlink" title="2.10.4 用 TypeScript 写 Node.js"></a>2.10.4 用 TypeScript 写 Node.js</h3><blockquote>
<p><code>Node.js</code> 不是内置对象的一部分，如果想用 <code>TypeScript</code> 写 <code>Node.js</code>，则需要引入第三方声明文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/node --save-dev</span><br></pre></td></tr></table></figure>

<h1 id="三、进阶"><a href="#三、进阶" class="headerlink" title="三、进阶"></a>三、进阶</h1><h2 id="3-1-类型别名"><a href="#3-1-类型别名" class="headerlink" title="3.1 类型别名"></a>3.1 类型别名</h2><blockquote>
<p>类型别名用来给一个类型起个新名字</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Name = string;</span><br><span class="line"></span><br><span class="line">type NameResolver = () =&gt; string;</span><br><span class="line"></span><br><span class="line">type NameOrResolver = Name | NameResolver; // 联合类型</span><br><span class="line"></span><br><span class="line">function getName(n: NameOrResolver): Name &#123;</span><br><span class="line">    if (typeof n === &#x27;string&#x27;) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，我们使用 <code>type</code> 创建类型别名。</p>
<blockquote>
<p>类型别名常用于联合类型</p>
</blockquote>
<h2 id="3-2-字符串字面量类型"><a href="#3-2-字符串字面量类型" class="headerlink" title="3.2 字符串字面量类型"></a>3.2 字符串字面量类型</h2><blockquote>
<p>字符串字面量类型用来约束取值只能是某几个字符串中的一个</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type EventNames = &#x27;click&#x27; | &#x27;scroll&#x27; | &#x27;mousemove&#x27;;</span><br><span class="line">function handleEvent(ele: Element, event: EventNames) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleEvent(document.getElementById(&#x27;hello&#x27;), &#x27;scroll&#x27;);  // 没问题</span><br><span class="line">handleEvent(document.getElementById(&#x27;world&#x27;), &#x27;dbclick&#x27;); // 报错，event 不能为 &#x27;dbclick&#x27;</span><br><span class="line"></span><br><span class="line">// index.ts(7,47): error TS2345: Argument of type &#x27;&quot;dbclick&quot;&#x27; is not assignable to parameter of type &#x27;EventNames&#x27;.</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</li>
</ul>
<p><strong>注意，类型别名与字符串字面量类型都是使用 type 进行定</strong></p>
<h2 id="3-3-元组"><a href="#3-3-元组" class="headerlink" title="3.3 元组"></a>3.3 元组</h2><ul>
<li>数组合并了相同类型的对象，而元组（<code>Tuple</code>）合并了不同类型的对象。</li>
<li>元组起源于函数编程语言,在这些语言中频繁使用元组。</li>
</ul>
<h3 id="3-3-1-简单的例子"><a href="#3-3-1-简单的例子" class="headerlink" title="3.3.1 简单的例子"></a>3.3.1 简单的例子</h3><blockquote>
<p>定义一对值分别为 <code>string</code> 和 <code>number</code>的元组</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number] = [&#x27;poetries&#x27;, 22];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当赋值或访问一个已知索引的元素时，会得到正确的类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number];</span><br><span class="line">user[0] = &#x27;poetries&#x27;;</span><br><span class="line">user[1] = 22;</span><br><span class="line"></span><br><span class="line">user[0].slice(1);</span><br><span class="line">user[1].toFixed(2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以只赋值其中一项</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number];</span><br><span class="line">user[0] = &#x27;poetries&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-越界的元素"><a href="#3-3-2-越界的元素" class="headerlink" title="3.3.2 越界的元素"></a>3.3.2 越界的元素</h3><blockquote>
<p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number];</span><br><span class="line">user = [&#x27;poetries&#x27;, 22];</span><br><span class="line">user.push(&#x27;http://blog.poetries.top&#x27;);</span><br><span class="line">user.push(true);</span><br><span class="line"></span><br><span class="line">// index.ts(4,14): error TS2345: Argument of type &#x27;boolean&#x27; is not assignable to parameter of type &#x27;string | number&#x27;.</span><br><span class="line">//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="3-4-枚举"><a href="#3-4-枚举" class="headerlink" title="3.4 枚举"></a>3.4 枚举</h2><blockquote>
<p>枚举（<code>Enum</code>）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等</p>
</blockquote>
<h3 id="3-4-1-简单的例子"><a href="#3-4-1-简单的例子" class="headerlink" title="3.4.1 简单的例子"></a>3.4.1 简单的例子</h3><blockquote>
<p>枚举使用 <code>enum</code> 关键字来定义：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>枚举成员会被赋值为从 <code>0</code> 开始递增的数字，同时也会对枚举值到枚举名进行反向映射</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 0); // true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1); // true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2); // true</span><br><span class="line">console.log(Days[&quot;Sat&quot;] === 6); // true</span><br><span class="line"></span><br><span class="line">console.log(Days[0] === &quot;Sun&quot;); // true</span><br><span class="line">console.log(Days[1] === &quot;Mon&quot;); // true</span><br><span class="line">console.log(Days[2] === &quot;Tue&quot;); // true</span><br><span class="line">console.log(Days[6] === &quot;Sat&quot;); // true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上，上面的例子会被编译为</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;</span><br><span class="line">    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;</span><br><span class="line">    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;</span><br><span class="line">    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;</span><br><span class="line">    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-手动赋值"><a href="#3-4-2-手动赋值" class="headerlink" title="3.4.2 手动赋值"></a>3.4.2 手动赋值</h3><blockquote>
<p>我们也可以给枚举项手动赋值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 7); // true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1); // true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2); // true</span><br><span class="line">console.log(Days[&quot;Sat&quot;] === 6); // true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增</p>
</blockquote>
<p>如果未手动赋值的枚举项与手动赋值的重复了，<code>TypeScript</code> 是不会察觉到这一点的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 3); // true</span><br><span class="line">console.log(Days[&quot;Wed&quot;] === 3); // true</span><br><span class="line">console.log(Days[3] === &quot;Sun&quot;); // false</span><br><span class="line">console.log(Days[3] === &quot;Wed&quot;); // true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，递增到 <code>3</code> 的时候与前面的 <code>Sun</code> 的取值重复了，但是 <code>TypeScript</code> 并没有报错，导致 <code>Days[3]</code>的值先是 <code>&quot;Sun&quot;</code>，而后又被 <code>&quot;Wed&quot;</code> 覆盖了。编译的结果是</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 3] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;</span><br><span class="line">    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;</span><br><span class="line">    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;</span><br><span class="line">    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;</span><br><span class="line">    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>所以使用的时候需要注意，最好不要出现这种覆盖的情况。</p>
<blockquote>
<p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 <code>tsc</code> 无视类型检查 (编译出的 <code>js</code> 仍然是可用的)：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;&quot;S&quot;&#125;;</span><br><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 7] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 8] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 9] = &quot;Tue&quot;;</span><br><span class="line">    Days[Days[&quot;Wed&quot;] = 10] = &quot;Wed&quot;;</span><br><span class="line">    Days[Days[&quot;Thu&quot;] = 11] = &quot;Thu&quot;;</span><br><span class="line">    Days[Days[&quot;Fri&quot;] = 12] = &quot;Fri&quot;;</span><br><span class="line">    Days[Days[&quot;Sat&quot;] = &quot;S&quot;] = &quot;Sat&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 <code>1</code>：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 7, Mon = 1.5, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 7); // true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1.5); // true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2.5); // true</span><br><span class="line">console.log(Days[&quot;Sat&quot;] === 6.5); // true</span><br></pre></td></tr></table></figure>

<h3 id="3-4-3-常数项和计算所得项"><a href="#3-4-3-常数项和计算所得项" class="headerlink" title="3.4.3 常数项和计算所得项"></a>3.4.3 常数项和计算所得项</h3><blockquote>
<p>枚举项有两种类型：常数项（<code>constant member</code>）和计算所得项（<code>computed member</code>）</p>
</blockquote>
<p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue = &quot;blue&quot;.length&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，<code>&quot;blue&quot;.length</code> 就是一个计算所得项。</p>
</blockquote>
<p>上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = &quot;red&quot;.length, Green, Blue&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(1,33): error TS1061: Enum member must have initializer.</span><br><span class="line">// index.ts(1,40): error TS1061: Enum member must have initializer.</span><br></pre></td></tr></table></figure>

<h3 id="3-4-4-常数枚举"><a href="#3-4-4-常数枚举" class="headerlink" title="3.4.4 常数枚举"></a>3.4.4 常数枚举</h3><blockquote>
<p>常数枚举是使用 <code>const enum</code> 定义的枚举类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//上例的编译结果是：</span><br><span class="line"></span><br><span class="line">var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];</span><br><span class="line">// 假如包含了计算成员，则会在编译阶段报错：</span><br><span class="line"></span><br><span class="line">const enum Color &#123;Red, Green, Blue = &quot;blue&quot;.length&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(1,38): error TS2474: In &#x27;const&#x27; enum declarations member initializer must be constant expression.</span><br></pre></td></tr></table></figure>

<h3 id="3-4-5-外部枚举"><a href="#3-4-5-外部枚举" class="headerlink" title="3.4.5 外部枚举"></a>3.4.5 外部枚举</h3><blockquote>
<p>外部枚举（<code>Ambient Enums</code>）是使用 <code>declare enum</code> 定义的枚举类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>

<ul>
<li>之前提到过，<code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除。</li>
</ul>
<p>上例的编译结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>

<ul>
<li>外部枚举与声明语句一样，常出现在声明文件中。</li>
<li>同时使用 <code>declare</code> 和 <code>const</code> 也是可以的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">declare const enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br><span class="line">// 编译结果：</span><br><span class="line"></span><br><span class="line">var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];</span><br></pre></td></tr></table></figure>

<h2 id="3-5-类"><a href="#3-5-类" class="headerlink" title="3.5 类"></a>3.5 类</h2><h3 id="3-5-1-类的概念"><a href="#3-5-1-类的概念" class="headerlink" title="3.5.1 类的概念"></a>3.5.1 类的概念</h3><blockquote>
<p>类相关的概念做一个简单的介绍</p>
</blockquote>
<ul>
<li>类(<code>Class</code>)：定义了一件事物的抽象特点，包含它的属性和方法</li>
<li>对象（<code>Object</code>）：类的实例，通过 <code>new</code> 生成</li>
<li>面向对象（<code>OOP</code>）的三大特性：封装、继承、多态</li>
<li>封装（<code>Encapsulation</code>）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li>
<li>继承（<code>Inheritance</code>）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>
<li>多态（<code>Polymorphism</code>）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code>还是 <code>Dog</code>，就可以直接调用 <code>eat</code>方法，程序会自动判断出来应该如何执行 <code>eat</code></li>
<li>存取器（<code>getter &amp; setter</code>）：用以改变属性的读取和赋值行为</li>
<li>修饰符（<code>Modifiers</code>）：修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code> 表示公有属性或方法</li>
<li>抽象类（<code>Abstract Class</code>）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>
<li>接口（<code>Interfaces</code>）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（<code>implements</code>）。一个类只能继承自另一个类，但是可以实现多个接口</li>
</ul>
<h3 id="3-5-2-public-private-和-protected"><a href="#3-5-2-public-private-和-protected" class="headerlink" title="3.5.2 public private 和 protected"></a>3.5.2 public private 和 protected</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeScript` 可以使用三种访问修饰符（`Access Modifiers`），分别是 `public`、`private` 和 `protected</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li>
<li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.name); // Jack</span><br><span class="line">a.name = &#x27;Tom&#x27;;</span><br><span class="line">console.log(a.name); // Tom</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p>
</blockquote>
<p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lass Animal &#123;</span><br><span class="line">    private name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.name); // Jack</span><br><span class="line">a.name = &#x27;Tom&#x27;;</span><br><span class="line"></span><br><span class="line">// index.ts(9,13): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br><span class="line">// index.ts(10,1): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子编译后的代码是：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Animal = (function () &#123;</span><br><span class="line">    function Animal(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    return Animal;</span><br><span class="line">&#125;());</span><br><span class="line">var a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.name);</span><br><span class="line">a.name = &#x27;Tom&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(11,17): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    protected name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-3-抽象类"><a href="#3-5-3-抽象类" class="headerlink" title="3.5.3 抽象类"></a>3.5.3 抽象类</h3><blockquote>
<p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p>
</blockquote>
<p><strong>什么是抽象类？</strong></p>
<blockquote>
<p>首先，抽象类是不允许被实例化的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p>
</blockquote>
<p>其次，抽象类中的抽象方法必须被子类实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    public eat() &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; is eating.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = new Cat(&#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(9,7): error TS2515: Non-abstract class &#x27;Cat&#x27; does not implement inherited abstract member &#x27;sayHi&#x27; from class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p>
</blockquote>
<p>下面是一个正确使用抽象类的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    public sayHi() &#123;</span><br><span class="line">        console.log(`Meow, My name is $&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = new Cat(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p>
<blockquote>
<p>需要注意的是，即使是抽象方法，<code>TypeScript</code> 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var __extends = (this &amp;&amp; this.__extends) || function (d, b) &#123;</span><br><span class="line">    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];</span><br><span class="line">    function __() &#123; this.constructor = d; &#125;</span><br><span class="line">    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());</span><br><span class="line">&#125;;</span><br><span class="line">var Animal = (function () &#123;</span><br><span class="line">    function Animal(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    return Animal;</span><br><span class="line">&#125;());</span><br><span class="line">var Cat = (function (_super) &#123;</span><br><span class="line">    __extends(Cat, _super);</span><br><span class="line">    function Cat() &#123;</span><br><span class="line">        _super.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    Cat.prototype.sayHi = function () &#123;</span><br><span class="line">        console.log(&#x27;Meow, My name is &#x27; + this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return Cat;</span><br><span class="line">&#125;(Animal));</span><br><span class="line">var cat = new Cat(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="3-5-4-类的类型"><a href="#3-5-4-类的类型" class="headerlink" title="3.5.4 类的类型"></a>3.5.4 类的类型</h3><blockquote>
<p>给类加上 <code>TypeScript</code> 的类型很简单，与接口类似：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi(): string &#123;</span><br><span class="line">      return `My name is $&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a: Animal = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.sayHi()); // My name is Jack</span><br></pre></td></tr></table></figure>

<h2 id="3-6-类与接口"><a href="#3-6-类与接口" class="headerlink" title="3.6 类与接口"></a>3.6 类与接口</h2><h3 id="3-6-1-类实现接口"><a href="#3-6-1-类实现接口" class="headerlink" title="3.6.1 类实现接口"></a>3.6.1 类实现接口</h3><blockquote>
<p>实现（<code>implements</code>）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（<code>interfaces</code>），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性</p>
</blockquote>
<p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Door &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SecurityDoor extends Door implements Alarm &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        console.log(&#x27;SecurityDoor alert&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car implements Alarm &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        console.log(&#x27;Car alert&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个类可以实现多个接口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Light &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car implements Alarm, Light &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        console.log(&#x27;Car alert&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOn() &#123;</span><br><span class="line">        console.log(&#x27;Car light on&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOff() &#123;</span><br><span class="line">        console.log(&#x27;Car light off&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code>接口，既能报警，也能开关车灯</p>
</blockquote>
<h3 id="3-6-2-接口继承接口"><a href="#3-6-2-接口继承接口" class="headerlink" title="3.6.2 接口继承接口"></a>3.6.2 接口继承接口</h3><blockquote>
<p>接口与接口之间可以是继承关系</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface LightableAlarm extends Alarm &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，我们使用 <code>extends</code> 使 <code>LightableAlarm</code> 继承 <code>Alarm</code></p>
</blockquote>
<h3 id="3-6-3-接口继承类"><a href="#3-6-3-接口继承类" class="headerlink" title="3.6.3 接口继承类"></a>3.6.3 接口继承类</h3><blockquote>
<p>接口也可以继承类：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">    z: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-4-混合类型"><a href="#3-6-4-混合类型" class="headerlink" title="3.6.4 混合类型"></a>3.6.4 混合类型</h3><blockquote>
<p>可以使用接口的方式来定义一个函数需要符合的形状</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有时候，一个函数还可以有自己的属性和方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">    (start: number): string;</span><br><span class="line">    interval: number;</span><br><span class="line">    reset(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getCounter(): Counter &#123;</span><br><span class="line">    let counter = &lt;Counter&gt;function (start: number) &#123; &#125;;</span><br><span class="line">    counter.interval = 123;</span><br><span class="line">    counter.reset = function () &#123; &#125;;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = getCounter();</span><br><span class="line">c(10);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = 5.0;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-泛型"><a href="#3-7-泛型" class="headerlink" title="3.7 泛型"></a>3.7 泛型</h2><blockquote>
<p>泛型（<code>Generics</code>）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p>
</blockquote>
<h3 id="3-7-1-简单的例子"><a href="#3-7-1-简单的例子" class="headerlink" title="3.7.1 简单的例子"></a>3.7.1 简单的例子</h3><blockquote>
<p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray(length: number, value: any): Array&lt;any&gt; &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。</li>
<li>这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：<code>Array</code> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的<code>value</code> 的类型。</li>
</ul>
<blockquote>
<p>这时候，泛型就派上用场了：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray&lt;string&gt;(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，我们在函数名后添加了 &#96;&#96;，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code>和输出 <code>Array</code>中即可使用了</p>
</blockquote>
<p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="3-7-2-多个类型参数"><a href="#3-7-2-多个类型参数" class="headerlink" title="3.7.2 多个类型参数"></a>3.7.2 多个类型参数</h3><blockquote>
<p>定义泛型的时候，可以一次定义多个类型参数：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;</span><br><span class="line">    return [tuple[1], tuple[0]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([7, &#x27;seven&#x27;]); // [&#x27;seven&#x27;, 7]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组</p>
</blockquote>
<h3 id="3-7-3-泛型约束"><a href="#3-7-3-泛型约束" class="headerlink" title="3.7.3 泛型约束"></a>3.7.3 泛型约束</h3><blockquote>
<p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;T&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p>
</blockquote>
<blockquote>
<p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含<code>length</code> 属性的变量。这就是泛型约束</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，我们使用了 <code>extends</code>约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p>
</blockquote>
<blockquote>
<p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code>不包含 <code>length</code>，那么在编译阶段就会报错了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loggingIdentity(7);</span><br><span class="line"></span><br><span class="line">// index.ts(10,17): error TS2345: Argument of type &#x27;7&#x27; is not assignable to parameter of type &#x27;Lengthwise&#x27;.</span><br></pre></td></tr></table></figure>

<p><strong>多个类型参数之间也可以互相约束：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123;</span><br><span class="line">    for (let id in source) &#123;</span><br><span class="line">        target[id] = (&lt;T&gt;source)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;</span><br><span class="line"></span><br><span class="line">copyFields(x, &#123; b: 10, d: 20 &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，我们使用了两个类型参数，其中要求 <code>T</code> 继承 <code>U</code>，这样就保证了<code>U</code> 上不会出现 <code>T</code> 中不存在的字段</p>
</blockquote>
<h3 id="3-7-4-泛型接口"><a href="#3-7-4-泛型接口" class="headerlink" title="3.7.4 泛型接口"></a>3.7.4 泛型接口</h3><blockquote>
<p>可以使用接口的方式来定义一个函数需要符合的形状</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然也可以使用含有泛型的接口来定义函数的形状</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface CreateArrayFunc &#123;</span><br><span class="line">    &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let createArray: CreateArrayFunc;</span><br><span class="line">createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进一步，我们可以把泛型参数提前到接口名上</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface CreateArrayFunc&lt;T&gt; &#123;</span><br><span class="line">    (length: number, value: T): Array&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let createArray: CreateArrayFunc&lt;any&gt;;</span><br><span class="line">createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，此时在使用泛型接口的时候，需要定义泛型的类型</p>
</blockquote>
<h3 id="3-7-5-泛型类"><a href="#3-7-5-泛型类" class="headerlink" title="3.7.5 泛型类"></a>3.7.5 泛型类</h3><blockquote>
<p>与泛型接口类似，泛型也可以用于类的类型定义中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myGenericNumber = new GenericNumber&lt;number&gt;();</span><br><span class="line"></span><br><span class="line">myGenericNumber.zeroValue = 0;</span><br><span class="line">myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-6-泛型参数的默认类型"><a href="#3-7-6-泛型参数的默认类型" class="headerlink" title="3.7.6 泛型参数的默认类型"></a>3.7.6 泛型参数的默认类型</h3><blockquote>
<p>在 <code>TypeScript 2.3</code>以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-8-声明合并"><a href="#3-8-声明合并" class="headerlink" title="3.8 声明合并"></a>3.8 声明合并</h2><blockquote>
<p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型</p>
</blockquote>
<h3 id="3-8-1-函数的合并"><a href="#3-8-1-函数的合并" class="headerlink" title="3.8.1 函数的合并"></a>3.8.1 函数的合并</h3><blockquote>
<p>我们可以使用重载定义多个函数类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line"></span><br><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-2-接口的合并"><a href="#3-8-2-接口的合并" class="headerlink" title="3.8.2 接口的合并"></a>3.8.2 接口的合并</h3><blockquote>
<p>接口中的属性在合并时会简单的合并到一个接口中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相当于：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，合并的属性的类型必须是唯一的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;  // 虽然重复了，但是类型都是 `number`，所以不会报错</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: string;  // 类型不一致，会报错</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable &#x27;price&#x27; must be of type &#x27;number&#x27;, but here has type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>

<p><strong>接口中方法的合并，与函数的合并一样</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    alert(s: string): string;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    weight: number;</span><br><span class="line">    alert(s: string, n: number): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    weight: number;</span><br><span class="line">    alert(s: string): string;</span><br><span class="line">    alert(s: string, n: number): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-3-类的合并"><a href="#3-8-3-类的合并" class="headerlink" title="3.8.3 类的合并"></a>3.8.3 类的合并</h3><blockquote>
<p>类的合并与接口的合并规则一致</p>
</blockquote>
<h1 id="四、工程"><a href="#四、工程" class="headerlink" title="四、工程"></a>四、工程</h1><h2 id="4-1-tsconfig-json"><a href="#4-1-tsconfig-json" class="headerlink" title="4.1 tsconfig.json"></a>4.1 tsconfig.json</h2><p><strong>编译选项</strong></p>
<blockquote>
<p>你可以通过 <code>compilerOptions</code> 来定制你的编译选项</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    /* 基本选项 */</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br><span class="line">    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件</span><br><span class="line">    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件</span><br><span class="line">    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误</span><br><span class="line">    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br><span class="line">    &quot;declaration&quot;: true,                   // 生成相应的 &#x27;.d.ts&#x27; 文件</span><br><span class="line">    &quot;sourceMap&quot;: true,                     // 生成相应的 &#x27;.map&#x27; 文件</span><br><span class="line">    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件</span><br><span class="line">    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录</span><br><span class="line">    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.</span><br><span class="line">    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释</span><br><span class="line">    &quot;noEmit&quot;: true,                        // 不生成输出文件</span><br><span class="line">    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数</span><br><span class="line">    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><span class="line"></span><br><span class="line">    /* 严格的类型检查选项 */</span><br><span class="line">    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项</span><br><span class="line">    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错</span><br><span class="line">    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查</span><br><span class="line">    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误</span><br><span class="line">    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><span class="line"></span><br><span class="line">    /* 额外的检查 */</span><br><span class="line">    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误</span><br><span class="line">    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误</span><br><span class="line">    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误</span><br><span class="line">    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><span class="line"></span><br><span class="line">    /* 模块解析选项 */</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br><span class="line">    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录</span><br><span class="line">    &quot;paths&quot;: &#123;&#125;,                           // 模块名到基于 baseUrl 的路径映射的列表</span><br><span class="line">    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br><span class="line">    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表</span><br><span class="line">    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。</span><br><span class="line"></span><br><span class="line">    /* Source Map Options */</span><br><span class="line">    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br><span class="line">    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置</span><br><span class="line">    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br><span class="line">    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><span class="line"></span><br><span class="line">    /* 其他选项 */</span><br><span class="line">    &quot;experimentalDecorators&quot;: true,        // 启用装饰器</span><br><span class="line">    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-TypeScript-编译"><a href="#4-2-TypeScript-编译" class="headerlink" title="4.2 TypeScript 编译"></a>4.2 TypeScript 编译</h2><blockquote>
<p>运行 <code>tsc -p ./path-to-project-directory</code> 。<code>tsc -w</code>来启用 <code>TypeScript</code>编译器的观测模式，在检测到文件改动之后，它将重新编译</p>
</blockquote>
<p><strong>指定需要编译的文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;./some/file.ts&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 include 和 exclude 选项来指定需要包含的文件，和排除的文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;./folder&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;exclude&quot;: [</span><br><span class="line">    &quot;./folder/**/*.spec.ts&quot;,</span><br><span class="line">    &quot;./folder/someSubFolder&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、一些例子演示"><a href="#五、一些例子演示" class="headerlink" title="五、一些例子演示"></a>五、一些例子演示</h1><h2 id="5-1-定义ajax请求数据接口"><a href="#5-1-定义ajax请求数据接口" class="headerlink" title="5.1 定义ajax请求数据接口"></a>5.1 定义ajax请求数据接口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">interface Config&#123;</span><br><span class="line">    type:string;</span><br><span class="line">    url:string;</span><br><span class="line">    data?:string;</span><br><span class="line">    dataType:string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//原生js封装的ajax </span><br><span class="line">function ajax(config:Config)&#123;</span><br><span class="line"></span><br><span class="line">   var xhr=new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">   xhr.open(config.type,config.url,true);</span><br><span class="line"></span><br><span class="line">   xhr.send(config.data);</span><br><span class="line"></span><br><span class="line">   xhr.onreadystatechange=function()&#123;</span><br><span class="line"></span><br><span class="line">        if(xhr.readyState==4 &amp;&amp; xhr.status==200)&#123;</span><br><span class="line">            console.log(&#x27;chengong&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if(config.dataType==&#x27;json&#x27;)&#123;</span><br><span class="line"></span><br><span class="line">                console.log(JSON.parse(xhr.responseText));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                console.log(xhr.responseText)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">    type:&#x27;get&#x27;,</span><br><span class="line">    data:&#x27;name=zhangsan&#x27;,</span><br><span class="line">    url:&#x27;http://a.itying.com/api/productlist&#x27;, //api</span><br><span class="line">    dataType:&#x27;json&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-2-函数类型接口-对方法约束"><a href="#5-2-函数类型接口-对方法约束" class="headerlink" title="5.2 函数类型接口-对方法约束"></a>5.2 函数类型接口-对方法约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 函数类型接口:对方法传入的参数 以及返回值进行约束   批量约束</span><br><span class="line"></span><br><span class="line">// 加密的函数类型接口</span><br><span class="line"></span><br><span class="line">interface encrypt&#123;</span><br><span class="line">    (key:string,value:string):string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var md5:encrypt=function(key:string,value:string):string&#123;</span><br><span class="line">        //模拟操作</span><br><span class="line">        return key+value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(md5(&#x27;name&#x27;,&#x27;zhangsan&#x27;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var sha1:encrypt=function(key:string,value:string):string&#123;</span><br><span class="line"></span><br><span class="line">    //模拟操作</span><br><span class="line">    return key+&#x27;----&#x27;+value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sha1(&#x27;name&#x27;,&#x27;lisi&#x27;));</span><br></pre></td></tr></table></figure>

<h2 id="5-3-可索引接口：数组、对象的约束（不常用）"><a href="#5-3-可索引接口：数组、对象的约束（不常用）" class="headerlink" title="5.3 可索引接口：数组、对象的约束（不常用）"></a>5.3 可索引接口：数组、对象的约束（不常用）</h2><h3 id="5-3-1-可索引接口-对数组的约束"><a href="#5-3-1-可索引接口-对数组的约束" class="headerlink" title="5.3.1 可索引接口-对数组的约束"></a>5.3.1 可索引接口-对数组的约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface UserArr&#123;</span><br><span class="line">    [index:number]:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr:UserArr=[&#x27;aaa&#x27;,&#x27;bbb&#x27;];</span><br><span class="line"></span><br><span class="line">console.log(arr[0]);</span><br></pre></td></tr></table></figure>

<h3 id="5-3-2-可索引接口-对对象的约束"><a href="#5-3-2-可索引接口-对对象的约束" class="headerlink" title="5.3.2 可索引接口-对对象的约束"></a>5.3.2 可索引接口-对对象的约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface UserObj&#123;</span><br><span class="line">    [index:string]:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr:UserObj=&#123;name:&#x27;张三&#x27;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-3-类类型接口-对类的约束"><a href="#5-3-3-类类型接口-对类的约束" class="headerlink" title="5.3.3 类类型接口:对类的约束"></a>5.3.3 类类型接口:对类的约束</h3><ul>
<li>抽象类抽象有点相似</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    eat(str:string):void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog implements Animal&#123;</span><br><span class="line"></span><br><span class="line">    name:string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line"></span><br><span class="line">        this.name=name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;吃粮食&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var d=new Dog(&#x27;小黑&#x27;);</span><br><span class="line">d.eat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat implements Animal&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line"></span><br><span class="line">        this.name=name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    eat(food:string)&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;吃&#x27;+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c=new Cat(&#x27;小花&#x27;);</span><br><span class="line">c.eat(&#x27;老鼠&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="5-4-接口的扩展"><a href="#5-4-接口的扩展" class="headerlink" title="5.4 接口的扩展"></a>5.4 接口的扩展</h2><blockquote>
<p>接口继承接口 类实现接口</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    eat():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person extends Animal&#123;</span><br><span class="line"></span><br><span class="line">    work():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Programmer&#123;</span><br><span class="line"></span><br><span class="line">    public name:string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coding(code:string)&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+code)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Web extends Programmer implements Person&#123;</span><br><span class="line">    </span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">       super(name)</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;喜欢吃馒头&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    work()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;写代码&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var w=new Web(&#x27;小李&#x27;);</span><br><span class="line"></span><br><span class="line">// w.eat();</span><br><span class="line"></span><br><span class="line">w.coding(&#x27;写ts代码&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="5-5-泛型类接口"><a href="#5-5-泛型类接口" class="headerlink" title="5.5 泛型类接口"></a>5.5 泛型类接口</h2><h3 id="5-5-1-泛型类-泛型方法"><a href="#5-5-1-泛型类-泛型方法" class="headerlink" title="5.5.1 泛型类 泛型方法"></a>5.5.1 泛型类 泛型方法</h3><ul>
<li>泛型：软件工程中，我们不仅要创建一致的定义良好的<code>API</code>，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</li>
<li>在像<code>C#</code>和<code>Java</code>这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</li>
<li>通俗理解：泛型就是解决类接口方法的复用性、以及对不特定数据类型的支持(类型校验)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 只能返回string类型的数据</span><br><span class="line">function getData(value:string):string&#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同时返回 string类型 和number类型  （代码冗余）</span><br><span class="line">function getData1(value:string):string&#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">function getData2(value:number):number&#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">//同时返回 string类型 和number类型  any可以解决这个问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> function getData(value:any):any&#123;</span><br><span class="line">    return &#x27;哈哈哈&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData(123);</span><br><span class="line">getData(&#x27;str&#x27;);</span><br><span class="line">//any放弃了类型检查,传入什么 返回什么。比如:传入number 类型必须返回number类型  传入 string类型必须返回string类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//传入的参数类型和返回的参数类型可以不一致</span><br><span class="line">function getData(value:any):any&#123;</span><br><span class="line">  return &#x27;哈哈哈&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>T</code>表示泛型，具体什么类型是调用这个方法的时候决定的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// T表示泛型，具体什么类型是调用这个方法的时候决定的</span><br><span class="line"></span><br><span class="line">function getData&lt;T&gt;(value:T):T&#123;</span><br><span class="line">   return value;</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;number&gt;(123);</span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(&#x27;1214231&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData&lt;number&gt;(&#x27;2112&#x27;);       /*错误的写法*/</span><br><span class="line">function getData&lt;T&gt;(value:T):any&#123;</span><br><span class="line">   return &#x27;2145214214&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData&lt;number&gt;(123);  //参数必须是number</span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(&#x27;这是一个泛型&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>泛型类</strong></p>
<blockquote>
<p>泛型类：比如有个最小堆算法，需要同时支持返回数字和字符串 <code>a - z</code>两种类型。 通过类的泛型来实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 基本写法 但是不能传入字符串</span><br><span class="line">class MinClass&#123;</span><br><span class="line">    public list:number[]=[];</span><br><span class="line">    add(num:number)&#123;</span><br><span class="line">        this.list.push(num)</span><br><span class="line">    &#125;</span><br><span class="line">    min():number&#123;</span><br><span class="line">        var minNum=this.list[0];</span><br><span class="line">        for(var i=0;i&lt;this.list.length;i++)&#123;</span><br><span class="line">            if(minNum&gt;this.list[i])&#123;</span><br><span class="line">                minNum=this.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m=new MinClass();</span><br><span class="line"></span><br><span class="line">m.add(3);</span><br><span class="line">m.add(22);</span><br><span class="line">m.add(23);</span><br><span class="line">m.add(6);</span><br><span class="line"></span><br><span class="line">m.add(7);</span><br><span class="line">alert(m.min());</span><br></pre></td></tr></table></figure>

<p><strong>类的泛型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 通过泛型改写 可以同时传入number 字符串等</span><br><span class="line">//类的泛型</span><br><span class="line">class MinClas&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    public list:T[]=[];</span><br><span class="line"></span><br><span class="line">    add(value:T):void&#123;</span><br><span class="line"></span><br><span class="line">        this.list.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    min():T&#123;        </span><br><span class="line">        var minNum=this.list[0];</span><br><span class="line">        for(var i=0;i&lt;this.list.length;i++)&#123;</span><br><span class="line">            if(minNum&gt;this.list[i])&#123;</span><br><span class="line">                minNum=this.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m1=new MinClas&lt;number&gt;();   /*实例化类 并且制定了类的T代表的类型是number*/</span><br><span class="line">m1.add(11);</span><br><span class="line">m1.add(3);</span><br><span class="line">m1.add(2);</span><br><span class="line">alert(m1.min())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var m2=new MinClas&lt;string&gt;();   /*实例化类 并且制定了类的T代表的类型是string*/</span><br><span class="line"></span><br><span class="line">m2.add(&#x27;c&#x27;);</span><br><span class="line">m2.add(&#x27;a&#x27;);</span><br><span class="line">m2.add(&#x27;v&#x27;);</span><br><span class="line">alert(m2.min())</span><br></pre></td></tr></table></figure>

<h3 id="5-5-2-泛型接口"><a href="#5-5-2-泛型接口" class="headerlink" title="5.5.2 泛型接口"></a>5.5.2 泛型接口</h3><p><strong>1. 方式1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface ConfigFn&#123;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt;(value:T):T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var getData:ConfigFn=function&lt;T&gt;(value:T):T&#123;</span><br><span class="line"></span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(&#x27;张三&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// getData&lt;string&gt;(1243);  //错误</span><br></pre></td></tr></table></figure>

<p><strong>2. 方式2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface ConfigFn&lt;T&gt;&#123;</span><br><span class="line">    (value:T):T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getData&lt;T&gt;(value:T):T&#123;</span><br><span class="line"></span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var myGetData:ConfigFn&lt;string&gt;=getData;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myGetData(&#x27;20&#x27;);  /*正确*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// myGetData(20)  //错误</span><br></pre></td></tr></table></figure>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/08/23/html+css+js+ts/5-Typescript%E6%80%BB%E7%BB%93/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-Typescript实践总结[基础+工程+实践]">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/08/15/html+css+js+ts/5-Typescript%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%5B%E5%9F%BA%E7%A1%80+%E5%B7%A5%E7%A8%8B+%E5%AE%9E%E8%B7%B5%5D/">Typescript实践总结[基础+工程+实践]</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-08-15
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/typescript/" class="cube-excerpt-tag-link">#typescript</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="第一章-基础篇"><a href="#第一章-基础篇" class="headerlink" title="第一章 基础篇"></a>第一章 基础篇</h1><blockquote>
<p>TS基础篇</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/base-1.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-2.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-3.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-4.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-5.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-6.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-7.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-8.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-9.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-10.webp" alt="img"></p>
<h2 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h2><ul>
<li><code>JavaScript</code> 的类型分为两种：原始数据类型和对象类型。</li>
<li>原始数据类型包括：布尔值、数值、字符串、<code>null</code>、<code>undefined</code> 以及 ES6 中的新类型 <code>Symbol</code></li>
<li>本节主要介绍前五种原始数据类型在 <code>TypeScript</code> 中的应用。</li>
<li>布尔值是最基础的数据类型，在 <code>TypeScript</code> 中，使用 <code>boolean</code> 定义布尔值类型</li>
</ul>
<p><strong>ES6数据类型</strong></p>
<ul>
<li><code>Boolean</code></li>
<li><code>Number</code></li>
<li><code>String</code></li>
<li><code>Array</code></li>
<li><code>Function</code></li>
<li><code>Object</code></li>
<li><code>Symbol</code></li>
<li><code>undefined</code></li>
<li><code>null</code></li>
</ul>
<p><strong>Typescript数据类型</strong></p>
<ul>
<li><code>Boolean</code></li>
<li><code>Number</code></li>
<li><code>String</code></li>
<li><code>Array</code></li>
<li><code>Function</code></li>
<li><code>Object</code></li>
<li><code>Symbol</code></li>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>void</code></li>
<li><code>any</code></li>
<li><code>never</code></li>
<li>元组</li>
<li>枚举</li>
<li>高级类型</li>
</ul>
<p><strong>正确的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">➖➖➖➖➖➖➖➖➖布尔➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 布尔值</span><br><span class="line">let isDone: boolean = false;  </span><br><span class="line"></span><br><span class="line">// 事实上 `new Boolean()` 返回的是一个 `Boolean` 对象</span><br><span class="line">let createdByNewBoolean: Boolean = new Boolean(1);</span><br><span class="line"></span><br><span class="line">//(直接调用 `Boolean` 也可以返回一个 `boolean` 类型) </span><br><span class="line">let createdByBoolean: boolean = Boolean(1); </span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖数值➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 数值</span><br><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line"></span><br><span class="line">// ES6 中的二进制表示法</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line"></span><br><span class="line">// ES6 中的八进制表示法</span><br><span class="line">let octalLiteral: number = 0o744;</span><br><span class="line">let notANumber: number = NaN;</span><br><span class="line">let infinityNumber: number = Infinity;</span><br><span class="line">➖➖➖➖➖➖➖➖➖字符串➖➖➖➖➖➖➖➖➖</span><br><span class="line">let myName: string = &#x27;Tom&#x27;;</span><br><span class="line">➖➖➖➖➖➖➖➖➖空值➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 没有返回值的函数为void</span><br><span class="line">function alertName(): void &#123;</span><br><span class="line">    alert(&#x27;My name is Tom&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//声明一个 void 类型的只能将它赋值为 undefined 和 null</span><br><span class="line">let unusable: void = undefined;</span><br><span class="line">➖➖➖➖➖➖➖➖➖Null 和 Undefined➖➖➖➖➖➖➖➖➖</span><br><span class="line">// undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null</span><br><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure>

<p><strong>错误的写法</strong></p>
<blockquote>
<p>注意:正确的很好记,大多数人都会写正确的,关键是要记住这些错误的!!!</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➖➖➖➖➖➖➖➖➖布尔➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 注意，使用构造函数 `Boolean` 创造的对象不是布尔值</span><br><span class="line">let createdByNewBoolean: boolean = new Boolean(1);❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖数值➖➖➖➖➖➖➖➖➖</span><br><span class="line">let decLiteral: number = &quot;6&quot;;❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖字符串➖➖➖➖➖➖➖➖➖</span><br><span class="line">let myName: string = 999;❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖空值➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 没有返回值的函数为void</span><br><span class="line">function alertName(): void &#123;❌</span><br><span class="line">   return 666;</span><br><span class="line">&#125;</span><br><span class="line">//声明一个 void 类型的只能将它赋值为 undefined 和 null</span><br><span class="line">let unusable: void = &#x27;I love you&#x27;;❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖Null 和 Undefined➖➖➖➖➖➖➖➖➖</span><br><span class="line">// undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null</span><br><span class="line">let u: undefined = 888;❌</span><br><span class="line">let n: null = 999;❌</span><br></pre></td></tr></table></figure>

<h2 id="二、任意值"><a href="#二、任意值" class="headerlink" title="二、任意值"></a>二、任意值</h2><p><strong>正确的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 顾名思义,可以被任何值赋值</span><br><span class="line">let anyThing: any = &#x27;hello&#x27;;</span><br><span class="line">let anyThing: any = 888;</span><br><span class="line">let anyThing: any = true;</span><br><span class="line">let anyThing: any = null;</span><br><span class="line">let anyThing: any = undefined;</span><br><span class="line"></span><br><span class="line">// 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</span><br><span class="line">let any;</span><br><span class="line">any =true;</span><br></pre></td></tr></table></figure>

<h2 id="三、类型推论"><a href="#三、类型推论" class="headerlink" title="三、类型推论"></a>三、类型推论</h2><p><strong>正确的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</span><br><span class="line">let myFavoriteNumber = &#x27;seven&#x27;;  </span><br><span class="line">//等价于</span><br><span class="line">let myFavoriteNumber :string= &#x27;seven&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>错误的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 第一句已经被推论为String类型了</span><br><span class="line">let myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;❌</span><br></pre></td></tr></table></figure>

<h2 id="四、联合类型"><a href="#四、联合类型" class="headerlink" title="四、联合类型"></a>四、联合类型</h2><p><strong>正确的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 联合类型（Union Types）表示取值可以为多种类型中的一种。</span><br><span class="line">// 当你允许某个变量被赋值多种类型的时候,使用联合类型,管道符进行连接</span><br><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// 也可用于方法的参数定义, 都有toString方法,访问 string 和 number 的共有属性是没问题的</span><br><span class="line">function getString(something: string | number): string &#123;</span><br><span class="line">    return something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>错误的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// number类型没有length属性.所以编译错误,因为我们只能访问此联合类型的所有类型里共有的属性或方法：</span><br><span class="line">function getLength(something: string | number): number &#123;❌</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、对象的类型——接口"><a href="#五、对象的类型——接口" class="headerlink" title="五、对象的类型——接口"></a>五、对象的类型——接口</h2><p><strong>正确的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// 赋值的时候，变量的形状必须和接口的形状保持一致(不能多也不能少,类型还必须一致)</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IUserInfo&#123;</span><br><span class="line">  age : any;//定义一个任何变量的 age.</span><br><span class="line">  userName :string;//定义一个 username.</span><br><span class="line">&#125;</span><br><span class="line">function getUserInfo(user : IUserInfo):string&#123;</span><br><span class="line">    return user.age+&quot;======&quot;+user.userName; 	</span><br><span class="line">&#125;</span><br><span class="line">  ➖➖➖➖➖➖➖➖➖可选属性➖➖➖➖➖➖➖➖➖</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number; // 表示这个属性可有可无</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">// 可索引签名</span><br><span class="line">interface StringArrary &#123;</span><br><span class="line">  [index]: string // 数字索引。通过数字索引，返回string类型</span><br><span class="line">  [string]: string // 字符串索引签名。两者不能混用，一起使用的前提是数字索引是字符串索引的子集</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myArr: StringArrary</span><br><span class="line">myArr = [&#x27;test1&#x27;,&#x27;test2&#x27;]</span><br><span class="line">let myString = myArr[0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ➖➖➖➖➖➖➖➖➖任意属性➖➖➖➖➖➖➖➖➖</span><br><span class="line"></span><br><span class="line">//希望一个接口允许有任意的属性，可以使用如下方式：旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27; // 可以加其他的属性</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖只读属性➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number; // </span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    id: 89757, // 只读</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>错误的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;❌</span><br><span class="line">&#125;;</span><br><span class="line">上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖只读属性➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 89757; // 不能被二次赋值❌</span><br></pre></td></tr></table></figure>

<p><strong>数组只读属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myARr:readonlyArrary&lt;number&gt; = [1,2,3]</span><br></pre></td></tr></table></figure>

<h2 id="六、数组的类型"><a href="#六、数组的类型" class="headerlink" title="六、数组的类型"></a>六、数组的类型</h2><p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br><span class="line">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖用接口表示数组➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index: number]: number;</span><br><span class="line">&#125;</span><br><span class="line">let fibonacci: NumberArray = [1, 1, 2, 3, 5];</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖any 在数组中的应用➖➖➖➖➖➖➖➖➖</span><br><span class="line">let list: any[] = [&#x27;Xcat Liu&#x27;, 25, &#123; website: &#x27;http://xcatliu.com&#x27; &#125;];</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖类数组➖➖➖➖➖➖➖➖➖</span><br><span class="line">function sum() &#123;</span><br><span class="line">    let args: IArguments = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>错误的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 数组的项中不允许出现其他的类型：</span><br><span class="line">let fibonacci: number[] = [1, &#x27;1&#x27;, 2, 3, 5];❌</span><br><span class="line"></span><br><span class="line">// push 方法只允许传入 number 类型的参数，但是却传了一个 string 类型的参数，所以报错了。</span><br><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br><span class="line">fibonacci.push(&#x27;8&#x27;);❌</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 类数组（Array-like Object）不是数组类型，比如 arguments</span><br><span class="line">function sum() &#123;❌</span><br><span class="line">    let args: number[] = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、函数的类型"><a href="#七、函数的类型" class="headerlink" title="七、函数的类型"></a>七、函数的类型</h2><p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 需要把输入和输出都考虑到</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖函数表达式➖➖➖➖➖➖➖➖➖</span><br><span class="line">let mySum = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line">// 不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;</span><br><span class="line">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line">➖➖➖➖➖➖➖➖➖接口定义函数的形状➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source, subString) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖可选参数➖➖➖➖➖➖➖➖➖</span><br><span class="line">function buildName(firstName: string, lastName?: string) &#123;</span><br><span class="line">    if (lastName) &#123;</span><br><span class="line">        return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(&#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖参数默认值➖➖➖➖➖➖➖➖➖</span><br><span class="line">function buildName(firstName: string, lastName: string = &#x27;Cat&#x27;) &#123;</span><br><span class="line">    return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖剩余参数➖➖➖➖➖➖➖➖➖</span><br><span class="line">// rest 参数只能是最后一个参数，关于 rest 参数,是一个数组</span><br><span class="line">function push(array: any[], ...items: any[]) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></table></figure>

<p><strong>错误的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 输入多余的（或者少于要求的）参数，是不被允许的：</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1, 2, 3); ❌</span><br><span class="line">sum(1);❌</span><br><span class="line"></span><br><span class="line">// 输入多余的（或者少于要求的）参数，是不被允许的：</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1, 2, 3);</span><br><span class="line"></span><br><span class="line">// 可选参数后面不允许再出现必须参数了：</span><br><span class="line">function buildName(firstName?: string, lastName: string) &#123;❌</span><br><span class="line">    if (firstName) &#123;</span><br><span class="line">        return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(undefined, &#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="7-1-函数相关知识点梳理"><a href="#7-1-函数相关知识点梳理" class="headerlink" title="7.1 函数相关知识点梳理"></a>7.1 函数相关知识点梳理</h3><p><strong>四种声明方式：</strong></p>
<ul>
<li>通过<code>function</code></li>
<li>通过变量</li>
<li>通过接口</li>
<li>通过类型别名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数定义</span><br><span class="line">function add1(x: number, y: number) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过变量</span><br><span class="line">let add2: (x: number, y: number) =&gt; number</span><br><span class="line"></span><br><span class="line">// 通过类型别名</span><br><span class="line">let add3 = (x: number, y: number) =&gt; number</span><br><span class="line"></span><br><span class="line">// 通过类型别名</span><br><span class="line">interface add4 &#123;</span><br><span class="line">    (x: number, y: number): number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用interface定义函数和用type定义函数有区别?</strong></p>
<ul>
<li><code>type</code>：不是创建新的类型，只是为一个给定的类型起一个名字。<code>type</code>还可以进行联合、交叉等操作，引用起来更简洁</li>
<li><code>interface</code>：创建新的类型，接口之间还可以继承、声明合并</li>
<li>如果可能，建议优先使用 <code>interface</code>。</li>
<li>混合接口一般是为第三方类库写声明文件时会用到，很多类库名称可以直接当函数调用，也可以有些属性和方法。例子可以看一下<code>@types/jest/index.d.ts</code> 里面有一些混合接口。</li>
<li>用混合接口声明函数和用接口声明类的区别是，接口不能声明类的构造函数（既不带名称的函数），但混合接口可以，其他都一样。</li>
</ul>
<p><strong>函数重载</strong></p>
<p>函数名相同，返回类型不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add8(...rest: number[]): number;</span><br><span class="line">function add8(...rest: string[]): string;</span><br><span class="line">function add8(...rest: any[]): any &#123;</span><br><span class="line">    let first = rest[0];</span><br><span class="line">    if(typeof first === &#x27;string&#x27;) &#123;</span><br><span class="line">        return rest.join(&#x27;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof first === &#x27;number&#x27;) &#123;</span><br><span class="line">        return rest.reduce((pre, cur) =&gt; pre + cur)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、类型断言"><a href="#八、类型断言" class="headerlink" title="八、类型断言"></a>八、类型断言</h2><ul>
<li>有时候你会遇到这样的情况，你会比 <code>TypeScript</code> 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</li>
<li>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 <code>TypeScript</code> 会假设你，程序员，已经进行了必须的检查。</li>
</ul>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &#x27;this is a string&#x27;</span><br><span class="line"></span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另一个为 <code>as</code> 语法：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &#x27;this is a string&#x27;</span><br><span class="line"></span><br><span class="line">let strLength: number = (someValue as string).length</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 <code>TypeScript</code> 里使用 <code>JSX</code>时，只有<code>as</code> 语法断言是被允许</p>
</blockquote>
<p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 可以使用类型断言，将 something 断言成 string</span><br><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if ((&lt;string&gt;something).length) &#123;</span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>错误的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 只能访问此联合类型的所有类型里共有的属性或方法</span><br><span class="line">function getLength(something: string | number): number &#123; ❌</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、类型别名"><a href="#九、类型别名" class="headerlink" title="九、类型别名"></a>九、类型别名</h2><p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用 type 创建类型别名,类型别名常用于联合类型</span><br><span class="line">type Name = string;</span><br><span class="line">type NameResolver = () =&gt; string;</span><br><span class="line">type NameOrResolver = Name | NameResolver;</span><br><span class="line">function getName(n: NameOrResolver): Name &#123;</span><br><span class="line">    if (typeof n === &#x27;string&#x27;) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十、枚举"><a href="#十、枚举" class="headerlink" title="十、枚举"></a>十、枚举</h2><p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天	</span><br><span class="line">// 枚举就是枚举值到枚举名进行反向映射</span><br><span class="line"></span><br><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line">console.log(Days[&quot;Sun&quot;]); // 0</span><br><span class="line">console.log(Days[0]); // &#x27;Sun&#x27;</span><br><span class="line"></span><br><span class="line">enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line">console.log(Days[&quot;Sun&quot;]); // 7</span><br></pre></td></tr></table></figure>

<h2 id="十一、类"><a href="#十一、类" class="headerlink" title="十一、类"></a>十一、类</h2><p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">➖➖➖➖➖➖➖➖➖类➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `My name is $&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.sayHi()); // My name is Jack</span><br><span class="line">➖➖➖➖➖➖➖➖➖继承➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        super(name); // 调用父类的 constructor(name)</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return &#x27;Meow, &#x27; + super.sayHi(); // 调用父类的 sayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = new Cat(&#x27;Tom&#x27;); // Tom</span><br><span class="line">console.log(c.sayHi()); // Meow, My name is Tom</span><br><span class="line">➖➖➖➖➖➖➖➖➖存储器➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    get name() &#123;</span><br><span class="line">        return &#x27;Jack&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    set name(value) &#123;</span><br><span class="line">        console.log(&#x27;setter: &#x27; + value);</span><br><span class="line">        this.name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Kitty&#x27;); // setter: Kitty</span><br><span class="line">a.name = &#x27;Tom&#x27;; // setter: Tom</span><br><span class="line">console.log(a.name); // Jack</span><br><span class="line">➖➖➖➖➖➖➖➖➖静态方法➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Animal &#123;</span><br><span class="line">    static isAnimal(a) &#123;</span><br><span class="line">        return a instanceof Animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">Animal.isAnimal(a); // true</span><br><span class="line">// 只能通过类名调用</span><br><span class="line">a.isAnimal(a); // TypeError: a.isAnimal is not a function ❌</span><br><span class="line">➖➖➖➖➖➖➖➖➖抽象类➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 只能被继承，不能被实例化</span><br><span class="line">abstract class Animal &#123;</span><br><span class="line">  eat()&#123;</span><br><span class="line">    console.log(&#x27;eat&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  abstract sleep(): void</span><br><span class="line">&#125;</span><br><span class="line">// 子类必须实现抽象类的抽象方法</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super()</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    name: string;</span><br><span class="line">    run() &#123;&#125;</span><br><span class="line">    sleep() &#123;</span><br><span class="line">        console.log(&#x27;dog sleep&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dog = new Dog(&#x27;wang&#x27;)</span><br><span class="line">dog.eat()</span><br></pre></td></tr></table></figure>

<h3 id="11-1类与接口的关系"><a href="#11-1类与接口的关系" class="headerlink" title="11.1类与接口的关系"></a>11.1类与接口的关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface Human &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    eat(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现接口中声明的属性</span><br><span class="line">class Person implements Human &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    name: string;</span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 接口可以像类一样实现继承</span><br><span class="line">interface Man extends Human &#123;</span><br><span class="line">    run(): voild</span><br><span class="line">&#125;</span><br><span class="line">interface Child &#123;</span><br><span class="line">    cry(): voild</span><br><span class="line">&#125;</span><br><span class="line">interface Boy extends Man,Child &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 添加被继承过来的属性</span><br><span class="line">let body: Boy = &#123;</span><br><span class="line">    name: &#x27;xx&#x27;,</span><br><span class="line">    run() &#123;&#125;,</span><br><span class="line">    eat() &#123;&#125;,</span><br><span class="line">    cry() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十二、public-private-和-protected"><a href="#十二、public-private-和-protected" class="headerlink" title="十二、public private 和 protected"></a>十二、public private 和 protected</h2><ul>
<li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li>
<li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li>
</ul>
<h2 id="十三、泛型"><a href="#十三、泛型" class="headerlink" title="十三、泛型"></a>十三、泛型</h2><blockquote>
<p>更多详情 <a target="_blank" rel="noopener" href="http://blog.poetries.top/ts-axios/chapter2/generic.html">http://blog.poetries.top/ts-axios/chapter2/generic.html</a></p>
</blockquote>
<blockquote>
<p>泛型就是解决 类 接口 方法的复用性、以及对不特定数据类型的支持。<strong>泛型理解为代表类型的参数，只是另一个维度的参数</strong></p>
</blockquote>
<p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//只能返回string类型的数据</span><br><span class="line">function getData(value:string):string&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同时返回 string类型 和number类型  （代码冗余）</span><br><span class="line">function getData1(value:string):string&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line">function getData2(value:number):number&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;使用泛型后就可以解决这个问题</span><br><span class="line">// T表示泛型，具体什么类型是调用这个方法的时候决定的</span><br><span class="line">// 表示参数是什么类型就返回什么类型~~~</span><br><span class="line">function getData&lt;T&gt;(value:T):T&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;number&gt;(123);</span><br><span class="line">getData&lt;string&gt;(&#x27;1214231&#x27;);</span><br><span class="line"></span><br><span class="line">// 定义接口</span><br><span class="line">interface ConfigFn&#123;</span><br><span class="line">    &lt;T&gt;(value:T):T;</span><br><span class="line">&#125;</span><br><span class="line">var getData:ConfigFn=function&lt;T&gt;(value:T):T&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;string&gt;(&#x27;张三&#x27;);</span><br><span class="line">getData&lt;string&gt;(1243);  //错误</span><br></pre></td></tr></table></figure>

<h3 id="13-1-泛型函数和接口"><a href="#13-1-泛型函数和接口" class="headerlink" title="13.1 泛型函数和接口"></a>13.1 泛型函数和接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 这两个等价的，使用时无需指定类型</span><br><span class="line">type Log = &lt;T&gt;(value: T) =&gt; T;</span><br><span class="line"></span><br><span class="line">// 只约束改成员</span><br><span class="line">interface Log &#123;</span><br><span class="line">  &lt;T&gt;(value: T):T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这两个等价的，使用时必须指定类型</span><br><span class="line">type Log&lt;T&gt; = (value: T) =&gt; T;</span><br><span class="line"></span><br><span class="line">// 约束接口的所有成员</span><br><span class="line">interface Log&lt;T&gt; &#123;</span><br><span class="line">  (value: T):T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-2-泛型类与泛型约束"><a href="#13-2-泛型类与泛型约束" class="headerlink" title="13.2 泛型类与泛型约束"></a>13.2 泛型类与泛型约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 把泛型放到类的后面，就可以约束所有成员</span><br><span class="line">class Log&lt;T&gt; &#123;</span><br><span class="line">    run(value: T) &#123;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line">    // 不能约束静态成员</span><br><span class="line">   // static eat() // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化类 传入类型</span><br><span class="line">let log1 = new Log&lt;number&gt;()</span><br><span class="line">log1.run(1)</span><br><span class="line"></span><br><span class="line">// 不指定类型参数传任意都允许</span><br><span class="line">let log2 = new Log()</span><br><span class="line">log2.run(&#x27;1&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>类型约束</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Length &#123;</span><br><span class="line">    length: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// T继承了接口 约束了不是任意类型都可传。传入的参数必须有length属性</span><br><span class="line">function log&lt;T extends Length&gt;(value: T): T &#123;</span><br><span class="line">    console.log(value, value.length)</span><br><span class="line">    return value</span><br><span class="line">&#125;</span><br><span class="line">// 如数组、字符串、对象都有length属性</span><br><span class="line">log([1])</span><br><span class="line">log(&#x27;1&#x27;)</span><br><span class="line">log(&#123;a:1&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>函数和类可以轻松支持多种类型，增强程序的扩展性</li>
<li>不必写多条函数重载</li>
<li>灵活控制类型之间的约束</li>
</ul>
<p><strong>对象属性约束</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 泛型约束对象中的属性</span><br><span class="line">function getProp&lt;T,K extends keyof T&gt;(obj:T,key: K) &#123;</span><br><span class="line">    return obj[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十四、类型检查机制"><a href="#十四、类型检查机制" class="headerlink" title="十四、类型检查机制"></a>十四、类型检查机制</h2><h3 id="14-1-类型检查机制"><a href="#14-1-类型检查机制" class="headerlink" title="14.1 类型检查机制"></a>14.1 类型检查机制</h3><blockquote>
<p>编译器在做类型检查时，秉承的一些原则，表现出的一些行为</p>
</blockquote>
<p>作用：辅助开发，提高开发效率</p>
<ul>
<li>类型推断</li>
<li>类型兼容性</li>
<li>类型保护</li>
</ul>
<blockquote>
<p>所谓类型推断：不需要指定变量的类型（函数的返回值类型），TS可以根据某些规则自动的为其推断出一个类型</p>
</blockquote>
<ul>
<li>基础类型推断</li>
<li>最佳通用类型推断</li>
<li>上下文类型推断</li>
</ul>
<blockquote>
<p>基础类型推断，从右向左。但是有些是从左向右推断</p>
</blockquote>
<p>如事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ts 根据onkeydown推断出类型</span><br><span class="line">window.onkeydown = event=&gt;&#123;</span><br><span class="line">    console.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过类型断言阻断TS的类型推断</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">    bar: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//let foo = &#123;&#125; as Foo</span><br><span class="line">//foo.bar = 1</span><br><span class="line"></span><br><span class="line">let foo: Foo = &#123;</span><br><span class="line">    bar: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-2-类型保护机制"><a href="#14-2-类型保护机制" class="headerlink" title="14.2 类型保护机制"></a>14.2 类型保护机制</h3><blockquote>
<p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 Fish 或者是 Bird 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员</p>
</blockquote>
<p><strong>不同的判断方法有不同的使用场景：</strong></p>
<ul>
<li><code>typeof</code>：判断一个变量的类型</li>
<li><code>instanceof</code>：判断一个实例是否属于某个类</li>
<li><code>in</code>：判断一个属性是否属于某个对象</li>
<li>类型保护函数：某些判断可能不是一条语句能够搞定的，需要更多复杂的逻辑，适合封装到一个函数内</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function getLanguage(type: Type) &#123;</span><br><span class="line">    let lang = type === type.Strong ? new Java(): new Javascript()</span><br><span class="line">    </span><br><span class="line">    // 类型保护instanceof</span><br><span class="line">    if(lang instanceof Java)&#123;</span><br><span class="line">        lang.hellJava()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        lang.hellJavaScript()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // in</span><br><span class="line">    if(&#x27;java&#x27; in lang) &#123;</span><br><span class="line">        lang.hellJava()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        lang.hellJavaScript()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 类型保护函数方式</span><br><span class="line">    if(isJava(lang)) &#123;</span><br><span class="line">        lang.hellJava()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        lang.hellJavaScript()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一种类型保护函数</span><br><span class="line">function isJava(lang: Java | Javascript): lang is Java &#123;</span><br><span class="line">    // 类型断言</span><br><span class="line">    return (lang as Java).lang.helloJava !== undefined</span><br><span class="line">&#125;</span><br><span class="line">let pet = getSmallPet()</span><br><span class="line"></span><br><span class="line">// 每一个成员访问都会报错</span><br><span class="line">if (pet.swim) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125; else if (pet.fly) &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让这段代码工作，我们要使用类型断言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let pet = getSmallPet()</span><br><span class="line"></span><br><span class="line">if ((pet as Fish).swim) &#123;</span><br><span class="line">  (pet as Fish).swim()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  (pet as Bird).fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-2-1-用户自定义的类型保护"><a href="#14-2-1-用户自定义的类型保护" class="headerlink" title="14.2.1 用户自定义的类型保护"></a>14.2.1 用户自定义的类型保护</h4><ul>
<li>这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</li>
<li><code>TypeScript</code> 里的类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个类型谓词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isFish(pet: Fish | Bird): pet is Fish &#123;</span><br><span class="line">  return (pet as Fish).swim !== undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code>必须是来自于当前函数签名里的一个参数名。</li>
<li>每当使用一些变量调用 <code>isFish</code> 时，TypeScript 会将变量缩减为那个具体的类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (isFish(pet)) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 TypeScript 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在<code>else</code> 分支里，一定不是 <code>Fish</code>类型而是 <code>Bird</code> 类型</p>
</blockquote>
<h4 id="14-2-2-typeof-类型保护"><a href="#14-2-2-typeof-类型保护" class="headerlink" title="14.2.2 typeof 类型保护"></a>14.2.2 typeof 类型保护</h4><p>我们可以像下面这样利用类型断言来写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function isNumber (x: any):x is string &#123;</span><br><span class="line">  return typeof x === &#x27;number&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isString (x: any): x is string &#123;</span><br><span class="line">  return typeof x === &#x27;string&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function padLeft (value: string, padding: string | number) &#123;</span><br><span class="line">  if (isNumber(padding)) &#123;</span><br><span class="line">    return Array(padding + 1).join(&#x27; &#x27;) + value</span><br><span class="line">  &#125;</span><br><span class="line">  if (isString(padding)) &#123;</span><br><span class="line">    return padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 <code>typeof x === &#39;number&#39;</code>抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function padLeft (value: string, padding: string | number) &#123;</span><br><span class="line">  if (typeof padding === &#x27;number&#x27;) &#123;</span><br><span class="line">    return Array(padding + 1).join(&#x27; &#x27;) + value</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof padding === &#x27;string&#x27;) &#123;</span><br><span class="line">    return padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这些 <code>typeof</code> 类型保护只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code>必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>，<code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。</p>
</blockquote>
<h4 id="14-2-3-instanceof-类型保护"><a href="#14-2-3-instanceof-类型保护" class="headerlink" title="14.2.3 instanceof 类型保护"></a>14.2.3 instanceof 类型保护</h4><ul>
<li>如果你已经阅读了 <code>typeof</code> 类型保护并且对 JavaScript 里的 <code>instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</li>
<li><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Bird &#123;</span><br><span class="line">  fly () &#123;</span><br><span class="line">    console.log(&#x27;bird fly&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  layEggs () &#123;</span><br><span class="line">    console.log(&#x27;bird lay eggs&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fish &#123;</span><br><span class="line">  swim () &#123;</span><br><span class="line">    console.log(&#x27;fish swim&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  layEggs () &#123;</span><br><span class="line">    console.log(&#x27;fish lay eggs&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getRandomPet () &#123;</span><br><span class="line">  return Math.random() &gt; 0.5 ? new Bird() : new Fish()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let pet = getRandomPet()</span><br><span class="line"></span><br><span class="line">if (pet instanceof Bird) &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br><span class="line">if (pet instanceof Fish) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十五、高级类型"><a href="#十五、高级类型" class="headerlink" title="十五、高级类型"></a>十五、高级类型</h2><h3 id="15-1-交叉类型（取并集）"><a href="#15-1-交叉类型（取并集）" class="headerlink" title="15.1 交叉类型（取并集）"></a>15.1 交叉类型（取并集）</h3><blockquote>
<p>交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Loggable</code>。就是说这个类型的对象同时拥有了这两种类型的成员。</p>
</blockquote>
<blockquote>
<p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript里发生这种情况的场合很多！）下面是如何创建混入的一个简单例子</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">function extend&lt;T, U&gt; (first: T, second: U): T &amp; U &#123;</span><br><span class="line">  let result = &#123;&#125; as T &amp; U</span><br><span class="line">  for (let id in first) &#123;</span><br><span class="line">    result[id] = first[id] as any</span><br><span class="line">  &#125;</span><br><span class="line">  for (let id in second) &#123;</span><br><span class="line">    if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      result[id] = second[id] as any</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  constructor (public name: string) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Loggable &#123;</span><br><span class="line">  log (): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConsoleLogger implements Loggable &#123;</span><br><span class="line">  log () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var jim = extend(new Person(&#x27;Jim&#x27;), new ConsoleLogger())</span><br><span class="line">var n = jim.name</span><br><span class="line">jim.log()</span><br><span class="line">interface DogInterface &#123;</span><br><span class="line">    run(): void</span><br><span class="line">&#125;</span><br><span class="line">interface CatInterface &#123;</span><br><span class="line">    jump(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// pet 具备两个接口的所有方法</span><br><span class="line">let pet: DogInterface &amp; CatInterface = &#123;</span><br><span class="line">    run() &#123;&#125;,</span><br><span class="line">    jump() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 联合类型</span><br><span class="line">let a: number | string = 1</span><br><span class="line">let b: &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; // 字面量联合类型</span><br><span class="line">let c: 1 | 2 | 3 // 数字联合类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog implements DogInterface &#123;</span><br><span class="line">    run() &#123;&#125;</span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat  implements CatInterface &#123;</span><br><span class="line">    jump() &#123;&#125;</span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">enum Master &#123; Boy, Girl &#125;</span><br><span class="line">function getPet(master: Master) &#123;</span><br><span class="line">    let pet = master === Master.Boy ? new Dog() : new Cat();</span><br><span class="line">    // pet.run()</span><br><span class="line">    // pet.jump()</span><br><span class="line">    pet.eat()</span><br><span class="line">    return pet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square &#123;</span><br><span class="line">    kind: &quot;square&quot;;</span><br><span class="line">    size: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Rectangle &#123;</span><br><span class="line">    kind: &quot;rectangle&quot;;</span><br><span class="line">    width: number;</span><br><span class="line">    height: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Circle &#123;</span><br><span class="line">    kind: &quot;circle&quot;;</span><br><span class="line">    radius: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Shape = Square | Rectangle | Circle</span><br><span class="line"></span><br><span class="line">function area(s: Shape) &#123;</span><br><span class="line">    switch (s.kind) &#123;</span><br><span class="line">        case &quot;square&quot;:</span><br><span class="line">            return s.size * s.size;</span><br><span class="line">        case &quot;rectangle&quot;:</span><br><span class="line">            return s.height * s.width;</span><br><span class="line">        case &#x27;circle&#x27;:</span><br><span class="line">            return Math.PI * s.radius ** 2</span><br><span class="line">        default:</span><br><span class="line">            return ((e: never) =&gt; &#123;throw new Error(e)&#125;)(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(area(&#123;kind: &#x27;circle&#x27;, radius: 1&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="15-2-索引类型"><a href="#15-2-索引类型" class="headerlink" title="15.2 索引类型"></a>15.2 索引类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// function getValues(obj: any, keys: string[]) &#123;</span><br><span class="line">//     return keys.map(key =&gt; obj[key])</span><br><span class="line">// &#125;</span><br><span class="line">function getValues&lt;T, K extends keyof T&gt;(obj: T, keys: K[]): T[K][] &#123;</span><br><span class="line">    return keys.map(key =&gt; obj[key])</span><br><span class="line">&#125;</span><br><span class="line">console.log(getValues(obj, [&#x27;a&#x27;, &#x27;b&#x27;]))</span><br><span class="line">// console.log(getValues(obj, [&#x27;d&#x27;, &#x27;e&#x27;]))</span><br><span class="line"></span><br><span class="line">// keyof T</span><br><span class="line">interface Obj &#123;</span><br><span class="line">    a: number;</span><br><span class="line">    b: string;</span><br><span class="line">&#125;</span><br><span class="line">let key: keyof Obj</span><br><span class="line"></span><br><span class="line">// T[K]</span><br><span class="line">let value: Obj[&#x27;a&#x27;]</span><br><span class="line"></span><br><span class="line">// T extends U</span><br></pre></td></tr></table></figure>

<h3 id="15-3-映射类型"><a href="#15-3-映射类型" class="headerlink" title="15.3 映射类型"></a>15.3 映射类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Obj &#123;</span><br><span class="line">    a: string;</span><br><span class="line">    b: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使得每个成员属性变为只读</span><br><span class="line">type ReadonlyObj = Readonly&lt;Obj&gt;</span><br><span class="line"></span><br><span class="line">// 把一个接口属性变为可选</span><br><span class="line">type PartialObj = Partial&lt;Obj&gt;</span><br><span class="line"></span><br><span class="line">// 抽取obj的子集</span><br><span class="line">type PickObj = Pick&lt;Obj, &#x27;a&#x27; | &#x27;b&#x27;&gt;</span><br><span class="line"></span><br><span class="line">type RecordObj = Record&lt;&#x27;x&#x27; | &#x27;y&#x27;, Obj&gt;</span><br></pre></td></tr></table></figure>

<h3 id="15-4-条件类型"><a href="#15-4-条件类型" class="headerlink" title="15.4 条件类型"></a>15.4 条件类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// T extends U ? X : Y</span><br><span class="line"></span><br><span class="line">type TypeName&lt;T&gt; =</span><br><span class="line">    T extends string ? &quot;string&quot; :</span><br><span class="line">    T extends number ? &quot;number&quot; :</span><br><span class="line">    T extends boolean ? &quot;boolean&quot; :</span><br><span class="line">    T extends undefined ? &quot;undefined&quot; :</span><br><span class="line">    T extends Function ? &quot;function&quot; :</span><br><span class="line">    &quot;object&quot;;</span><br><span class="line">type T1 = TypeName&lt;string&gt;</span><br><span class="line">type T2 = TypeName&lt;string[]&gt;</span><br><span class="line"></span><br><span class="line">// (A | B) extends U ? X : Y</span><br><span class="line">// (A extends U ? X : Y) | (B extends U ? X : Y)</span><br><span class="line">type T3 = TypeName&lt;string | string[]&gt;</span><br><span class="line"></span><br><span class="line">type Diff&lt;T, U&gt; = T extends U ? never : T</span><br><span class="line">type T4 = Diff&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;</span><br><span class="line">// Diff&lt;&quot;a&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;b&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;</span><br><span class="line">// never | &quot;b&quot; | &quot;c&quot;</span><br><span class="line">// &quot;b&quot; | &quot;c&quot;</span><br><span class="line"></span><br><span class="line">type NotNull&lt;T&gt; = Diff&lt;T, null | undefined&gt;</span><br><span class="line">type T5 = NotNull&lt;string | number | undefined | null&gt;</span><br><span class="line"></span><br><span class="line">// Exclude&lt;T, U&gt;</span><br><span class="line">// NonNullable&lt;T&gt;</span><br><span class="line"></span><br><span class="line">// Extract&lt;T, U&gt;</span><br><span class="line">type T6 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;</span><br><span class="line"></span><br><span class="line">// ReturnType&lt;T&gt;</span><br><span class="line">type T8 = ReturnType&lt;() =&gt; string&gt;</span><br></pre></td></tr></table></figure>

<h3 id="15-5-联合类型"><a href="#15-5-联合类型" class="headerlink" title="15.5 联合类型"></a>15.5 联合类型</h3><blockquote>
<p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。 例如下面的函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function padLeft(value: string, padding: any) &#123;</span><br><span class="line">  if (typeof padding === &#x27;number&#x27;) &#123;</span><br><span class="line">    return Array(padding + 1).join(&#x27; &#x27;) + value</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof padding === &#x27;string&#x27;) &#123;</span><br><span class="line">    return padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">padLeft(&#x27;Hello world&#x27;, 4) // returns &quot;    Hello world&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>padLeft 存在一个问题，padding 参数的类型指定成了 any。 这就是说我们可以传入一个既不是 number 也不是 string 类型的参数，但是 TypeScript 却不报错</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let indentedString = padLeft(&#x27;Hello world&#x27;, true) // 编译阶段通过，运行时报错</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了解决这个问题，我们可以使用 联合类型做为 <code>padding</code> 的参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function padLeft(value: string, padding: string | number) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let indentedString = padLeft(&#x27;Hello world&#x27;, true) // 编译阶段报错</span><br></pre></td></tr></table></figure>

<ul>
<li>联合类型表示一个值可以是几种类型之一。我们用竖线（<code>|</code>）分隔每个类型，所以 <code>number | string</code> 表示一个值可以是 <code>number</code>或<code>string</code>。</li>
</ul>
<blockquote>
<p>如果一个值是联合类型，<strong>我们只能访问此联合类型的所有类型里共有的成员</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">  fly()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Fish &#123;</span><br><span class="line">  swim()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getSmallPet(): Fish | Bird &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let pet = getSmallPet()</span><br><span class="line">pet.layEggs() // okay</span><br><span class="line">pet.swim()    // error</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，Fish 具有一个 <code>swim</code> 方法，我们不能确定一个 <code>Bird | Fish</code>类型的变量是否有 <code>swim</code>方法。 如果变量在运行时是 Bird 类型，那么调用 <code>pet.swim()</code>就出错了</p>
</blockquote>
<h2 id="十六、初学者的困惑"><a href="#十六、初学者的困惑" class="headerlink" title="十六、初学者的困惑"></a>十六、初学者的困惑</h2><h3 id="16-1-如何优雅的声明类型"><a href="#16-1-如何优雅的声明类型" class="headerlink" title="16.1 如何优雅的声明类型"></a>16.1 如何优雅的声明类型</h3><h4 id="16-1-1-基础"><a href="#16-1-1-基础" class="headerlink" title="16.1.1 基础"></a>16.1.1 基础</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Basic &#123;</span><br><span class="line">  num: number;</span><br><span class="line">  str: string | null;</span><br><span class="line">  bol?: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>五种 JS 值类型就声明好了。那数组、函数呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Func &#123;</span><br><span class="line">  func(str: string): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Arr &#123;</span><br><span class="line">  str: string[];</span><br><span class="line">  mixed: Array&lt;string | number&gt;;</span><br><span class="line">  fixedStructure: [string, number];</span><br><span class="line">  basics: Basic[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>枚举类型也是很常用的，比如声明一个状态机的各个状态</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">  Draft,</span><br><span class="line">  Published</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 也可指定值</span><br><span class="line">enum Status &#123;</span><br><span class="line">  Draft = &#x27;Draft&#x27;,</span><br><span class="line">  Published = &#x27;Published&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-1-2-糅合"><a href="#16-1-2-糅合" class="headerlink" title="16.1.2 糅合"></a>16.1.2 糅合</h4><p><strong>独立声明</strong></p>
<blockquote>
<p>一个 <code>ts</code> 文件只声明一个类型或者接口，文件名为需要暴露的类型名称，方便检索和管理</p>
</blockquote>
<p><strong>就近声明</strong></p>
<blockquote>
<p>当一个声明没有被外部引用或者依赖时，可以考虑就近放在使用的地方，典型的场景是 <code>React</code> 组件的 <code>Props</code> 和 <code>State</code> 的类型声明</p>
</blockquote>
<p><strong>按职责分组</strong></p>
<ul>
<li>在项目中，需要声明类型的可大致分为两类：一类是 <code>model</code>，也就是接口请求相关的，包括入参和出参；另一类是 <code>view</code>，界面渲染相关的。因此，我在 独立声明 的基础上，可以类型按照<code>model</code> 和 <code>view</code> 的维度进行分组，相互独立。</li>
<li>那么问题来了，如果是独立的类型声明的话，怎么把 model 的数据应用到 <code>view</code> 呢？ 可能你需要一个 <code>adapter</code> 来做类型的的转换：<code>DTOTypes</code> -&gt; <code>adapter</code> -&gt; <code>ViewTypes</code>, 完成类似于将接口中的字符串映射成枚举类型这之类的转换</li>
</ul>
<p><strong>any</strong></p>
<blockquote>
<p>当遇到确实解决不了的类型报错的时候，<code>as any</code> 能带给你不一样的快感，但是不建议使用啊</p>
</blockquote>
<h3 id="16-2-如何引用外部库"><a href="#16-2-如何引用外部库" class="headerlink" title="16.2 如何引用外部库"></a>16.2 如何引用外部库</h3><blockquote>
<p>在 <code>JS</code> 中，<code>npm</code> 上有丰富的海量的库帮我们完成日常的编码，可能并不是所有的库都能完全被应用到 <code>TS</code> 中，因为有些缺少类型声明</p>
</blockquote>
<p>比如，在 <code>TS</code> 中使用 <code>react</code>, 你会得到这样的一个类型检查错误：</p>
<p><img src="https://pic2.zhimg.com/80/v2-fdfb8e5f2be67d8c978e216254b80a9d_hd.jpg" alt="img"></p>
<ul>
<li>因为 react 的库中并没有类型声明</li>
<li>现在比较通用的做法是，实现和类型实现独立成两个库，也就是你需要再安装类型声明的库: <code>@types/react</code></li>
<li>当遇到上述问题的时候，尝试安装一下 <code>@types/[package]</code></li>
<li>然而，并不是所有的库都有类型声明的实现，也会有很多不支持 TS 的存在，然而又必须得使用这个库的时候该怎么办？</li>
</ul>
<p><strong>自己写声明</strong></p>
<blockquote>
<p>以 <code>progressbar.js</code>为例，基本使用方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import * as ProgressBar from &#x27;progressbar.js&#x27;;</span><br><span class="line"></span><br><span class="line">new ProgressBar.Circle(this.$progress, &#123;</span><br><span class="line">  strokeWidth: 8,</span><br><span class="line">  trailColor: &#x27;#e5e4e5&#x27;,</span><br><span class="line">  trailWidth: 8,</span><br><span class="line">  easing: &#x27;easeInOut&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们需要对库中暴露出的 api 去做声明，对上述例子做个分解：暴露了 Circle 类，Circle 构造函数包含两个参数，一个 HTMLElement，一个 options. OK</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 首先声明一下模块：</span><br><span class="line">declare module &#x27;progressbar.js&#x27; &#123;</span><br><span class="line">  // 模块中暴露了 Circle 类</span><br><span class="line">  export class Circle &#123;</span><br><span class="line">    constructor(container: HTMLElement, options: Options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 构造函数的 Options 需要单独声明 </span><br><span class="line">  interface Options &#123;</span><br><span class="line">    easing?: string;</span><br><span class="line">    strokeWidth?: number;</span><br><span class="line">    trailColor?: string;</span><br><span class="line">    trailWidth?: number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如此我们便完成了一个简单的声明，当然实际使用中的 API 肯定比上述情况复杂，根据使用情况，用了哪些 API 或者参数，就补充那些的声明即可</p>
</blockquote>
<h3 id="16-3-如何组织一个-TS-项目"><a href="#16-3-如何组织一个-TS-项目" class="headerlink" title="16.3 如何组织一个 TS 项目"></a>16.3 如何组织一个 TS 项目</h3><ul>
<li>TS 项目的目录组织上，跟 JS 项目一样，补充好 types 的声明就可以了</li>
<li>需要注意的是，将你希望对外暴露的能力相关的类型声明都暴露出去，不友好的声明会让接入你项目的人非常的痛苦，同时，在 package.json 中需要指定 type 的 path, 比如：”types”: “dist&#x2F;types&#x2F;index.d.ts”</li>
<li>另外，务必加上 tslint, 更规范的去用 TS 实现功能，对于入门而言尤为重要</li>
</ul>
<h3 id="16-4-TSX-和-JSX"><a href="#16-4-TSX-和-JSX" class="headerlink" title="16.4 TSX 和 JSX"></a>16.4 TSX 和 JSX</h3><ul>
<li>之前我们在用 <code>JavaScript</code> 写 <code>React</code> 时，对文件的扩展名没有什么特别的要求，<code>.js</code> 或者 <code>.jsx</code> 都行。</li>
<li>但在 <code>TypeScript</code> 中，如果你要使用 <code>JSX</code> 语法，就不能使用 <code>.ts</code>，必须使用 <code>.tsx</code>。如果你不知道，或者忘了这么做，那么你会在使用了 <code>JSX</code> 代码的地方收到类型报错，但代码本身怎么看都没有问题。这也是刚上手 <code>TypeScript + React</code> 时几乎每个人都会遇到的坑。</li>
<li>关于这一点，<code>TypeScript</code> 只是在官方教程的示例代码中直接用了 <code>*.tsx</code>，但并没有明确说明这一问题</li>
</ul>
<h3 id="16-5-变量的-Type-怎么找"><a href="#16-5-变量的-Type-怎么找" class="headerlink" title="16.5 变量的 Type 怎么找"></a>16.5 变量的 Type 怎么找</h3><ul>
<li>上手 <code>TypeScript</code> 之后很快我们就发现，即便是原生的 <code>DOM</code>、或是 <code>React</code> 的 <code>API</code>，也经常会要我们手动指定类型。但这些结构并不是简单的 <code>JavaScript</code>原始类型，在使用 <code>JavaScript</code> 编写相关代码时候由于没有这种需要，我们也没关心过这些东西的类型，突然问起来，还真不知道这些类型叫什么名字。</li>
<li>不光是这些标准类型，同样的问题在很多第三方的库中也会遇到，比如一些组件库会检查你传入的 <code>Props</code></li>
<li>在我看来，这中间其实缺少了一部分的文档，来指导新用户如何找到所需要的类型。既然社区没有提供，那就我来吧。</li>
<li>当然，让每个开发者都熟记所有的类型肯定是不现实的，总不能每接触一个新的库，就要去记一堆类型吧。放心，世界还是美好的，这种事情，当然是有方法的。</li>
<li>最直白的方法就是去看库的 <code>Types Definition</code>，也就是那些 <code>.*d.ts</code> 文件。如果你刚好有在用 <code>VS Code</code> 的话，有一个非常方便的操作：把鼠标移动到你想知道它类型的代码上（比如某个变量、某个函数调用，或是某个 JSX 标签、某个组件的 props），右键选择「Go to Definition」（或者光标选中后按 F12），就可以跳转到它的类型定义文件了。</li>
<li>如果你更习惯使用 VS Code 之外的编辑器，我相信时至今日，它们应该也都早就对 <code>TypeScript</code> 提供了支持。具体操作我不太熟悉，你可以自己探索下（我一直用 VS Code，其它的不太熟）</li>
<li>一般来说，这个操作可以直接把你带到你想要的地方，但考虑到类型是可以继承的，有时候一次跳转可能不太够，遇到这种情况，那就需要你随机应变一下，沿着继承关系多跳几次，直到找到你想要的内容。</li>
<li>对于不熟悉的类型，可以通过这个方法去寻找，慢慢熟悉以后，你会发现，一些常见的类型还是很好找的，稍微联想一下英文的表达方式，配合自动补全的提示，一般都不难找到</li>
</ul>
<h3 id="16-6-常见-Types-之-DOM"><a href="#16-6-常见-Types-之-DOM" class="headerlink" title="16.6 常见 Types 之 DOM"></a>16.6 常见 Types 之 DOM</h3><ul>
<li><code>TypeScript</code> 自带了一些基本的类型定义，包括 ECMAScript 和 DOM 的类型定义，所有你需要的类型都可以从这里找到。如果你想做一些「纯 TypeScript 开发」的话，有这些就够了</li>
<li>比如下面这张截图，就是对 &#96;&#96; 标签的类型定义。我们可以看到，它继承了更加通用的 <code>HTMLElement</code> 类型，并且扩展了一个即将被废弃的 <code>align</code> 属性，以及两组 <code>addEventListener</code> 和 <code>removeEventListener</code>，注意这里使用了重载。</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/3.png" alt="img"></p>
<blockquote>
<p>这里的命名也不是随便起的，都是在 MDN 上可以查到的。还是以 &#96;&#96; 为例，我们已经知道它继承自 <code>HTMLElement</code>，其实再往上，<code>HTMLElement</code> 继承自 <code>Element</code>，<code>Element</code> 又继承自 <code>Node</code>，顺着这条路，你可以挖掘出所有 <code>HTML</code> 标签的类型</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/4.png" alt="img"></p>
<blockquote>
<p>对于一些 DOM 相关的属性，比如 <code>onclick</code>、<code>onchange</code> 等，你都可以如法炮制，找到它们的定义。</p>
</blockquote>
<h3 id="16-7-常见-Types-之-React"><a href="#16-7-常见-Types-之-React" class="headerlink" title="16.7 常见 Types 之 React"></a>16.7 常见 Types 之 React</h3><ul>
<li>关于 TypeScript 的问题，有不少其实是在使用第三方库的时候遇到的，React 就是其中比较典型的一个</li>
<li>其实方法都一样，只不过相关的类型定义不在 <code>TypeScript</code> 中，而是在 <code>@types/react</code> 中。</li>
<li><code>React</code> 的类型定义的名称其实也很直观，比如我们常见的 <code>React.Component</code>，在定义 <code>Class</code> 组件时，我们需要对 <code>Props</code> 和 <code>State</code> 预先进行类型定义，为什么呢？答案就在它的类型定义中</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/5.png" alt="img"></p>
<ul>
<li>再比如，当我们在写一些组件时，我们可能会需要向下传递 <code>this.props.children</code>，但 <code>children</code> 并没有被设为默认值，需要我们自己定义到 <code>props</code> 上，那么它的类型应该是什么呢</li>
<li>到类型定义中搜一下关键字 <code>children</code>，很快我们就找到了下面的定义</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/6.png" alt="img"></p>
<blockquote>
<p>所有 <code>React</code> 中 <code>JSX</code> 所代表的内容，无论是 <code>render()</code> 的返回，还是 <code>children</code>，我们都可以定义为一个 <code>ReactNode</code>。那这个 <code>ReactNode</code> 长什么样呢？我们通过右键继续寻找</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/7.png" alt="img"></p>
<blockquote>
<p>看到这里，我们不光找到了我们想要的类型，还顺带明白了为什么 <code>render()</code> 可以返回 <code>boolean</code>、<code>null</code>、<code>undefined</code> 表示不渲染任何内容。<br>那么事件呢？当我们给组件定义事件处理函数的时候，也经常会被要求指定类型。还是老办法，找不到咱就搜，比如 <code>onClick</code> 不清楚，那我们就以它为关键字去搜</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/8.png" alt="img"></p>
<blockquote>
<p>据此我们找到一个叫 <code>MouseEventHandler</code> 的定义，这名字，够直白吧。好了，我们找到想要的了。不过既然来了，不如继续看一下，看看还能发现什么。我们右键 <code>MouseEventHandler</code> 急需往下看：</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/9.png" alt="img"></p>
<blockquote>
<p>看到了吗，所有的事件处理函数都有对应的定义，每个都需要一个泛型参数，传递了事件的类型，名称也挺直白的</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/10.png" alt="img"></p>
<blockquote>
<p>事件的类型也被我们挖出来了，以后如果需要单独定义一个事件相关的类型，就可以直接用了。以此类推，不管是什么东西的类型，都可以去它们对应的 <code>@types/xxx</code>里，按关键字搜</p>
</blockquote>
<h3 id="16-8-多重-extends"><a href="#16-8-多重-extends" class="headerlink" title="16.8 多重 extends"></a>16.8 多重 extends</h3><ul>
<li>我们知道 <code>Interface</code> 是可以多继承的，<code>extends</code> 后面可以跟多个其它 <code>Interface</code>，我们不能保证被继承的多个 <code>Interface</code> 一定没有重复的属性，那么当属性重复，但类型定义不同时，最终的结果会怎么样呢？</li>
<li>在 <code>TypeScript</code> 中，<code>Interface</code> 会按照从右往左的顺序去合并多个被继承的 <code>Interface</code>，也就是说，同名属性，左边的会覆盖右边的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">  value?: string</span><br><span class="line">&#125;</span><br><span class="line">interface B &#123;</span><br><span class="line">  value: string</span><br><span class="line">&#125;</span><br><span class="line">interface C &#123;</span><br><span class="line">  value: number</span><br><span class="line">&#125;</span><br><span class="line">interface D extends A, B &#123;&#125;// value?: string</span><br><span class="line">interface E extends B, C &#123;&#125;// value: string</span><br></pre></td></tr></table></figure>

<h3 id="16-9-obj-prop-无法访问怎么办"><a href="#16-9-obj-prop-无法访问怎么办" class="headerlink" title="16.9 obj[prop] 无法访问怎么办"></a>16.9 obj[prop] 无法访问怎么办</h3><ul>
<li>有时候我们会定义一些集合型的数据，例如对象、枚举等，但在调用的时候，我们未必会直接通过 <code>obj.prop</code> 的形式去调用，可能会是以 <code>obj[prop]</code> 这种动态索引的形式去访问，但通过动态索引的方式就无法确定最终访问的元素是否存在，因此在 <code>TypeScript</code> 中，默认是不允许这种操作的</li>
<li>但这又是个非常合理，而且非常常见的场景，怎么办呢？<code>TypeScript</code> 允许为类型添加索引，以实现这一点。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">  x: string,</span><br><span class="line">  y: number</span><br><span class="line">  [index: string]: string | number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个方法虽然有效，但每次都要手动为类型加索引，重复多了也挺心累的。包括在一些「配置对象」中，我们甚至无法确定有哪些类型，有没有一种更加通用、更加一劳永逸的方法。</li>
<li>其实在 <code>TypeScript</code>的官方文档中就有提到这个方案，官方管它叫 <code>OptionBag</code>，大概就是指 <code>config</code>、o<code>ption</code> 等用于提供配置信息的这么一类参数。我不是很确定这到底是个常规的英文单词，还是 <code>TypeScript</code> 中特定的术语（个人感觉是前者），反正就这么个意思吧。<br>简单说来，我们可以定义下面这样一个类型：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface OptionBag &#123;</span><br><span class="line">  [index: string]: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个非常通用的结构，以字符串为键，值可以是任何类型，并且支持索引 —— 这不就是 <code>Object</code> 么。</li>
<li>之后所有需要动态索引的结构，或是作为配置对象的结构，都可以直接指定为，或是继承 <code>OptionBag</code>。这个方案以牺牲一定的类型检查为代价，换取了操作上的便利。</li>
<li>理论上讲，<code>OptionBag</code> 可以适用于所有类似对象这样的结构，但不建议各位真就这么做。这个方案只能是用在一些对类型要求不那么严格，或是无法预知类型的场景中，能够确定的类型还是尽可能地写一下，否则就失去了使用 <code>TypeScript</code> 意义了</li>
</ul>
<h2 id="十七、其他技巧"><a href="#十七、其他技巧" class="headerlink" title="十七、其他技巧"></a>十七、其他技巧</h2><p><strong>1. 安全导航操作符 ( ?. )和非空断言操作符（!.）</strong></p>
<ul>
<li><strong>安全导航操作符 ( ?. ) 和空属性路径</strong>：</li>
</ul>
<blockquote>
<p>为了解决导航时变量值为null时，页面运行时出错的问题</p>
</blockquote>
<ul>
<li><strong>非空断言操作符</strong></li>
</ul>
<blockquote>
<p>能确定变量值一定不为空时使用。与安全导航操作符不同的是，非空断言操作符不会防止出现 <code>null</code> 或 <code>undefined</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s = e!.name; // 断言e是非空并访问name属性</span><br></pre></td></tr></table></figure>

<h1 id="第二章-工程篇"><a href="#第二章-工程篇" class="headerlink" title="第二章 工程篇"></a>第二章 工程篇</h1><p><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-1.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-2.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-3.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-4.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-5.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-6.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-7.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-8.webp" alt="img"></p>
<h2 id="一、使用命名空间"><a href="#一、使用命名空间" class="headerlink" title="一、使用命名空间"></a>一、使用命名空间</h2><blockquote>
<p>不要在一个模块中使用命名空间，最好在一个全局中使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// a.ts</span><br><span class="line">namespace Shape &#123;</span><br><span class="line">    const pi = Math.PI</span><br><span class="line">    export function cricle(r: number) &#123;</span><br><span class="line">        return pi * r ** 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// b.ts</span><br><span class="line"></span><br><span class="line">// 三斜线引用a</span><br><span class="line">/// &lt;reference path=&quot;a.ts&quot; /&gt;</span><br><span class="line">namespace Shape &#123;</span><br><span class="line">    export function square(x: number) &#123;</span><br><span class="line">        return x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Shape.cricle(2))</span><br><span class="line">console.log(Shape.square(2))</span><br><span class="line"></span><br><span class="line">// 更方便使用 不是es6中的import</span><br><span class="line">import cricle = Shape.cricle</span><br><span class="line">console.log(cricle(2))</span><br></pre></td></tr></table></figure>

<h2 id="二、理解联合声明"><a href="#二、理解联合声明" class="headerlink" title="二、理解联合声明"></a>二、理解联合声明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 接口声明合并</span><br><span class="line">interface A &#123;</span><br><span class="line">    x: number;</span><br><span class="line">    // y: string;</span><br><span class="line">    foo(bar: number): number; // 5</span><br><span class="line">    foo(bar: &#x27;a&#x27;): string; // 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A &#123;</span><br><span class="line">    y: number;</span><br><span class="line">    foo(bar: string): string; // 3</span><br><span class="line">    foo(bar: string[]): string[]; // 4</span><br><span class="line">    foo(bar: &#x27;b&#x27;): string; // 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a: A = &#123;</span><br><span class="line">    x: 1,</span><br><span class="line">    y: 2,</span><br><span class="line">    foo(bar: any) &#123;</span><br><span class="line">        return bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 命名空间和类声明合并--命名空间需要放到后面</span><br><span class="line">class C &#123;&#125;</span><br><span class="line">namespace C &#123;</span><br><span class="line">    export let state = 1</span><br><span class="line">&#125;</span><br><span class="line">console.log(C.state)</span><br><span class="line"></span><br><span class="line">// 命名空间和函数声明合并--命名空间需要放到后面</span><br><span class="line">function Lib() &#123;&#125;</span><br><span class="line">namespace Lib &#123;</span><br><span class="line">    export let version = &#x27;1.0&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Lib.version)</span><br><span class="line"></span><br><span class="line">// 命名空间和枚举声明合并--位置没有要求</span><br><span class="line">enum Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Yellow,</span><br><span class="line">    Blue</span><br><span class="line">&#125;</span><br><span class="line">namespace Color &#123;</span><br><span class="line">    export function mix() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Color)</span><br></pre></td></tr></table></figure>

<h2 id="三、如何编写声明文件–引入类库"><a href="#三、如何编写声明文件–引入类库" class="headerlink" title="三、如何编写声明文件–引入类库"></a>三、如何编写声明文件–引入类库</h2><blockquote>
<p>类库分为三类：全局类库、模块类库、<code>UMD</code>类库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare var // 声明全局变量</span><br><span class="line">declare function // 声明全局方法</span><br><span class="line">declare class // 声明全局类</span><br><span class="line">declare enum // 声明全局枚举类型</span><br><span class="line">declare global // 扩展全局变量</span><br><span class="line">declare module // 扩展模块</span><br></pre></td></tr></table></figure>

<blockquote>
<p>大多数的声明文件社区已经帮我们安装好了，使用<code>@types/包名</code>声明文件即可</p>
</blockquote>
<blockquote>
<p>Typescript声明文件查找 <a target="_blank" rel="noopener" href="https://microsoft.github.io/TypeSearch/">https://microsoft.github.io/TypeSearch/</a></p>
</blockquote>
<p><strong>以jquery为例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @types/jquery</span><br></pre></td></tr></table></figure>

<p><strong>引入了一个JS类库，但是社区又没有提供类型声明文件，我该如何去编写它的类型声明文件</strong></p>
<blockquote>
<p>先确定这个库的类型，全局库、模块库、还是UMD库，然后参照下面介绍的方法，把它的<code>API</code>声明逐步添加进来（暂时用不到的<code>API</code>也可以不写）</p>
</blockquote>
<h3 id="3-1-三种类库声明文件写法"><a href="#3-1-三种类库声明文件写法" class="headerlink" title="3.1 三种类库声明文件写法"></a>3.1 三种类库声明文件写法</h3><h4 id="3-1-1-全局库"><a href="#3-1-1-全局库" class="headerlink" title="3.1.1 全局库"></a>3.1.1 全局库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// global-lib.d.ts</span><br><span class="line">    </span><br><span class="line">declare function globalLib(options: globalLib.Options): void;</span><br><span class="line">// 函数和命名空间的声明合并 为这个函数提供了一些属性</span><br><span class="line">declare namespace globalLib &#123;</span><br><span class="line">    const version: string;</span><br><span class="line">    function doSomething(): void;</span><br><span class="line">    interface Options &#123;</span><br><span class="line">        [key: string]: any</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// global-lib.js</span><br><span class="line">// 和声明文件对应</span><br><span class="line">function globalLib(options) &#123;</span><br><span class="line">    console.log(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">globalLib.version = &#x27;1.0.0&#x27;;</span><br><span class="line"></span><br><span class="line">globalLib.doSomething = function() &#123;</span><br><span class="line">    console.log(&#x27;globalLib do something&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">// 全局使用 index.ts</span><br><span class="line">globalLib(&#123;x:1&#125;)</span><br><span class="line">globalLib.doSomething()</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-模块类库"><a href="#3-1-2-模块类库" class="headerlink" title="3.1.2 模块类库"></a>3.1.2 模块类库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// module-lib.d.ts</span><br><span class="line">declare function moduleLib(options: Options): void</span><br><span class="line"></span><br><span class="line">interface Options &#123;</span><br><span class="line">    [key: string]: any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare namespace moduleLib &#123;</span><br><span class="line">    const version: string</span><br><span class="line">    function doSomething(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export = moduleLib</span><br><span class="line">// module-lib.js</span><br><span class="line">const version = &#x27;1.0.0&#x27;;</span><br><span class="line"></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    console.log(&#x27;moduleLib do something&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function moduleLib(options) &#123;</span><br><span class="line">    console.log(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moduleLib.version = version;</span><br><span class="line">moduleLib.doSomething = doSomething;</span><br><span class="line"></span><br><span class="line">module.exports = moduleLib;</span><br><span class="line">// index.ts 使用</span><br><span class="line">import umdLib from &#x27;./umd-lib&#x27;</span><br><span class="line"></span><br><span class="line">umdLib.doSomething()</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-UMD类库"><a href="#3-1-3-UMD类库" class="headerlink" title="3.1.3 UMD类库"></a>3.1.3 UMD类库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// umd-lib.d.ts</span><br><span class="line"></span><br><span class="line">declare namespace umdLib &#123;</span><br><span class="line">    // 省略了export</span><br><span class="line">    const version: string</span><br><span class="line">    function doSomething(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UMD库不可缺少的语句</span><br><span class="line">export as namespace umdLib</span><br><span class="line"></span><br><span class="line">export = umdLib</span><br><span class="line">// umd-lib.js</span><br><span class="line">(function (root, factory) &#123;</span><br><span class="line">    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;</span><br><span class="line">        define(factory);</span><br><span class="line">    &#125; else if (typeof module === &quot;object&quot; &amp;&amp; module.exports) &#123;</span><br><span class="line">        module.exports = factory();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        root.umdLib = factory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(this, function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        // 需要为这两个成员编写声明文件</span><br><span class="line">        version: &#x27;1.0.0&#x27;,</span><br><span class="line">        doSomething() &#123;</span><br><span class="line">            console.log(&#x27;umdLib do something&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line">// index.ts使用</span><br><span class="line">import umdLib from &#x27;./umd-lib&#x27;</span><br><span class="line">// 可以不用导入umd-lib模块。但是需要打开tsconfig.tson中的umd配置</span><br><span class="line">umdLib.doSomething()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-两种插件声明文件写法"><a href="#3-2-两种插件声明文件写法" class="headerlink" title="3.2 两种插件声明文件写法"></a>3.2 两种插件声明文件写法</h3><h4 id="3-2-1-模块化插件declare-module"><a href="#3-2-1-模块化插件declare-module" class="headerlink" title="3.2.1 模块化插件declare module"></a>3.2.1 模块化插件declare module</h4><blockquote>
<p><code>declare module</code> 可以给类库添加一些自定义方法。 扩展模块</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 模块插件</span><br><span class="line">import m from &#x27;moment&#x27;;</span><br><span class="line">declare module &#x27;moment&#x27; &#123;</span><br><span class="line">    // 给moment自定义一些方法</span><br><span class="line">    export function myFunction(): void;</span><br><span class="line">&#125;</span><br><span class="line">m.myFunction = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-全局插件declare-global"><a href="#3-2-2-全局插件declare-global" class="headerlink" title="3.2.2 全局插件declare global"></a>3.2.2 全局插件declare global</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 全局插件</span><br><span class="line">declare global &#123;</span><br><span class="line">    namespace globalLib &#123;</span><br><span class="line">        function doAnyting(): void</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在全局变量添加方法</span><br><span class="line">// 会对全局变量造成污染 一般不这么做</span><br><span class="line">globalLib.doAnyting = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-jquery声明文件示例"><a href="#3-3-jquery声明文件示例" class="headerlink" title="3.3 jquery声明文件示例"></a>3.3 jquery声明文件示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// index.d.ts入口</span><br><span class="line"></span><br><span class="line">// Type definitions for jquery 3.3</span><br><span class="line">// Project: https://jquery.com</span><br><span class="line">// Definitions by: Leonard Thieu &lt;https://github.com/leonard-thieu&gt;</span><br><span class="line">//                 Boris Yankov &lt;https://github.com/borisyankov&gt;</span><br><span class="line">//                 Christian Hoffmeister &lt;https://github.com/choffmeister&gt;</span><br><span class="line">//                 Steve Fenton &lt;https://github.com/Steve-Fenton&gt;</span><br><span class="line">//                 Diullei Gomes &lt;https://github.com/Diullei&gt;</span><br><span class="line">//                 Tass Iliopoulos &lt;https://github.com/tasoili&gt;</span><br><span class="line">//                 Jason Swearingen &lt;https://github.com/jasons-novaleaf&gt;</span><br><span class="line">//                 Sean Hill &lt;https://github.com/seanski&gt;</span><br><span class="line">//                 Guus Goossens &lt;https://github.com/Guuz&gt;</span><br><span class="line">//                 Kelly Summerlin &lt;https://github.com/ksummerlin&gt;</span><br><span class="line">//                 Basarat Ali Syed &lt;https://github.com/basarat&gt;</span><br><span class="line">//                 Nicholas Wolverson &lt;https://github.com/nwolverson&gt;</span><br><span class="line">//                 Derek Cicerone &lt;https://github.com/derekcicerone&gt;</span><br><span class="line">//                 Andrew Gaspar &lt;https://github.com/AndrewGaspar&gt;</span><br><span class="line">//                 Seikichi Kondo &lt;https://github.com/seikichi&gt;</span><br><span class="line">//                 Benjamin Jackman &lt;https://github.com/benjaminjackman&gt;</span><br><span class="line">//                 Poul Sorensen &lt;https://github.com/s093294&gt;</span><br><span class="line">//                 Josh Strobl &lt;https://github.com/JoshStrobl&gt;</span><br><span class="line">//                 John Reilly &lt;https://github.com/johnnyreilly&gt;</span><br><span class="line">//                 Dick van den Brink &lt;https://github.com/DickvdBrink&gt;</span><br><span class="line">//                 Thomas Schulz &lt;https://github.com/King2500&gt;</span><br><span class="line">//                 Terry Mun &lt;https://github.com/terrymun&gt;</span><br><span class="line">// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped</span><br><span class="line">// TypeScript Version: 2.3</span><br><span class="line"></span><br><span class="line">// 三斜线引入模块</span><br><span class="line"></span><br><span class="line">/// &lt;reference types=&quot;sizzle&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;</span><br><span class="line"></span><br><span class="line">export = jQuery;</span><br></pre></td></tr></table></figure>

<h2 id="四、配置tsconfig-json"><a href="#四、配置tsconfig-json" class="headerlink" title="四、配置tsconfig.json"></a>四、配置tsconfig.json</h2><h3 id="4-1-基础配置"><a href="#4-1-基础配置" class="headerlink" title="4.1 基础配置"></a>4.1 基础配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ===与文件相关的选项===</span><br><span class="line">  &quot;files&quot; : [&#x27;src/index.ts&#x27;], // 编译的文件列表</span><br><span class="line">  &quot;include&quot;: [&#x27;src&#x27;], // 指定编译文件</span><br><span class="line">  &quot;exclude&quot;: [&#x27;src/lib&#x27;], // 排除编译文件</span><br><span class="line">  </span><br><span class="line">  // ====与编译相关的选项====</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">      // &quot;incremental&quot;: true,                // 增量编译，再次编译会增量编译</span><br><span class="line">      // &quot;tsBuildInfoFile&quot;: &quot;./buildFile&quot;,   // 增量编译文件的存储位置</span><br><span class="line">      // &quot;diagnostics&quot;: true,                // 打印诊断信息</span><br><span class="line"></span><br><span class="line">      // &quot;target&quot;: &quot;es5&quot;,           // 目标语言的版本</span><br><span class="line">      // &quot;module&quot;: &quot;commonjs&quot;,      // 生成代码的模块标准</span><br><span class="line">      // &quot;outFile&quot;: &quot;./app.js&quot;,     // 将多个相互依赖的文件生成一个文件，可以用在 AMD 模块中</span><br><span class="line">        </span><br><span class="line">       // 比如你需要使用es2019方法 需要在这里导入模块 &quot;lib&quot;: [&#x27;es2019.arrary&#x27;]</span><br><span class="line">      // &quot;lib&quot;: [],                 // TS 需要引用的库，即声明文件，es5 默认 &quot;dom&quot;, &quot;es5&quot;, &quot;scripthost&quot;</span><br><span class="line"></span><br><span class="line">      // &quot;allowJs&quot;: true,           // 允许编译 JS 文件（js、jsx）</span><br><span class="line">      // &quot;checkJs&quot;: true,           // 允许在 JS 文件中报错，通常与 allowJS 一起使用</span><br><span class="line">      // &quot;outDir&quot;: &quot;./out&quot;,         // 指定输出目录</span><br><span class="line">      // &quot;rootDir&quot;: &quot;./&quot;,           // 指定输入文件目录（用于输出）</span><br><span class="line"></span><br><span class="line">      // &quot;declaration&quot;: true,         // 生成声明文件</span><br><span class="line">      // &quot;declarationDir&quot;: &quot;./d&quot;,     // 声明文件的路径</span><br><span class="line">      // &quot;emitDeclarationOnly&quot;: true, // 只生成声明文件</span><br><span class="line">      // &quot;sourceMap&quot;: true,           // 生成目标文件的 sourceMap</span><br><span class="line">      // &quot;inlineSourceMap&quot;: true,     // 生成目标文件的 inline sourceMap</span><br><span class="line">      // &quot;declarationMap&quot;: true,      // 生成声明文件的 sourceMap</span><br><span class="line">      // &quot;typeRoots&quot;: [],             // 声明文件目录，默认 node_modules/@types</span><br><span class="line">      // &quot;types&quot;: [],                 // 声明文件包</span><br><span class="line"></span><br><span class="line">      // &quot;removeComments&quot;: true,    // 删除注释</span><br><span class="line"></span><br><span class="line">      // &quot;noEmit&quot;: true,            // 不输出文件</span><br><span class="line">      // &quot;noEmitOnError&quot;: true,     // 发生错误时不输出文件</span><br><span class="line"></span><br><span class="line">      // &quot;noEmitHelpers&quot;: true,     // 不生成 helper 函数，需额外安装 ts-helpers</span><br><span class="line">      // &quot;importHelpers&quot;: true,     // 通过 tslib 引入 helper 函数，文件必须是模块</span><br><span class="line"></span><br><span class="line">      // &quot;downlevelIteration&quot;: true,    // 降级遍历器的实现（es3/5）</span><br><span class="line"></span><br><span class="line">      // &quot;strict&quot;: true,                        // 开启所有严格的类型检查</span><br><span class="line">      // &quot;alwaysStrict&quot;: false,                 // 在代码中注入 &quot;use strict&quot;;</span><br><span class="line">      // &quot;noImplicitAny&quot;: false,                // 不允许隐式的 any 类型</span><br><span class="line">      // &quot;strictNullChecks&quot;: false,             // 不允许把 null、undefined 赋值给其他类型变量</span><br><span class="line">      // &quot;strictFunctionTypes&quot;: false           // 不允许函数参数双向协变</span><br><span class="line">      // &quot;strictPropertyInitialization&quot;: false, // 类的实例属性必须初始化</span><br><span class="line">      // &quot;strictBindCallApply&quot;: false,          // 严格的 bind/call/apply 检查</span><br><span class="line">      // &quot;noImplicitThis&quot;: false,               // 不允许 this 有隐式的 any 类型</span><br><span class="line"></span><br><span class="line">      // &quot;noUnusedLocals&quot;: true,                // 检查只声明，未使用的局部变量</span><br><span class="line">      // &quot;noUnusedParameters&quot;: true,            // 检查未使用的函数参数</span><br><span class="line">      // &quot;noFallthroughCasesInSwitch&quot;: true,    // 防止 switch 语句贯穿</span><br><span class="line">      // &quot;noImplicitReturns&quot;: true,             // 每个分支都要有返回值</span><br><span class="line"></span><br><span class="line">      // &quot;esModuleInterop&quot;: true,               // 允许 export = 导出，由import from 导入</span><br><span class="line">      // &quot;allowUmdGlobalAccess&quot;: true,          // 允许在模块中访问 UMD 全局变量</span><br><span class="line">      // &quot;moduleResolution&quot;: &quot;node&quot;,            // 模块解析策略</span><br><span class="line">      // &quot;baseUrl&quot;: &quot;./&quot;,                       // 解析非相对模块的基地址</span><br><span class="line">      // &quot;paths&quot;: &#123;                             // 路径映射，相对于 baseUrl</span><br><span class="line">      //   &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;]</span><br><span class="line">      // &#125;,</span><br><span class="line">      // &quot;rootDirs&quot;: [&quot;src&quot;, &quot;out&quot;],            // 将多个目录放在一个虚拟目录下，用于运行时</span><br><span class="line"></span><br><span class="line">      // &quot;listEmittedFiles&quot;: true,        // 打印输出的文件</span><br><span class="line">      // &quot;listFiles&quot;: true,               // 打印编译的文件（包括引用的声明文件）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以把公共的抽离出来</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// tsconfig.base.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;files&quot; : [&#x27;src/index.ts&#x27;], // 编译的文件列表</span><br><span class="line">  &quot;include&quot;: [&#x27;src&#x27;], // 指定编译文件</span><br><span class="line">  &quot;exclude&quot;: [&#x27;src/lib&#x27;], // 排除编译文件</span><br><span class="line">&#125;</span><br><span class="line">&quot;extends&quot;: &#x27;./tsconfig.base&#x27;,</span><br><span class="line">&quot;exclude&quot;: [] // 覆盖之前的</span><br></pre></td></tr></table></figure>

<h3 id="4-2-工程引用配置多个项目"><a href="#4-2-工程引用配置多个项目" class="headerlink" title="4.2 工程引用配置多个项目"></a>4.2 工程引用配置多个项目</h3><blockquote>
<p>每个项目都有一份独立的<code>tsconfig.json</code>，继承一份公共的配置，最后可单独构建每个子项目工程</p>
</blockquote>
<blockquote>
<p>参考学习<code>typescript</code>项目 <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/tree/master/src">https://github.com/microsoft/TypeScript/tree/master/src</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 示例 项目入口</span><br><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">    &quot;strict&quot;: true,</span><br><span class="line">    &quot;composite&quot;: true,</span><br><span class="line">    &quot;declaration&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子工程1</span><br><span class="line">// src/client/tsconfig.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: &quot;../../tsconfig.json&quot;, //继承基础配置</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;../../dist/client&quot;, // 输出文件</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;references&quot;: [</span><br><span class="line">        &#123; &quot;path&quot;: &quot;../common&quot; &#125; // 依赖文件</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">// 子工程2</span><br><span class="line">// src/server/tsconfig.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: &quot;../../tsconfig.json&quot;,</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;../../dist/server&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;references&quot;: [</span><br><span class="line">        &#123; &quot;path&quot;: &quot;../common&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、编译工具ts-loader、ts-lint"><a href="#五、编译工具ts-loader、ts-lint" class="headerlink" title="五、编译工具ts-loader、ts-lint"></a>五、编译工具ts-loader、ts-lint</h2><p><strong>如何选择Typescript编译器</strong></p>
<blockquote>
<ul>
<li>如果没有使用过<code>babel</code>，首选<code>Typescript</code>自身编译器(可配合<code>Ts-loader</code>使用)</li>
<li>如果项目中已经使用<code>babel</code>，安装<code>@babel/preset-typescript</code>(可配合tsc做类型检查)</li>
<li>两种编译工具不要混用</li>
</ul>
</blockquote>
<p><strong>typescript-eslint与babel-eslint区别</strong></p>
<blockquote>
<ul>
<li><code>babel-eslint</code>支持<code>typescript</code>没有额外的语法检查，抛弃<code>typescript</code>,不支持类型检查</li>
<li><code>typescript-eslint</code>基础typescript的AST,基于创建基于类型信息的规则（<code>tsconfig.json</code>）</li>
</ul>
</blockquote>
<ul>
<li>两者底层机制不一样，不要一起使用</li>
<li><code>babel</code>体系建议使用<code>babel-eslint</code>，否则使用<code>typescript-eslint</code></li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>编译工具<ul>
<li><code>ts-loader</code></li>
<li><code>@babel/preset-typescript</code></li>
</ul>
</li>
<li>代码检查工具<ul>
<li><code>babel-eslint</code></li>
<li><code>typescript-eslint</code></li>
</ul>
</li>
</ul>
<h2 id="六、使用jest进行单元测试"><a href="#六、使用jest进行单元测试" class="headerlink" title="六、使用jest进行单元测试"></a>六、使用jest进行单元测试</h2><ul>
<li>单元测试工具<ul>
<li><code>ts-jest</code> – 能够在测试用例中进行类型检查</li>
<li><code>babel-jest</code> – 没有进行类型检查</li>
</ul>
</li>
</ul>
<blockquote>
<p>生成配置文件 <code>ts-jest config:init</code></p>
</blockquote>
<h1 id="第三章-项目实战"><a href="#第三章-项目实战" class="headerlink" title="第三章 项目实战"></a>第三章 项目实战</h1><h2 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、思维导图</h2><p><img src="https://poetries1.gitee.io/img-repo/20190903/1.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/2.png" alt="img"></p>
<h2 id="二、React项目实践"><a href="#二、React项目实践" class="headerlink" title="二、React项目实践"></a>二、React项目实践</h2><h3 id="2-1-手动创建react项目"><a href="#2-1-手动创建react项目" class="headerlink" title="2.1 手动创建react项目"></a>2.1 手动创建react项目</h3><blockquote>
<p>项目代码 <a target="_blank" rel="noopener" href="https://github.com/poetries/typescript-in-action/tree/master/ts-react">https://github.com/poetries/typescript-in-action/tree/master/ts-react</a></p>
</blockquote>
<p><strong>1. 安装依赖文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @types/react @types/react-dom</span><br></pre></td></tr></table></figure>

<p><strong>2. 修改tsconfig.json</strong>配置</p>
<blockquote>
<p>修改 <code>compilerOptions</code>中的<code>jsx</code>为<code>react</code></p>
</blockquote>
<h3 id="2-2-使用脚手架安装"><a href="#2-2-使用脚手架安装" class="headerlink" title="2.2 使用脚手架安装"></a>2.2 使用脚手架安装</h3><blockquote>
<p>项目代码 <a target="_blank" rel="noopener" href="https://github.com/poetries/typescript-in-action/tree/master/ts-react-app">https://github.com/poetries/typescript-in-action/tree/master/ts-react-app</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app ts-react-app --typescript</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-函数组件"><a href="#2-2-1-函数组件" class="headerlink" title="2.2.1 函数组件"></a>2.2.1 函数组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; Button &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    firstName: string;</span><br><span class="line">    lastName: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Hello = (props: Greeting) =&gt; &lt;Button&gt;Hello &#123;props.name&#125;&lt;/Button&gt;</span><br><span class="line"></span><br><span class="line">// const Hello: React.FC&lt;Greeting&gt; = (&#123;</span><br><span class="line">//     name,</span><br><span class="line">//     firstName,</span><br><span class="line">//     lastName,</span><br><span class="line">//     children</span><br><span class="line">// &#125;) =&gt; &lt;Button&gt;Hello &#123;name&#125;&lt;/Button&gt;</span><br><span class="line"></span><br><span class="line">Hello.defaultProps = &#123;</span><br><span class="line">    firstName: &#x27;&#x27;,</span><br><span class="line">    lastName: &#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Hello;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-类组件"><a href="#2-2-2-类组件" class="headerlink" title="2.2.2 类组件"></a>2.2.2 类组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Button &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    firstName?: string;</span><br><span class="line">    lastName?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface HelloState &#123;</span><br><span class="line">    count: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloClass extends Component&lt;Greeting, HelloState&gt; &#123;</span><br><span class="line">    state: HelloState = &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;</span><br><span class="line">    static defaultProps = &#123;</span><br><span class="line">        firstName: &#x27;&#x27;,</span><br><span class="line">        lastName: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;p&gt;你点击了 &#123;this.state.count&#125; 次&lt;/p&gt;</span><br><span class="line">                &lt;Button onClick=&#123;() =&gt; &#123;this.setState(&#123;count: this.state.count + 1&#125;)&#125;&#125;&gt;</span><br><span class="line">                    Hello &#123;this.props.name&#125;</span><br><span class="line">                &lt;/Button&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default HelloClass;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-高阶组件"><a href="#2-2-3-高阶组件" class="headerlink" title="2.2.3 高阶组件"></a>2.2.3 高阶组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">import HelloClass from &#x27;./HelloClass&#x27;;</span><br><span class="line"></span><br><span class="line">interface Loading &#123;</span><br><span class="line">    loading: boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function HelloHOC&lt;P&gt;(WrappedComponent: React.ComponentType&lt;P&gt;) &#123;</span><br><span class="line">    return class extends Component&lt;P &amp; Loading&gt; &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            const &#123; loading, ...props &#125; = this.props;</span><br><span class="line">            return loading ? &lt;div&gt;Loading...&lt;/div&gt; : &lt;WrappedComponent &#123; ...props as P &#125; /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default HelloHOC(HelloClass);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-Hooks组件"><a href="#2-2-4-Hooks组件" class="headerlink" title="2.2.4 Hooks组件"></a>2.2.4 Hooks组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Button &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    firstName: string;</span><br><span class="line">    lastName: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const HelloHooks = (props: Greeting) =&gt; &#123;</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    const [text, setText] = useState&lt;string | null&gt;(null);</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        if (count &gt; 5) &#123;</span><br><span class="line">            setText(&#x27;休息一下&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [count]);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;p&gt;你点击了 &#123;count&#125; 次 &#123;text&#125;&lt;/p&gt;</span><br><span class="line">            &lt;Button onClick=&#123;() =&gt; &#123;setCount(count + 1)&#125;&#125;&gt;</span><br><span class="line">                Hello &#123;props.name&#125;</span><br><span class="line">            &lt;/Button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloHooks.defaultProps = &#123;</span><br><span class="line">    firstName: &#x27;&#x27;,</span><br><span class="line">    lastName: &#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default HelloHooks;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-事件处理与数据请求"><a href="#2-2-5-事件处理与数据请求" class="headerlink" title="2.2.5 事件处理与数据请求"></a>2.2.5 事件处理与数据请求</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Form, Input, Select, Button &#125; from &#x27;antd&#x27;;</span><br><span class="line">import &#123; FormComponentProps &#125; from &#x27;antd/lib/form&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123; get &#125; from &#x27;../../utils/request&#x27;;</span><br><span class="line">import &#123; GET_EMPLOYEE_URL &#125; from &#x27;../../constants/urls&#x27;;</span><br><span class="line">import &#123; EmployeeRequest, EmployeeResponse &#125; from &#x27;../../interface/employee&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Option &#125; = Select;</span><br><span class="line"></span><br><span class="line">interface Props extends FormComponentProps &#123;</span><br><span class="line">    onDataChange(data: EmployeeResponse): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Hooks version</span><br><span class="line">// const QueryFormHooks = (props: Props) =&gt; &#123;</span><br><span class="line">//     const [name, setName] = useState(&#x27;&#x27;);</span><br><span class="line">//     const [departmentId, setDepartmentId] = useState&lt;number | undefined&gt;();</span><br><span class="line"></span><br><span class="line">//     const handleNameChange = (e: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">//         setName(e.currentTarget.value)</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     const handleDepartmentChange = (value: number) =&gt; &#123;</span><br><span class="line">//         setDepartmentId(value)</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     const handleSubmit = () =&gt; &#123;</span><br><span class="line">//         queryEmployee(&#123;name, departmentId&#125;);</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     const queryEmployee = (param: EmployeeRequest) =&gt; &#123;</span><br><span class="line">//         get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">//             props.onDataChange(res.data);</span><br><span class="line">//         &#125;);</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     useEffect(() =&gt; &#123;</span><br><span class="line">//         queryEmployee(&#123;name, departmentId&#125;);</span><br><span class="line">//     &#125;, [])</span><br><span class="line"></span><br><span class="line">//     return (</span><br><span class="line">//         &lt;&gt;</span><br><span class="line">//             &lt;Form layout=&quot;inline&quot;&gt;</span><br><span class="line">//                 &lt;Form.Item&gt;</span><br><span class="line">//                     &lt;Input</span><br><span class="line">//                         placeholder=&quot;姓名&quot;</span><br><span class="line">//                         style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">//                         allowClear</span><br><span class="line">//                         value=&#123;name&#125;</span><br><span class="line">//                         onChange=&#123;handleNameChange&#125;</span><br><span class="line">//                     /&gt;</span><br><span class="line">//                 &lt;/Form.Item&gt;</span><br><span class="line">//                 &lt;Form.Item&gt;</span><br><span class="line">//                 &lt;Select</span><br><span class="line">//                     placeholder=&quot;部门&quot;</span><br><span class="line">//                     style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">//                     allowClear</span><br><span class="line">//                     value=&#123;departmentId&#125;</span><br><span class="line">//                     onChange=&#123;handleDepartmentChange&#125;</span><br><span class="line">//                 &gt;</span><br><span class="line">//                     &lt;Option value=&#123;1&#125;&gt;技术部&lt;/Option&gt;</span><br><span class="line">//                     &lt;Option value=&#123;2&#125;&gt;产品部&lt;/Option&gt;</span><br><span class="line">//                     &lt;Option value=&#123;3&#125;&gt;市场部&lt;/Option&gt;</span><br><span class="line">//                     &lt;Option value=&#123;4&#125;&gt;运营部&lt;/Option&gt;</span><br><span class="line">//                 &lt;/Select&gt;</span><br><span class="line">//                 &lt;/Form.Item&gt;</span><br><span class="line">//                 &lt;Form.Item&gt;</span><br><span class="line">//                     &lt;Button type=&quot;primary&quot; onClick=&#123;handleSubmit&#125;&gt;查询&lt;/Button&gt;</span><br><span class="line">//                 &lt;/Form.Item&gt;</span><br><span class="line">//             &lt;/Form&gt;</span><br><span class="line">//         &lt;/&gt;</span><br><span class="line">//     )</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">class QueryForm extends Component&lt;Props, EmployeeRequest&gt; &#123;</span><br><span class="line">    state: EmployeeRequest = &#123;</span><br><span class="line">        name: &#x27;&#x27;,</span><br><span class="line">        departmentId: undefined</span><br><span class="line">    &#125;</span><br><span class="line">    handleNameChange = (e: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            name: e.currentTarget.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    handleDepartmentChange = (value: number) =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            departmentId: value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    handleSubmit = () =&gt; &#123;</span><br><span class="line">        this.queryEmployee(this.state);</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this.queryEmployee(this.state);</span><br><span class="line">    &#125;</span><br><span class="line">    queryEmployee(param: EmployeeRequest) &#123;</span><br><span class="line">        get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            this.props.onDataChange(res.data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Form layout=&quot;inline&quot;&gt;</span><br><span class="line">                &lt;Form.Item&gt;</span><br><span class="line">                    &lt;Input</span><br><span class="line">                        placeholder=&quot;姓名&quot;</span><br><span class="line">                        style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">                        allowClear</span><br><span class="line">                        value=&#123;this.state.name&#125;</span><br><span class="line">                        onChange=&#123;this.handleNameChange&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                &lt;/Form.Item&gt;</span><br><span class="line">                &lt;Form.Item&gt;</span><br><span class="line">                &lt;Select</span><br><span class="line">                    placeholder=&quot;部门&quot;</span><br><span class="line">                    style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">                    allowClear</span><br><span class="line">                    value=&#123;this.state.departmentId&#125;</span><br><span class="line">                    onChange=&#123;this.handleDepartmentChange&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;Option value=&#123;1&#125;&gt;技术部&lt;/Option&gt;</span><br><span class="line">                    &lt;Option value=&#123;2&#125;&gt;产品部&lt;/Option&gt;</span><br><span class="line">                    &lt;Option value=&#123;3&#125;&gt;市场部&lt;/Option&gt;</span><br><span class="line">                    &lt;Option value=&#123;4&#125;&gt;运营部&lt;/Option&gt;</span><br><span class="line">                &lt;/Select&gt;</span><br><span class="line">                &lt;/Form.Item&gt;</span><br><span class="line">                &lt;Form.Item&gt;</span><br><span class="line">                    &lt;Button type=&quot;primary&quot; onClick=&#123;this.handleSubmit&#125;&gt;查询&lt;/Button&gt;</span><br><span class="line">                &lt;/Form.Item&gt;</span><br><span class="line">            &lt;/Form&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const WrapQueryForm = Form.create&lt;Props&gt;(&#123;</span><br><span class="line">    name: &#x27;employee_query&#x27;</span><br><span class="line">&#125;)(QueryForm);</span><br><span class="line"></span><br><span class="line">export default WrapQueryForm;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-6-列表渲染"><a href="#2-2-6-列表渲染" class="headerlink" title="2.2.6 列表渲染"></a>2.2.6 列表渲染</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Table &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;./index.css&#x27;;</span><br><span class="line"></span><br><span class="line">import QueryForm from &#x27;./QueryForm&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123; employeeColumns &#125; from &#x27;./colums&#x27;;</span><br><span class="line">import &#123; EmployeeResponse &#125; from &#x27;../../interface/employee&#x27;;</span><br><span class="line"></span><br><span class="line">// Hooks version</span><br><span class="line">// const Employee = () =&gt; &#123;</span><br><span class="line">//     const [employee, setEmployee] = useState&lt;EmployeeResponse&gt;(undefined);</span><br><span class="line"></span><br><span class="line">//     const getTotal = () =&gt; &#123;</span><br><span class="line">//         let total: number;</span><br><span class="line">//         if (typeof employee !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">//             total = employee.length</span><br><span class="line">//         &#125; else &#123;</span><br><span class="line">//             total = 0</span><br><span class="line">//         &#125;</span><br><span class="line">//         return &lt;p&gt;共 &#123;total&#125; 名员工&lt;/p&gt;</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     return (</span><br><span class="line">//         &lt;&gt;</span><br><span class="line">//             &lt;QueryForm onDataChange=&#123;setEmployee&#125; /&gt;</span><br><span class="line">//             &#123;/* &#123;getTotal()&#125; */&#125;</span><br><span class="line">//             &lt;Table columns=&#123;employeeColumns&#125; dataSource=&#123;employee&#125; className=&quot;table&quot; /&gt;</span><br><span class="line">//         &lt;/&gt;</span><br><span class="line">//     )</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">interface State &#123;</span><br><span class="line">    employee: EmployeeResponse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Component&lt;&#123;&#125;, State&gt; &#123;</span><br><span class="line">    state: State = &#123;</span><br><span class="line">        employee: undefined</span><br><span class="line">    &#125;</span><br><span class="line">    setEmployee = (employee: EmployeeResponse) =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            employee</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    getTotal() &#123;</span><br><span class="line">        let total: number;</span><br><span class="line">        // 类型保护</span><br><span class="line">        if (typeof this.state.employee !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">            total = this.state.employee.length</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            total = 0</span><br><span class="line">        &#125;</span><br><span class="line">        return &lt;p&gt;共 &#123;total&#125; 名员工&lt;/p&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;QueryForm onDataChange=&#123;this.setEmployee&#125; /&gt;</span><br><span class="line">                &#123;/* &#123;this.getTotal()&#125; */&#125;</span><br><span class="line">                &lt;Table columns=&#123;employeeColumns&#125; dataSource=&#123;this.state.employee&#125; className=&quot;table&quot; /&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Employee;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-7-Redux与类型"><a href="#2-2-7-Redux与类型" class="headerlink" title="2.2.7 Redux与类型"></a>2.2.7 Redux与类型</h4><blockquote>
<p>项目代码 <a target="_blank" rel="noopener" href="https://github.com/poetries/typescript-in-action/tree/master/ts-redux">https://github.com/poetries/typescript-in-action/tree/master/ts-redux</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Dispatch &#125; from &#x27;redux&#x27;;</span><br><span class="line">import _ from &#x27;lodash&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123; get, post &#125; from &#x27;../../utils/request&#x27;;</span><br><span class="line">import &#123; department, level &#125; from &#x27;../../constants/options&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">    GET_EMPLOYEE_URL,</span><br><span class="line">    CREATE_EMPLOYEE_URL,</span><br><span class="line">    DELETE_EMPLOYEE_URL,</span><br><span class="line">    UPDATE_EMPLOYEE_URL</span><br><span class="line">&#125; from &#x27;../../constants/urls&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">    GET_EMPLOYEE,</span><br><span class="line">    CREATE_EMPLOYEE,</span><br><span class="line">    DELETE_EMPLOYEE,</span><br><span class="line">    UPDATE_EMPLOYEE</span><br><span class="line">&#125; from &#x27;../../constants/actions&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">    EmployeeInfo,</span><br><span class="line">    EmployeeRequest,</span><br><span class="line">    EmployeeResponse,</span><br><span class="line">    CreateRequest,</span><br><span class="line">    DeleteRequest,</span><br><span class="line">    UpdateRequest</span><br><span class="line">&#125; from &#x27;../../interface/employee&#x27;;</span><br><span class="line"></span><br><span class="line">type State = Readonly&lt;&#123;</span><br><span class="line">    employeeList: EmployeeResponse</span><br><span class="line">&#125;&gt;</span><br><span class="line"></span><br><span class="line">type Action = &#123;</span><br><span class="line">    type: string;</span><br><span class="line">    payload: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const initialState: State = &#123;</span><br><span class="line">    employeeList: undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function getEmployee(param: EmployeeRequest, callback: () =&gt; void) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: GET_EMPLOYEE,</span><br><span class="line">                payload: res.data</span><br><span class="line">            &#125;);</span><br><span class="line">            callback();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function createEmployee(param: CreateRequest, callback: () =&gt; void) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        post(CREATE_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: CREATE_EMPLOYEE,</span><br><span class="line">                payload: &#123;</span><br><span class="line">                    name: param.name,</span><br><span class="line">                    department: department[param.departmentId],</span><br><span class="line">                    departmentId: param.departmentId,</span><br><span class="line">                    hiredate: param.hiredate,</span><br><span class="line">                    level: level[param.levelId],</span><br><span class="line">                    levelId: param.levelId,</span><br><span class="line">                    ...res.data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            callback();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function deleteEmployee(param: DeleteRequest) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        post(DELETE_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: DELETE_EMPLOYEE,</span><br><span class="line">                payload: param.id</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function updateEmployee(param: UpdateRequest, callback: () =&gt; void) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        post(UPDATE_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: UPDATE_EMPLOYEE,</span><br><span class="line">                payload: param</span><br><span class="line">            &#125;);</span><br><span class="line">            callback();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function(state = initialState, action: Action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case GET_EMPLOYEE:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: action.payload</span><br><span class="line">            &#125;</span><br><span class="line">        case CREATE_EMPLOYEE:</span><br><span class="line">            let newList = [action.payload, ...(state.employeeList as EmployeeInfo[])]</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: newList</span><br><span class="line">            &#125;</span><br><span class="line">        case DELETE_EMPLOYEE:</span><br><span class="line">            let reducedList = [...(state.employeeList as EmployeeInfo[])];</span><br><span class="line">            _.remove(reducedList, (item: EmployeeInfo) =&gt; &#123;</span><br><span class="line">                return item.id === action.payload</span><br><span class="line">            &#125;);</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: reducedList</span><br><span class="line">            &#125;</span><br><span class="line">        case UPDATE_EMPLOYEE:</span><br><span class="line">            let updatedList = [...(state.employeeList as EmployeeInfo[])];</span><br><span class="line">            let item: UpdateRequest = action.payload;</span><br><span class="line">            let index = _.findIndex(updatedList, &#123;</span><br><span class="line">                id: item.id</span><br><span class="line">            &#125;);</span><br><span class="line">            updatedList[index] = &#123;</span><br><span class="line">                id: item.id,</span><br><span class="line">                key: item.id,</span><br><span class="line">                name: item.name,</span><br><span class="line">                department: department[item.departmentId],</span><br><span class="line">                departmentId: item.departmentId,</span><br><span class="line">                hiredate: item.hiredate,</span><br><span class="line">                level: level[item.levelId],</span><br><span class="line">                levelId: item.levelId</span><br><span class="line">            &#125;</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: updatedList</span><br><span class="line">            &#125;</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-服务端使用Typescript"><a href="#2-3-服务端使用Typescript" class="headerlink" title="2.3 服务端使用Typescript"></a>2.3 服务端使用Typescript</h3><blockquote>
<p>项目地址 <a target="_blank" rel="noopener" href="https://github.com/poetries/typescript-in-action/tree/master/ts-express">https://github.com/poetries/typescript-in-action/tree/master/ts-express</a></p>
</blockquote>
<h2 id="三、Vue项目实践"><a href="#三、Vue项目实践" class="headerlink" title="三、Vue项目实践"></a>三、Vue项目实践</h2><blockquote>
<p>项目代码 <a target="_blank" rel="noopener" href="https://github.com/poetries/typescript-in-action/tree/master/ts-vue">https://github.com/poetries/typescript-in-action/tree/master/ts-vue</a></p>
</blockquote>
<blockquote>
<p>TS不能识别<code>.vue</code>文件，需要声明文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// vue-shims.d.ts</span><br><span class="line"></span><br><span class="line">declare module &#x27;*.vue&#x27; &#123;</span><br><span class="line">    import Vue from &#x27;vue&#x27;</span><br><span class="line">    export default Vue</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/poetries/poetries.github.io/edit/dev/source/_posts/ts-in-action.md">原文地址</a></p>
</blockquote>
<h1 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://blog.poetries.top/ts-axios/chapter1/">TypeScript 从零实现 axios</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.poetries.top/2018/12/29/ts-intro-and-use-in-react/">Typescript基础及结合React实践(一)</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.poetries.top/2018/12/30/ts-summary/">Typescript总结篇（二）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.poetries.top/2018/12/31/ts-react-template/">Typescript+React模板搭建（三）</a></li>
</ul>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/08/15/html+css+js+ts/5-Typescript%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%5B%E5%9F%BA%E7%A1%80+%E5%B7%A5%E7%A8%8B+%E5%AE%9E%E8%B7%B5%5D/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-Typescript基础总结">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/08/03/html+css+js+ts/5-Typescript%E5%9F%BA%E7%A1%80/">Typescript基础总结</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-08-03
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/typescript/" class="cube-excerpt-tag-link">#typescript</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、typescript-安装"><a href="#一、typescript-安装" class="headerlink" title="一、typescript 安装"></a>一、typescript 安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局安装完成后，我们新建一个<code>hello.ts</code>的<code>ts</code>文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.ts内容</span><br><span class="line">let a = &quot;poet&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来我们在命令行输入<code>tsc hello.ts</code>来编译这个<code>ts</code>文件，然后会在同级目录生成一个编译好了的<code>hello.js</code>文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.js内容</span><br><span class="line">var = &quot;poet&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么我们每次都要输<code>tsc hello.ts</code>命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，使用<code>vscode</code>来开发，需要配置一下<code>vscode</code>就可以。</p>
</blockquote>
<blockquote>
<p>首先我们在命令行执行<code>tsc --init</code>来生成配置文件，然后我们在目录下看到生成了一个<code>tsconfig.json</code>文件</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/545.png" alt="img"></p>
<blockquote>
<p>这个<code>json</code>文件里有很多选项</p>
</blockquote>
<ul>
<li><code>target</code>是选择编译到什么语法</li>
<li><code>module</code>则是模块类型</li>
<li><code>outDir</code>则是输出目录，可以指定这个参数到指定目录</li>
</ul>
<blockquote>
<p>更多细节 <a target="_blank" rel="noopener" href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html</a></p>
</blockquote>
<blockquote>
<p>接下来我们需要开启监控了，在<code>vscode</code>任务栏中</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/546.png" alt="img"></p>
<p><strong>Typescript在线编辑器</strong></p>
<blockquote>
<p>建议使用在线编辑器练习 <a target="_blank" rel="noopener" href="http://www.typescriptlang.org/play/index.html">http://www.typescriptlang.org/play/index.html</a></p>
</blockquote>
<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><blockquote>
<p><code>js</code>是弱类型语言，强弱类语言有什么区别呢？<code>typescript</code>最大的优点就是类型检查，可以帮你检查你定义的类型和赋值的类型。</p>
</blockquote>
<h3 id="2-1-布尔类型boolean"><a href="#2-1-布尔类型boolean" class="headerlink" title="2.1 布尔类型boolean"></a>2.1 布尔类型boolean</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 在js中，定义isFlag为true，为布尔类型boolean</span><br><span class="line">let isFlag = true;</span><br><span class="line">// 但是我们也可以重新给它赋值为字符串</span><br><span class="line">isFlag = &quot;hello swr&quot;;</span><br><span class="line"></span><br><span class="line">// 在ts中，定义isFlag为true，为布尔类型boolean</span><br><span class="line">// 在变量名后加冒号和类型，如  :boolean</span><br><span class="line">let isFlag:boolean = true</span><br><span class="line">// 重新赋值到字符串类型会报错</span><br><span class="line">isFlag = &quot;hello swr&quot; </span><br><span class="line"></span><br><span class="line">// 在java中，一般是这样定义，要写变量名也要写类型名</span><br><span class="line">// int a = 10; </span><br><span class="line">// string name = &quot;poetries&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-数字类型number"><a href="#2-2-数字类型number" class="headerlink" title="2.2 数字类型number"></a>2.2 数字类型number</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let age:number = 28;</span><br><span class="line">age = 29;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-字符串类型string"><a href="#2-3-字符串类型string" class="headerlink" title="2.3 字符串类型string"></a>2.3 字符串类型string</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name:string = &quot;poetries&quot;</span><br><span class="line">name = &quot;iamswr&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上<code>boolean</code>、<code>number</code>、<code>string</code>类型有个共性，就是可以通过<code>typeof</code>来获取到是什么类型，是基本数据类型</p>
</blockquote>
<p>那么复杂的数据类型是怎么处理的呢？</p>
<h3 id="2-4-数组-Array"><a href="#2-4-数组-Array" class="headerlink" title="2.4 数组 Array"></a>2.4 数组 Array</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 数组</span><br><span class="line">// 这是一个字符串数组，只能往里面放字符串，写别的类型会报错</span><br><span class="line">let persion:string[] = [&#x27;poetries&#x27;, &#x27;jing&#x27;]</span><br><span class="line">// 另一个写法 </span><br><span class="line">let persions:Array&lt;string&gt; = [&#x27;poetries&#x27;, &#x27;jing&#x27;]</span><br><span class="line"></span><br><span class="line">// 如果数组里放对象呢</span><br><span class="line">let persionObject:Array&lt;object&gt; = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]</span><br><span class="line">let persionObjects:object[] = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]</span><br><span class="line"></span><br><span class="line">// 在数组中放string、number、boolean、object</span><br><span class="line">let arr:Array&lt;number|object|string|boolean&gt; = [22, &#x27;test&#x27;, true, &#123;name:&#x27;poetries&#x27;&#125;]</span><br><span class="line"></span><br><span class="line">// 数组中放什么都可以</span><br><span class="line">let arrAny:Array&lt;any&gt; = [&#x27;test&#x27;,12,false]</span><br></pre></td></tr></table></figure>

<h3 id="2-5-元组类型tuple"><a href="#2-5-元组类型tuple" class="headerlink" title="2.5 元组类型tuple"></a>2.5 元组类型tuple</h3><ul>
<li>什么是元组类型？其实元组是数组的一种。</li>
<li>有点类似解构赋值，但是又不完全是解构赋值，比如元组类型必须一一对应上</li>
<li>元组类型是一个不可变的数组，长度、类型是不可变的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 元组类型tuple</span><br><span class="line">// 什么是元组类型？其实元组是数组的一种</span><br><span class="line">let per :[string,number,object] = [&#x27;poetries&#x27;,22,&#123;love: &#x27;coding&#x27;&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="2-6-枚举类型enum"><a href="#2-6-枚举类型enum" class="headerlink" title="2.6 枚举类型enum"></a>2.6 枚举类型enum</h3><blockquote>
<p>什么是枚举？枚举有点类似一一列举，一个一个数出来。一般用于值是某几个固定的值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 枚举类型enum</span><br><span class="line"></span><br><span class="line">enum sex &#123;</span><br><span class="line">    BOY=&#x27;男孩&#x27;,</span><br><span class="line">    GIRL=&#x27;女孩&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sex)</span><br><span class="line">// 转化为es5语法</span><br><span class="line">// 我们顺便看看实现的原理</span><br><span class="line"></span><br><span class="line">var sex;</span><br><span class="line">(function (sex) &#123;</span><br><span class="line">// 首先这里是一个自执行函数</span><br><span class="line">// 并且把sex定义为对象，传参进给自执行函数</span><br><span class="line">// 然后给sex对象添加属性并且赋值</span><br><span class="line">    sex[&quot;BOY&quot;] = &quot;\u7537\u5B69&quot;;</span><br><span class="line">    sex[&quot;GIRL&quot;] = &quot;\u5973\u5B69&quot;;</span><br><span class="line">&#125;)(sex || (sex = &#123;&#125;));</span><br><span class="line">console.log(sex);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>比如我们实际项目中，特别是商城类，订单会存在很多状态流转，那么非常适合用枚举</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum orderStatus &#123;</span><br><span class="line">    WAIT_FOR_PAY = &quot;待支付&quot;,</span><br><span class="line">    UNDELIVERED = &quot;完成支付，待发货&quot;,</span><br><span class="line">    DELIVERED = &quot;已发货&quot;,</span><br><span class="line">    COMPLETED = &quot;已确认收货&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这里，我们会有一个疑虑，为什么我们不这样写呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let orderStatus2 = &#123;</span><br><span class="line">    WAIT_FOR_PAY : &quot;待支付&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们直接写对象的键值对方式，是可以在外部修改这个值的，而我们通过<code>enum</code>则不能修改定义好的值了</p>
</blockquote>
<h3 id="2-7-任意类型-any"><a href="#2-7-任意类型-any" class="headerlink" title="2.7 任意类型 any"></a>2.7 任意类型 any</h3><blockquote>
<p><code>any</code>有好处也有坏处，特别是前端，很多时候写类型的时候，几乎分不清楚类型，任意去写，写起来很爽，但是对于后续的重构、迭代等是非常不友好的，会暴露出很多问题，某种程度来说，<code>any</code>类型就是放弃了类型检查了</p>
</blockquote>
<p>比如我们有这样一个场景，就是需要获取某一个dom节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">btn.style.color = &quot;blue&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时我们发现在<code>ts</code>中会报错</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/547.png" alt="img"></p>
<ul>
<li>因为我们取这个<code>dom</code>节点，有可能取到，也有可能没取到，当没取到的时候，相当于是<code>null</code>，是没有<code>style</code>这个属性的。</li>
<li>那么我们可以给它添加一个类型为<code>any</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 添加一个any类型，此时就不会报错了，但是也相当于放弃了类型检查了</span><br><span class="line">let btn:any = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">btn.style.color = &quot;blue&quot;;</span><br><span class="line">// 可以赋值任何类型的值</span><br><span class="line">// 跟以前我们var let声明的一模一样的</span><br><span class="line">let person:any = &quot;poetries&quot;</span><br><span class="line">person = 22</span><br></pre></td></tr></table></figure>

<h3 id="2-8-null-undefined类型"><a href="#2-8-null-undefined类型" class="headerlink" title="2.8 null undefined类型"></a>2.8 null undefined类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// (string | number | null | undefined) 相当于这几种类型</span><br><span class="line">// 是 string 或 number 或 null 或 undefined</span><br><span class="line"></span><br><span class="line">let str:(string | number | null | undefined)</span><br><span class="line"></span><br><span class="line">str = &#x27;poetries&#x27;</span><br><span class="line">str = 28</span><br><span class="line">str = null </span><br><span class="line">str = undefined</span><br></pre></td></tr></table></figure>

<h3 id="2-9-void类型"><a href="#2-9-void类型" class="headerlink" title="2.9 void类型"></a>2.9 void类型</h3><blockquote>
<p><code>void</code>表示没有任何类型，一般是定义函数没有返回值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// void 不能再函数里写return</span><br><span class="line">// 怎么理解叫没有返回值呢？此时我们给函数return一个值</span><br><span class="line">function say(name:string):void&#123;</span><br><span class="line">    console.log(&#x27;hello:&#x27;, name)</span><br><span class="line">    // return &quot;ok&quot; 会报错</span><br><span class="line">    return undefined;</span><br><span class="line">    return //不会报错</span><br><span class="line">&#125;</span><br><span class="line">say(&#x27;poetries&#x27;)</span><br><span class="line"></span><br><span class="line">// 返回一个字符串类型</span><br><span class="line">function say1(name:string):string &#123;</span><br><span class="line">    return &#x27;ok&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-10-never类型"><a href="#2-10-never类型" class="headerlink" title="2.10 never类型"></a>2.10 never类型</h3><blockquote>
<p>这个用得很少，一般是用于抛出异常</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function error(message:string):never &#123;</span><br><span class="line">    throw new Error(message)</span><br><span class="line">&#125;</span><br><span class="line">error(&#x27;errorMsg&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="2-11-我们要搞明白any、never、void"><a href="#2-11-我们要搞明白any、never、void" class="headerlink" title="2.11 我们要搞明白any、never、void"></a>2.11 我们要搞明白any、never、void</h3><ul>
<li><code>any</code>是任意的值</li>
<li><code>void</code>是不能有任何值</li>
<li><code>never</code>永远不会有返回值</li>
</ul>
<blockquote>
<p><code>any</code>比较好理解，就是任何值都可以</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str:any = &quot;hello poetries&quot;</span><br><span class="line">str = 28</span><br><span class="line">str = true</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>void</code>不能有任何值(返回值)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function say():void &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>never</code>则不好理解，什么叫永远不会有返回值？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 除了上面举例的抛出异常以外，我们看一下这个例子</span><br><span class="line">// 这个loop函数，一旦开始执行，就永远不会结束</span><br><span class="line">// 可以看出在while中，是死循环，永远都不会有返回值，包括undefined</span><br><span class="line"></span><br><span class="line">function loop():never &#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        console.log(&quot;陷入死循环啦&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop()</span><br><span class="line"></span><br><span class="line">// 包括比如JSON.parse也是使用这种 never | any</span><br><span class="line">function parse(str:string):(never | any)&#123;</span><br><span class="line">    return JSON.parse(str)</span><br><span class="line">&#125;</span><br><span class="line">// 首先在正常情况下，我们传一个JSON格式的字符串，是可以正常得到一个JSON对象的</span><br><span class="line">let json = parse(&#x27;&#123;&quot;name&quot;:&quot;poetries&quot;&#125;&#x27;)</span><br><span class="line">// 但是有时候，传进去的不一定是JSON格式的字符串，那么就会抛出异常</span><br><span class="line">// 此时就需要never了</span><br><span class="line">let json = parse(&quot;iamswr&quot;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也就是说，当一个函数执行的时候，被抛出异常打断了，导致没有返回值或者该函数是一个死循环，永远没有返回值，这样叫做永远不会有返回值。</p>
</blockquote>
<p>实际开发中，是<code>never</code>和联合类型来一起用，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function say():(never | string) &#123;</span><br><span class="line">  return &quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><h3 id="3-1-函数定义"><a href="#3-1-函数定义" class="headerlink" title="3.1 函数定义"></a>3.1 函数定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(name:string):void &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-函数参数处理"><a href="#3-2-函数参数处理" class="headerlink" title="3.2 函数参数处理"></a>3.2 函数参数处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数是这样定义的</span><br><span class="line">// 形参和实参一一对应，完全一样</span><br><span class="line">function sayHello(name:string,age:number):void &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;, name, age)</span><br><span class="line">&#125;</span><br><span class="line">sayHello(&#x27;poetries&#x27;,22)</span><br><span class="line"></span><br><span class="line">// 形参和实参要完全一样，如想不一样，则需要配置可选参数，可选参数放在后面</span><br><span class="line">// 可选参数，用 ？ 处理，只能放在后面</span><br><span class="line">function sayHelloToYou(name:string,age?:number):void &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;, name, age)</span><br><span class="line">&#125;</span><br><span class="line">sayHelloToYou(&#x27;poetries&#x27;)</span><br><span class="line"></span><br><span class="line">// 那么如何设置默认参数呢？</span><br><span class="line"></span><br><span class="line">function ajax(url:string,method:string = &#x27;GET&#x27;) &#123;</span><br><span class="line">    console.log(url, method)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 那么如何设置剩余参数呢？可以利用扩展运算符</span><br><span class="line"></span><br><span class="line">function sum(...args:Array&lt;number&gt;):number &#123;</span><br><span class="line">    return eval(args.join(&quot;+&quot;))</span><br><span class="line">&#125;</span><br><span class="line">let total:number = sum(1,2,3,4,5)</span><br><span class="line">console.log(total)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 那么如何实现函数重载呢？函数重载是java中非常有名的，在java中函数的重载，是指两个或者两个以上的同名函数，参数的个数和类型不一样</span><br><span class="line"></span><br><span class="line">// 比如我们现在有两个同名函数</span><br><span class="line">// function eating(name:string) &#123;</span><br><span class="line">    </span><br><span class="line">// &#125;</span><br><span class="line">// function eating(name:string,age:number) &#123;</span><br><span class="line">    </span><br><span class="line">// &#125;</span><br><span class="line">// 那么我想达到一个效果</span><br><span class="line">// 当我传参数name时，执行name:string这个函数</span><br><span class="line">// 当我传参数name和age时，执行name:string,age:number这个函数</span><br><span class="line">// 此时该怎么办？</span><br><span class="line"></span><br><span class="line">// 接下来看一下typescript中的函数重载</span><br><span class="line"></span><br><span class="line">// 首先声明两个函数名一样的函数</span><br><span class="line">function eating(name: string):void;</span><br><span class="line">function eating(name: number):void;</span><br><span class="line"></span><br><span class="line">function eating(name:any): void &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eating(&quot;hello poetries&quot;)</span><br><span class="line">eating(22)</span><br><span class="line"></span><br><span class="line">// 在typescript中主要体现是同一个同名函数提供多个函数类型定义，函数实际上就只有一个，就是拥有函数体那个，如果想根据传入值类型的不一样执行不同逻辑，则需要在这个函数里面进行一个类型判断。</span><br><span class="line"></span><br><span class="line">// 那么这个函数重载有什么作用呢？其实在ts中，函数重载只是用来限制参数的个数和类型，用来检查类型的，而且重载不能拆开几个函数，这一点和java的处理是不一样的，需要注意。</span><br></pre></td></tr></table></figure>

<h2 id="四、类"><a href="#四、类" class="headerlink" title="四、类"></a>四、类</h2><h3 id="4-1-定义一个类"><a href="#4-1-定义一个类" class="headerlink" title="4.1 定义一个类"></a>4.1 定义一个类</h3><blockquote>
<p>如何定义一个类？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// ts 写法</span><br><span class="line">// 跟es6非常像 没有太大区别</span><br><span class="line">class Persion &#123;</span><br><span class="line">    // 这里声明的变量 是实例上的属性</span><br><span class="line">    name: string;</span><br><span class="line">    age:number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        // this.name和this.age 必须先在前面声明好类型</span><br><span class="line">        // name: string</span><br><span class="line">        // age: number</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 原型方法</span><br><span class="line">    say():string &#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Persion(&#x27;poetries&#x27;, 22)</span><br><span class="line">// 那么转为es5呢？</span><br><span class="line"></span><br><span class="line">var Persion = /** @class */ (function () &#123;</span><br><span class="line">    function Persion(name, age) &#123;</span><br><span class="line">        // this.name和this.age 必须先在前面声明好类型</span><br><span class="line">        // name: string</span><br><span class="line">        // age: number</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 原型方法</span><br><span class="line">    Persion.prototype.say = function () &#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;;</span><br><span class="line">    &#125;;</span><br><span class="line">    return Persion;</span><br><span class="line">&#125;());</span><br><span class="line">var p = new Persion(&#x27;poetries&#x27;, 22);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-类的继承"><a href="#4-2-类的继承" class="headerlink" title="4.2 类的继承"></a>4.2 类的继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 和es6也是差不多</span><br><span class="line">class Parent &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    constructor(name:string, age: number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    say():string&#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    childName: string;</span><br><span class="line">    constructor(name: string,age:number,childName:string) &#123;</span><br><span class="line">        super(name,age)</span><br><span class="line">        this.childName = childName</span><br><span class="line">    &#125;</span><br><span class="line">    childSay():string &#123;</span><br><span class="line">        return this.childName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let child = new Child(&#x27;poetries&#x27;, 22, &#x27;静观流叶&#x27;)</span><br><span class="line">console.log(child)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-类的修饰符"><a href="#4-3-类的修饰符" class="headerlink" title="4.3 类的修饰符"></a>4.3 类的修饰符</h3><ul>
<li><code>public</code>公开的，可以供自己、子类以及其它类访问</li>
<li><code>protected</code>受保护的，可以供自己、子类访问，但是其他就访问不了</li>
<li><code>private</code>私有的，只有自己访问，而子类、其他都访问不了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Parents &#123;</span><br><span class="line">    public name:string;</span><br><span class="line">    protected age:number;</span><br><span class="line">    private money:number;</span><br><span class="line"></span><br><span class="line">   // 简写</span><br><span class="line">   // constructor(public name:string,protected age:number,private money:number)</span><br><span class="line"></span><br><span class="line">   constructor(name: string, age:number,money:number) &#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">       this.age = age;</span><br><span class="line">       this.money = money;</span><br><span class="line">   &#125;</span><br><span class="line">   getName():string &#123;</span><br><span class="line">       return this.name</span><br><span class="line">   &#125;</span><br><span class="line">   getAge():number&#123;</span><br><span class="line">       return this.age</span><br><span class="line">   &#125;</span><br><span class="line">   getMoney():number&#123;</span><br><span class="line">       return this.money</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">let pare = new Parents(&#x27;poetries&#x27;, 22, 3000)</span><br><span class="line">console.log(pare.name)</span><br><span class="line">// console.log(pare.age)  报错</span><br><span class="line">// console.log(pare.money) 报错</span><br></pre></td></tr></table></figure>

<h3 id="4-4-静态属性、静态方法"><a href="#4-4-静态属性、静态方法" class="headerlink" title="4.4 静态属性、静态方法"></a>4.4 静态属性、静态方法</h3><p>跟<code>es6</code>差不多</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person2 &#123;</span><br><span class="line">    // 类的静态属性</span><br><span class="line">    static name1 = &#x27;poetries&#x27;</span><br><span class="line"></span><br><span class="line">    // 类的静态方法</span><br><span class="line">    static say() &#123;</span><br><span class="line">        console.log(&#x27;hello poetries&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let per2 = new Person2()</span><br><span class="line">Person2.say() // hello poetries</span><br><span class="line">// per2.say() 报错</span><br></pre></td></tr></table></figure>

<h3 id="4-5-抽象类"><a href="#4-5-抽象类" class="headerlink" title="4.5 抽象类"></a>4.5 抽象类</h3><ul>
<li>抽象类和方法，有点类似抽取共性出来，但是又不是具体化，比如说，世界上的动物都需要吃东西，那么会把吃东西这个行为，抽象出来</li>
<li>如果子类继承的是一个抽象类，子类必须实现父类里的抽象方法，不然的话不能实例化，会报错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/ 关键字 abstract抽象</span><br><span class="line">// 定义抽象类</span><br><span class="line"></span><br><span class="line">abstract class Animal &#123;</span><br><span class="line">    // 实际上是使用了public修饰符</span><br><span class="line">    // 如果添加private修饰符会报错</span><br><span class="line">    abstract eat():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要注意的是这个Animal是不能实例化的</span><br><span class="line">// let animal = new Animal() // 报错</span><br><span class="line"></span><br><span class="line">// // 抽象类的抽象方法，意思就是，需要在继承这个抽象类的子类中</span><br><span class="line">// 实现这个抽象方法，不然会报错</span><br><span class="line">// 报错，因为在子类中没有实现eat抽象方法</span><br><span class="line">// class Person4 extends Animal&#123;</span><br><span class="line">//     test()&#123;</span><br><span class="line">//         console.log(&quot;吃米饭&quot;)</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// Dog类继承Animal类后并且实现了抽象方法eat，所以不会报错</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&quot;吃骨头&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、接口"><a href="#五、接口" class="headerlink" title="五、接口"></a>五、接口</h2><blockquote>
<p>这里的接口，主要是一种规范，规范某些类必须遵守规范，和抽象类有点类似，但是不局限于类，还有属性、函数等</p>
</blockquote>
<h3 id="5-1-接口规范对象"><a href="#5-1-接口规范对象" class="headerlink" title="5.1 接口规范对象"></a>5.1 接口规范对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//假设我们需要获取用户信息</span><br><span class="line">// 我们通过这样的方式 规范必须传name和age的值</span><br><span class="line">function getUserInfo(user:&#123;name:string,age:number&#125;) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo(&#123;name: &#x27;poetries&#x27;, age: 22&#125;)</span><br><span class="line"></span><br><span class="line">// 这样看挺完美的， 那么问题就出现了，如果我另外还有一个方法，也是需要这个规范呢？</span><br><span class="line"></span><br><span class="line">function getUserInfo1(user:&#123;name:string,age:number&#125;)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo(user:&#123;name:string,age:number&#125;)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo1(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line">getInfo(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line"></span><br><span class="line">// 可以看出，函数getUserInfo和getInfo都遵循同一个规范，那么我们有办法对这个规范复用吗？</span><br><span class="line"></span><br><span class="line">// 首先把需要复用的规范，写到接口 关键字interface</span><br><span class="line">interface infoInterface &#123;</span><br><span class="line">    name: string,</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">// 然后把这个接口 替换到我们需要复用的地方</span><br><span class="line">function getUserInfo2(user:infoInterface) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo2(user:infoInterface) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInfo2(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line">getInfo2(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line"></span><br><span class="line">// 那么有些参数可传可不传，该怎么处理呢？</span><br><span class="line"></span><br><span class="line">interface infoInterface2&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    city?:string;</span><br><span class="line">&#125;</span><br><span class="line">function getUserInfo3(user:infoInterface2)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125; $&#123;user.city&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo3(user:infoInterface)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo3(&#123;name:&quot;poetries&quot;,age:22,city:&quot;深圳&quot;&#125;)</span><br><span class="line">getInfo3(&#123;name:&quot;iamswr&quot;,age:22&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-接口规范函数"><a href="#5-2-接口规范函数" class="headerlink" title="5.2 接口规范函数"></a>5.2 接口规范函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 对一个函数的参数和返回值进行规范</span><br><span class="line">interface mytotal &#123;</span><br><span class="line">    // 左侧是函数的参数，右侧是函数的返回类型</span><br><span class="line">    (a:number,b:number):number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let totalSum:mytotal = function(a:number,b:number):number &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(totalSum(10, 20))</span><br></pre></td></tr></table></figure>

<h3 id="5-3-接口规范数组"><a href="#5-3-接口规范数组" class="headerlink" title="5.3 接口规范数组"></a>5.3 接口规范数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface userInterface &#123;</span><br><span class="line">    // index为数组索引 类型是number</span><br><span class="line">    // 右边是数组里为字符串的数组成员</span><br><span class="line">    [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line">let arrTest: userInterface = [&#x27;poetries&#x27;, &#x27;静观流叶&#x27;]</span><br><span class="line"></span><br><span class="line">console.log(arrTest)</span><br></pre></td></tr></table></figure>

<h3 id="5-4-接口规范类"><a href="#5-4-接口规范类" class="headerlink" title="5.4 接口规范类"></a>5.4 接口规范类</h3><blockquote>
<p>这个比较重要，因为写<code>react</code>的时候会经常使用到类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 首先实现一个接口</span><br><span class="line">interface Animal2 &#123;</span><br><span class="line">    // 这个类必须有name</span><br><span class="line">    name:string;</span><br><span class="line"></span><br><span class="line">    // 这个类必须有eat方法</span><br><span class="line">    eat(any:string):void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关键字implements实现</span><br><span class="line">// 因为接口是抽象的，需要通过子类是实现它</span><br><span class="line"></span><br><span class="line">class Person6 implements Animal2 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string):void &#123;</span><br><span class="line">        console.log(`吃`+any)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果想遵循多个接口</span><br><span class="line"></span><br><span class="line">interface Animal3 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    eat(any: string):void;</span><br><span class="line">&#125;</span><br><span class="line">// 新增一个接口</span><br><span class="line">interface Animal4 &#123;</span><br><span class="line">    sleep():void;</span><br><span class="line">&#125;</span><br><span class="line">// 可以在implements后面通过逗号添加和java一样</span><br><span class="line">class Person7 implements Animal3,Animal4 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string) &#123;</span><br><span class="line">        console.log(`吃`+any)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep() &#123;</span><br><span class="line">        console.log(&#x27;睡觉&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-接口继承接口"><a href="#5-5-接口继承接口" class="headerlink" title="5.5 接口继承接口"></a>5.5 接口继承接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface Animal5&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    eat(any:string):void;</span><br><span class="line">&#125;</span><br><span class="line">// 像类一样 通过extends继承</span><br><span class="line">interface Animal6 extends Animal5 &#123;</span><br><span class="line">    sleep():void;</span><br><span class="line">&#125;</span><br><span class="line">// 因为Animal6类继承了Animal5</span><br><span class="line">// 所以这里遵循Animal6就相当于把Animal5也继承了</span><br><span class="line"></span><br><span class="line">class Person8 implements Animal2 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name:string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string):void&#123;</span><br><span class="line">        console.log(`吃$&#123;any&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep()&#123;</span><br><span class="line">        console.log(&#x27;睡觉&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a>六、泛型</h2><h3 id="6-1-函数的泛型"><a href="#6-1-函数的泛型" class="headerlink" title="6.1 函数的泛型"></a>6.1 函数的泛型</h3><blockquote>
<p>泛型可以支持不特定的数据类型，什么叫不特定呢？比如我们有一个方法，里面接收参数，但是参数类型我们是不知道，但是这个类型在方法里面很多地方会用到，参数和返回值要保持一致性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 假设我们有一个需求，我们不知道函数接收什么类型的参数，也不知道返回值的类型</span><br><span class="line">// 而我们又需要传进去的参数类型和返回值的类型保持一致，那么我们就需要用到泛型</span><br><span class="line"></span><br><span class="line">// &lt;T&gt;的意思是泛型，即generic type</span><br><span class="line">// 可以看出value的类型也为T，返回值的类型也为T</span><br><span class="line">function deal&lt;T&gt;(value:T):T&#123;</span><br><span class="line">    return value</span><br><span class="line">&#125;</span><br><span class="line">// 下面的&lt;string&gt;、&lt;number&gt;实际上用的时候再传给上面的&lt;T&gt;</span><br><span class="line">console.log(deal&lt;string&gt;(&quot;poetries&quot;))</span><br><span class="line">console.log(deal&lt;number&gt;(22))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的</p>
</blockquote>
<h3 id="6-2-类的泛型"><a href="#6-2-类的泛型" class="headerlink" title="6.2 类的泛型"></a>6.2 类的泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyMath&lt;T&gt; &#123;</span><br><span class="line">    // 定义一个私有属性</span><br><span class="line"></span><br><span class="line">    private arr: T[] = []</span><br><span class="line"></span><br><span class="line">    // 规定传参类型</span><br><span class="line">    add(value: T) &#123;</span><br><span class="line">        this.arr.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这里规定了类型为number</span><br><span class="line">// 相当于把T替换为number</span><br><span class="line"></span><br><span class="line">let mymath = new MyMath&lt;number&gt;()</span><br><span class="line">mymath.add(1)</span><br><span class="line">mymath.add(2)</span><br><span class="line">mymath.add(3)</span><br></pre></td></tr></table></figure>

<p><strong>有了接口为什么还需要抽象类？</strong></p>
<blockquote>
<p>接口里面只能放定义，抽象类里面可以放普通类、普通类的方法、定义抽象的东西。</p>
</blockquote>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/08/03/html+css+js+ts/5-Typescript%E5%9F%BA%E7%A1%80/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-TS-interface与type区别">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/07/25/html+css+js+ts/5-Ts-interface%E4%B8%8Etype%E5%8C%BA%E5%88%AB/">TS-interface与type区别</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-07-25
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/typescript/" class="cube-excerpt-tag-link">#typescript</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h2><h3 id="都可以描述一个对象或者函数"><a href="#都可以描述一个对象或者函数" class="headerlink" title="都可以描述一个对象或者函数"></a>都可以描述一个对象或者函数</h3><p><strong>interface</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SetUser &#123;</span><br><span class="line">  (name: string, age: number): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type SetUser = (name: string, age: number)=&gt; void;</span><br></pre></td></tr></table></figure>

<h3 id="都允许拓展（extends）"><a href="#都允许拓展（extends）" class="headerlink" title="都允许拓展（extends）"></a>都允许拓展（extends）</h3><blockquote>
<p><code>interface</code> 和 <code>type</code> 都可以拓展，并且两者并不是相互独立的，也就是说 <code>interface</code> 可以 <code>extends type</code>, <code>type</code> 也可以 <code>extends interface</code> 。 虽然效果差不多，但是两者语法不同</p>
</blockquote>
<p><strong>interface extends interface</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type extends type</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; age: number  &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>interface extends type</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type extends interface</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><h3 id="type-可以而-interface-不行"><a href="#type-可以而-interface-不行" class="headerlink" title="type 可以而 interface 不行"></a>type 可以而 interface 不行</h3><blockquote>
<p>type 可以声明基本类型别名，联合类型，元组等类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型别名</span><br><span class="line">type Name = string</span><br><span class="line"></span><br><span class="line">// 联合类型</span><br><span class="line">interface Dog &#123;</span><br><span class="line">    wong();</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Pet = Dog | Cat</span><br><span class="line"></span><br><span class="line">// 具体定义数组每个位置的类型</span><br><span class="line">type PetList = [Dog, Pet]</span><br></pre></td></tr></table></figure>

<p><strong>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 当你想获取一个变量的类型时，使用 typeof</span><br><span class="line">let div = document.createElement(&#x27;div&#x27;);</span><br><span class="line">type B = typeof div</span><br></pre></td></tr></table></figure>

<p><strong>其他骚操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type StringOrNumber = string | number;  </span><br><span class="line">type Text = string | &#123; text: string &#125;;  </span><br><span class="line">type NameLookup = Dictionary&lt;string, Person&gt;;  </span><br><span class="line">type Callback&lt;T&gt; = (data: T) =&gt; void;  </span><br><span class="line">type Pair&lt;T&gt; = [T, T];  </span><br><span class="line">type Coordinates = Pair&lt;number&gt;;  </span><br><span class="line">type Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="interface-可以而-type-不行"><a href="#interface-可以而-type-不行" class="headerlink" title="interface 可以而 type 不行"></a>interface 可以而 type 不行</h3><blockquote>
<p><code>interface</code> 能够声明合并</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface User &#123;</span><br><span class="line">  sex: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">User 接口为 &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">  sex: string </span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不清楚什么时候用<code>interface/type</code>，能用 <code>interface</code> 实现，就用 <code>interface</code> , 如果不能就用 <code>type</code></p>
</blockquote>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/07/25/html+css+js+ts/5-Ts-interface%E4%B8%8Etype%E5%8C%BA%E5%88%AB/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-echart使用小结">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/06/23/bug/echart%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">echart使用小结</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-06-23
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/echart/" class="cube-excerpt-tag-link">#echart</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <blockquote>
<p>十一个组件选项主要用来进行交互</p>
</blockquote>
<h2 id="一、Timeline选项"><a href="#一、Timeline选项" class="headerlink" title="一、Timeline选项"></a>一、Timeline选项</h2><ul>
<li>时间轴，每个图表最多仅有一个时间轴控件</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/45.png" alt="img"></p>
<h2 id="二、Title选项"><a href="#二、Title选项" class="headerlink" title="二、Title选项"></a>二、Title选项</h2><ul>
<li>每个图表最多仅有一个标题控件，每个标题控件可设主副标题</li>
</ul>
<blockquote>
<p>可以对标题文字的大小样式进行设置</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/46.png" alt="img"></p>
<h2 id="三、toolbox"><a href="#三、toolbox" class="headerlink" title="三、toolbox"></a>三、toolbox</h2><ul>
<li>工具箱，每个图表最多仅有一个工具箱。工具箱里面可以实现图表类型的切换，保存图片，刷新，查看数据等功能。可以对其像素进行设置</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/47.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    mark : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            mark : &#x27;辅助线开关&#x27;,</span><br><span class="line"></span><br><span class="line">            markUndo : &#x27;删除辅助线&#x27;,</span><br><span class="line"></span><br><span class="line">            markClear : &#x27;清空辅助线&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        lineStyle : &#123;</span><br><span class="line"></span><br><span class="line">            width : 2,</span><br><span class="line"></span><br><span class="line">            color : &#x27;#1e90ff&#x27;,</span><br><span class="line"></span><br><span class="line">            type : &#x27;dashed&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    dataZoom : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            dataZoom : &#x27;区域缩放&#x27;,</span><br><span class="line"></span><br><span class="line">            dataZoomReset : &#x27;区域缩放后退&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    dataView : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;数据视图&#x27;,</span><br><span class="line"></span><br><span class="line">        readOnly: false,</span><br><span class="line"></span><br><span class="line">        lang: [&#x27;数据视图&#x27;, &#x27;关闭&#x27;, &#x27;刷新&#x27;]</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    magicType: &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            line : &#x27;折线图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            bar : &#x27;柱形图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            stack : &#x27;堆积&#x27;,</span><br><span class="line"></span><br><span class="line">            tiled : &#x27;平铺&#x27;,</span><br><span class="line"></span><br><span class="line">            force: &#x27;力导向布局图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            chord: &#x27;和弦图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            pie: &#x27;饼图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            funnel: &#x27;漏斗图切换&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        option: &#123;</span><br><span class="line"></span><br><span class="line">            // line: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // bar: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // stack: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // tiled: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // force: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // chord: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // pie: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // funnel: &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        type : []</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    restore : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;还原&#x27;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    saveAsImage : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;保存为图片&#x27;,</span><br><span class="line"></span><br><span class="line">        type : &#x27;png&#x27;,</span><br><span class="line"></span><br><span class="line">        lang : [&#x27;点击保存&#x27;]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、tooltip"><a href="#四、tooltip" class="headerlink" title="四、tooltip"></a>四、tooltip</h2><ul>
<li>提示框，鼠标悬浮交互时的信息提示</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/48.png" alt="img"></p>
<h2 id="五、legend"><a href="#五、legend" class="headerlink" title="五、legend"></a>五、legend</h2><ul>
<li>图例，每个图表最多仅有一个图例，混搭图表共享</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/49.png" alt="img"></p>
<h2 id="六、dataRange"><a href="#六、dataRange" class="headerlink" title="六、dataRange"></a>六、dataRange</h2><ul>
<li>值域选择，每个图表最多仅有一个值域控件</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/50.png" alt="img"></p>
<h2 id="七、dataZoom"><a href="#七、dataZoom" class="headerlink" title="七、dataZoom"></a>七、dataZoom</h2><ul>
<li><a target="_blank" rel="noopener" href="http://echarts.baidu.com/echarts2/doc/example/dataZoom.html">数据区域缩放</a>。与toolbox.feature.dataZoom同步，仅对直角坐标系图表有效</li>
</ul>
<h2 id="roamController"><a href="#roamController" class="headerlink" title="roamController"></a>roamController</h2><ul>
<li><a target="_blank" rel="noopener" href="http://echarts.baidu.com/echarts2/doc/example/map1.html">缩放漫游组件</a>，仅对地图有效</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/51.png" alt="img"></p>
<h2 id="八、grid"><a href="#八、grid" class="headerlink" title="八、grid"></a>八、grid</h2><blockquote>
<p>直角坐标系内绘图网格</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/52.png" alt="img"></p>
<h2 id="九、xAxis"><a href="#九、xAxis" class="headerlink" title="九、xAxis"></a>九、xAxis</h2><blockquote>
<p>直角坐标系中横轴数组，数组中每一项代表一条横轴坐标轴，仅有一条时可省略数组。最多同时存在2条横轴，单条横轴时可指定安放于grid的底部（默认）或顶部，2条同时存在时位置互斥，默认第一条安放于底部，第二条安放于顶部</p>
</blockquote>
<h2 id="十、yAxis"><a href="#十、yAxis" class="headerlink" title="十、yAxis"></a>十、yAxis</h2><blockquote>
<p>直角坐标系中纵轴数组，数组中每一项代表一条纵轴坐标轴，仅有一条时可省略数组。最多同时存在2条纵轴，单条纵轴时可指定安放于grid的左侧（默认）或右侧，2条同时存在时位置互斥，默认第一条安放于左侧，第二条安放于右侧</p>
</blockquote>
<ul>
<li>坐标轴有三种类型，类目型、数值型和时间型，纵轴通常为数值型，但条形图时则纵轴为类目型</li>
</ul>
<h2 id="十一、series（通用）"><a href="#十一、series（通用）" class="headerlink" title="十一、series（通用）"></a>十一、series（通用）</h2><blockquote>
<p>驱动图表生成的数据内容数组，数组中每一项为一个系列的选项及数据，其中个别选项仅在部分图表类型中有效，请注意适用类型</p>
</blockquote>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/06/23/bug/echart%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-await 在 forEach 中不生效解决方案">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/05/24/html+css+js+ts/await%20%E5%9C%A8%20forEach%20%E4%B8%AD%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">await 在 forEach 中不生效解决方案</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-05-24
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/async-await/" class="cube-excerpt-tag-link">#async/await</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	arr.forEach(async item =&gt; &#123;</span><br><span class="line">		const res = await fetch(item)</span><br><span class="line">		console.log(res)</span><br><span class="line">	&#125;)</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fetch(x) &#123;</span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		setTimeout(() =&gt; &#123;</span><br><span class="line">			resolve(x)</span><br><span class="line">		&#125;, 500 * x)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>期望的打印顺序是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>结果打印顺序居然是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">end</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong></p>
<blockquote>
<p>那就是 <code>forEach</code> 只支持同步代码。<code>forEach</code> 并不会去处理异步的情况</p>
</blockquote>
<h2 id="二、解决办法"><a href="#二、解决办法" class="headerlink" title="二、解决办法"></a>二、解决办法</h2><h3 id="2-1-第一种是使用-Promise-all-的方式"><a href="#2-1-第一种是使用-Promise-all-的方式" class="headerlink" title="2.1 第一种是使用 Promise.all 的方式"></a>2.1 第一种是使用 Promise.all 的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	await Promise.all(</span><br><span class="line">		arr.map(async item =&gt; &#123;</span><br><span class="line">			const res = await fetch(item)</span><br><span class="line">			console.log(res)</span><br><span class="line">		&#125;)</span><br><span class="line">	)</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样可以生效的原因是 <code>async</code> 函数肯定会返回一个 <code>Promise</code> 对象，调用 <code>map</code> 以后返回值就是一个存放了 <code>Promise</code> 的数组了，这样我们把数组传入 <code>Promise.all</code> 中就可以解决问题了。但是这种方式其实并不能达成我们要的效果，如果你希望内部的 <code>fetch</code> 是顺序完成的，可以选择第二种方式</p>
</blockquote>
<h3 id="2-2-另一种方法是使用-for…of"><a href="#2-2-另一种方法是使用-for…of" class="headerlink" title="2.2 另一种方法是使用 for…of"></a>2.2 另一种方法是使用 for…of</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	for (const item of arr) &#123;</span><br><span class="line">		const res = await fetch(item)</span><br><span class="line">		console.log(res)</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式相比 <code>Promise.all</code> 要简洁的多，并且也可以实现开头我想要的输出顺序。</li>
<li>但是这时候你是否又多了一个疑问？为啥 <code>for...of</code> 内部就能让 <code>await</code> 生效呢。</li>
<li>因为 <code>for...of</code> 内部处理的机制和 f<code>orEach</code> 不同，<code>forEach</code> 是直接调用回调函数，<code>for...of</code> 是通过迭代器的方式去遍历。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	const iterator = arr[Symbol.iterator]()</span><br><span class="line">	let res = iterator.next()</span><br><span class="line">	while (!res.done) &#123;</span><br><span class="line">		const value = res.value</span><br><span class="line">		const res1 = await fetch(value)</span><br><span class="line">		console.log(res1)</span><br><span class="line">		res = iterator.next()</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码等价于 <code>for...of</code>，可以看成 <code>for...of</code> 是以上代码的语法糖</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/05/24/html+css+js+ts/await%20%E5%9C%A8%20forEach%20%E4%B8%AD%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-图解前端性能优化">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%9B%BE%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">图解前端性能优化</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-30
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/%E4%BC%98%E5%8C%96/" class="cube-excerpt-tag-link">#优化</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、css和js的装载与执行"><a href="#一、css和js的装载与执行" class="headerlink" title="一、css和js的装载与执行"></a>一、css和js的装载与执行</h2><h3 id="1-1-HTML-页面加载渲染的过程"><a href="#1-1-HTML-页面加载渲染的过程" class="headerlink" title="1.1 HTML 页面加载渲染的过程"></a>1.1 HTML 页面加载渲染的过程</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/119.png" alt="img"></p>
<h3 id="1-2-HTML渲染过程的一些特点"><a href="#1-2-HTML渲染过程的一些特点" class="headerlink" title="1.2 HTML渲染过程的一些特点"></a>1.2 HTML渲染过程的一些特点</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/120.png" alt="img"></p>
<h3 id="1-3-css-阻塞和-js-阻塞"><a href="#1-3-css-阻塞和-js-阻塞" class="headerlink" title="1.3 css 阻塞和 js 阻塞"></a>1.3 css 阻塞和 js 阻塞</h3><h4 id="1-3-1-CSS阻塞"><a href="#1-3-1-CSS阻塞" class="headerlink" title="1.3.1 CSS阻塞"></a>1.3.1 CSS阻塞</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/121.png" alt="img"></p>
<h4 id="1-3-2-JS阻塞"><a href="#1-3-2-JS阻塞" class="headerlink" title="1.3.2 JS阻塞"></a>1.3.2 JS阻塞</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/122.png" alt="img"></p>
<h2 id="二、资源的压缩与合并"><a href="#二、资源的压缩与合并" class="headerlink" title="二、资源的压缩与合并"></a>二、资源的压缩与合并</h2><h3 id="2-1-文件合并"><a href="#2-1-文件合并" class="headerlink" title="2.1 文件合并"></a>2.1 文件合并</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/123.png" alt="img"></p>
<h3 id="2-2-css、js-及-HTML压缩"><a href="#2-2-css、js-及-HTML压缩" class="headerlink" title="2.2 css、js 及 HTML压缩"></a>2.2 css、js 及 HTML压缩</h3><h4 id="2-2-1-CSS压缩"><a href="#2-2-1-CSS压缩" class="headerlink" title="2.2.1 CSS压缩"></a>2.2.1 CSS压缩</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/124.png" alt="img"></p>
<h4 id="2-2-2-JS压缩"><a href="#2-2-2-JS压缩" class="headerlink" title="2.2.2 JS压缩"></a>2.2.2 JS压缩</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/125.png" alt="img"></p>
<h4 id="2-2-3-HTML压缩"><a href="#2-2-3-HTML压缩" class="headerlink" title="2.2.3 HTML压缩"></a>2.2.3 HTML压缩</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/126.png" alt="img"></p>
<h3 id="2-3-http-清求的过程及潜在的性能优化点"><a href="#2-3-http-清求的过程及潜在的性能优化点" class="headerlink" title="2.3 http 清求的过程及潜在的性能优化点"></a>2.3 http 清求的过程及潜在的性能优化点</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/127.png" alt="img"></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/128.png" alt="img"></p>
<h2 id="三、图片相关的优化"><a href="#三、图片相关的优化" class="headerlink" title="三、图片相关的优化"></a>三、图片相关的优化</h2><h3 id="3-1-不同格式图片常用的业务场景"><a href="#3-1-不同格式图片常用的业务场景" class="headerlink" title="3.1 不同格式图片常用的业务场景"></a>3.1 不同格式图片常用的业务场景</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/129.png" alt="img"></p>
<h3 id="3-2-图片压缩几种方法-雪碧图、Image-inline"><a href="#3-2-图片压缩几种方法-雪碧图、Image-inline" class="headerlink" title="3.2 图片压缩几种方法-雪碧图、Image inline"></a>3.2 图片压缩几种方法-雪碧图、Image inline</h3><h4 id="3-2-1-使用矢量图"><a href="#3-2-1-使用矢量图" class="headerlink" title="3.2.1 使用矢量图"></a>3.2.1 使用矢量图</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/130.png" alt="img"></p>
<h4 id="3-2-2-在安卓下使用webp"><a href="#3-2-2-在安卓下使用webp" class="headerlink" title="3.2.2 在安卓下使用webp"></a>3.2.2 在安卓下使用webp</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/131.png" alt="img"></p>
<h2 id="四、-懒加载与预加载"><a href="#四、-懒加载与预加载" class="headerlink" title="四、 懒加载与预加载"></a>四、 懒加载与预加载</h2><h3 id="4-1-懒加载原理"><a href="#4-1-懒加载原理" class="headerlink" title="4.1 懒加载原理"></a>4.1 懒加载原理</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/132.png" alt="img"></p>
<h3 id="4-2-预加载原理"><a href="#4-2-预加载原理" class="headerlink" title="4.2 预加载原理"></a>4.2 预加载原理</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/133.png" alt="img"></p>
<h3 id="4-3-懒加载、预加载使用场景"><a href="#4-3-懒加载、预加载使用场景" class="headerlink" title="4.3 懒加载、预加载使用场景"></a>4.3 懒加载、预加载使用场景</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/134.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/135.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/136.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/137.png" alt="img"></p>
<h3 id="4-4-预加载原生-js-和-PreloadJS-实现"><a href="#4-4-预加载原生-js-和-PreloadJS-实现" class="headerlink" title="4.4 预加载原生 js 和 PreloadJS 实现"></a>4.4 预加载原生 js 和 PreloadJS 实现</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/138.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/139.png" alt="img"></p>
<h2 id="五、缓存"><a href="#五、缓存" class="headerlink" title="五、缓存"></a>五、缓存</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/140.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/141.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/142.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/143.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/144.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/145.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/146.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/147.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/148.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/149.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/150.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/151.png" alt="img"></p>
<h2 id="六、重绘与回流"><a href="#六、重绘与回流" class="headerlink" title="六、重绘与回流"></a>六、重绘与回流</h2><h3 id="6-1-什么是重绘与回流"><a href="#6-1-什么是重绘与回流" class="headerlink" title="6.1 什么是重绘与回流"></a>6.1 什么是重绘与回流</h3><h4 id="6-1-1-重绘"><a href="#6-1-1-重绘" class="headerlink" title="6.1.1 重绘"></a>6.1.1 重绘</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/152.png" alt="img"></p>
<h4 id="6-1-2-回流"><a href="#6-1-2-回流" class="headerlink" title="6.1.2 回流"></a>6.1.2 回流</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/153.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/154.png" alt="img"></p>
<h3 id="6-2-避免重绘回流的两种方法"><a href="#6-2-避免重绘回流的两种方法" class="headerlink" title="6.2 避免重绘回流的两种方法"></a>6.2 避免重绘回流的两种方法</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/155.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/156.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/157.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/158.png" alt="img"></p>
<h3 id="6-3-css-性能让-Javacript-变慢？"><a href="#6-3-css-性能让-Javacript-变慢？" class="headerlink" title="6.3 css 性能让 Javacript 变慢？"></a>6.3 css 性能让 Javacript 变慢？</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/159.png" alt="img"></p>
<h3 id="6-4-案例解析-重绘、回流及图层"><a href="#6-4-案例解析-重绘、回流及图层" class="headerlink" title="6.4 案例解析-重绘、回流及图层"></a>6.4 案例解析-重绘、回流及图层</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/160.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/161.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/162.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/163.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/164.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/165.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/166.png" alt="img"></p>
<h3 id="6-5-实战优化点总结"><a href="#6-5-实战优化点总结" class="headerlink" title="6.5 实战优化点总结"></a>6.5 实战优化点总结</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/167.png" alt="img"></p>
<h2 id="七、浏览器存储"><a href="#七、浏览器存储" class="headerlink" title="七、浏览器存储"></a>七、浏览器存储</h2><h3 id="7-1-cookies"><a href="#7-1-cookies" class="headerlink" title="7.1 cookies"></a>7.1 cookies</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/168.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/169.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/170.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/171.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/172.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/173.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/174.png" alt="img"></p>
<h3 id="7-2-LocalStorage、SessionStorage"><a href="#7-2-LocalStorage、SessionStorage" class="headerlink" title="7.2 LocalStorage、SessionStorage"></a>7.2 LocalStorage、SessionStorage</h3><h4 id="7-2-1-LocalStorage"><a href="#7-2-1-LocalStorage" class="headerlink" title="7.2.1 LocalStorage"></a>7.2.1 LocalStorage</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/175.png" alt="img"></p>
<h4 id="7-2-2-SessionStorage"><a href="#7-2-2-SessionStorage" class="headerlink" title="7.2.2 SessionStorage"></a>7.2.2 SessionStorage</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/176.png" alt="img"></p>
<h3 id="7-3-IndexedDB"><a href="#7-3-IndexedDB" class="headerlink" title="7.3 IndexedDB"></a>7.3 IndexedDB</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/177.png" alt="img"></p>
<h3 id="7-4-案例解析"><a href="#7-4-案例解析" class="headerlink" title="7.4 案例解析"></a>7.4 案例解析</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/178.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/179.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/180.png" alt="img"></p>
<h3 id="7-5-PWA与Service-Workers"><a href="#7-5-PWA与Service-Workers" class="headerlink" title="7.5 PWA与Service Workers"></a>7.5 PWA与Service Workers</h3><h4 id="7-5-1-PWA"><a href="#7-5-1-PWA" class="headerlink" title="7.5.1 PWA"></a>7.5.1 PWA</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/181.png" alt="img"></p>
<h4 id="7-5-2-Service-Workers"><a href="#7-5-2-Service-Workers" class="headerlink" title="7.5.2 Service Workers"></a>7.5.2 Service Workers</h4><p><img src="https://poetries1.gitee.io/img-repo/2019/10/182.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/183.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/184.png" alt="img"></p>
<h3 id="7-6-Service-Workers-离线应用"><a href="#7-6-Service-Workers-离线应用" class="headerlink" title="7.6 Service Workers-离线应用"></a>7.6 Service Workers-离线应用</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/185.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/186.png" alt="img"></p>
<h2 id="八、移动H5前端性能优化指南"><a href="#八、移动H5前端性能优化指南" class="headerlink" title="八、移动H5前端性能优化指南"></a>八、移动H5前端性能优化指南</h2><p><img src="https://camo.githubusercontent.com/db045941b5adebe26eae1202b9286fe8c39e5fa2/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f3934383631342d313735326635633839393363633161302e6a7065673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%9B%BE%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-前端页面性能优化">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/22/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端页面性能优化</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-22
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/%E4%BC%98%E5%8C%96/" class="cube-excerpt-tag-link">#优化</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、调试工具"><a href="#一、调试工具" class="headerlink" title="一、调试工具"></a>一、调试工具</h2><h3 id="1、Network"><a href="#1、Network" class="headerlink" title="1、Network"></a>1、Network</h3><p><img src="https://blog.poetries.top/img/static/images/image-20210208102537169.png" alt="image-20210208102537169"></p>
<p>这里可以看到资源加载详情，初步评估影响<code>页面性能</code>的因素。鼠标右键可以自定义选项卡，页面底部是当前加载资源的一个概览。<code>DOMContentLoaded</code> DOM渲染完成的时间，<code>Load</code>：当前页面所有资源加载完成的时间</p>
<p><strong>思考：如何判断哪些资源对当前页面加载无用，做对应优化？</strong></p>
<p><strong>shift + cmd + P 调出控制台的扩展工具，添加规则</strong></p>
<p><img src="https://blog.poetries.top/img/static/images/image-20210208102549961.png" alt="image-20210208102549961"></p>
<p><strong>监控页面性能变化</strong></p>
<p><img src="https://blog.poetries.top/img/static/images/image-20210208102650825.png" alt="image-20210208102650825"></p>
<h4 id="瀑布流waterfal"><a href="#瀑布流waterfal" class="headerlink" title="瀑布流waterfal"></a>瀑布流waterfal</h4><p><img src="https://blog.poetries.top/img/static/images/image-20210208102723253.png" alt="image-20210208102723253"></p>
<ul>
<li><code>Queueing</code> 浏览器将资源放入队列时间</li>
<li><code>Stalled</code> 因放入队列时间而发生的停滞时间</li>
<li><code>DNS Lookup</code> DNS解析时间</li>
<li><code>Initial connection</code> 建立HTTP连接的时间</li>
<li><code>SSL</code> 浏览器与服务器建立安全性连接的时间</li>
<li><code>TTFB</code> 等待服务端返回数据的时间</li>
<li><code>Content Download</code> 浏览器下载资源的时间</li>
</ul>
<h3 id="2、Lighthouse"><a href="#2、Lighthouse" class="headerlink" title="2、Lighthouse"></a>2、Lighthouse</h3><p><img src="https://blog.poetries.top/img/static/images/image-20210208102851752.png" alt="image-20210208102851752"></p>
<ul>
<li><code>First Contentful Paint</code> 首屏渲染时间，1s以内绿色</li>
<li><code>Speed Index</code> 速度指数，4s以内绿色</li>
<li><code>Time to Interactive</code> 到页面可交换的时间</li>
</ul>
<blockquote>
<p>根据chrome的一些策略自动对网站做一个质量评估，并且会给出一些优化的建议</p>
</blockquote>
<h3 id="3、Peformance"><a href="#3、Peformance" class="headerlink" title="3、Peformance"></a>3、Peformance</h3><p><img src="https://blog.poetries.top/img/static/images/image-20210208102949596.png" alt="image-20210208102949596"></p>
<p>对网站最专业的分析</p>
<h3 id="4、webPageTest"><a href="#4、webPageTest" class="headerlink" title="4、webPageTest"></a>4、webPageTest</h3><blockquote>
<p>可以模拟不同场景下访问的情况，比如模拟不同浏览器、不同国家等等，在线测试地址：<a target="_blank" rel="noopener" href="https://www.webpagetest.org/">webPageTest</a></p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/image-20210208103032419.png" alt="image-20210208103032419"></p>
<p><img src="https://blog.poetries.top/img/static/images/image-20210208103054016.png" alt="image-20210208103054016"></p>
<h3 id="5、资源打包分析"><a href="#5、资源打包分析" class="headerlink" title="5、资源打包分析"></a>5、资源打包分析</h3><h4 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a>webpack-bundle-analyzer</h4><p><img src="https://blog.poetries.top/img/static/images/image-20210208103127992.png" alt="image-20210208103127992"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br><span class="line">// webpack.config.js 文件</span><br><span class="line">const BundleAnalyzerPlugin = require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin</span><br><span class="line">module.exports=&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new BundleAnalyzerPlugin(&#123;</span><br><span class="line">          analyzerMode: &#x27;server&#x27;,</span><br><span class="line">          analyzerHost: &#x27;127.0.0.1&#x27;,</span><br><span class="line">          analyzerPort: 8889,</span><br><span class="line">          reportFilename: &#x27;report.html&#x27;,</span><br><span class="line">          defaultSizes: &#x27;parsed&#x27;,</span><br><span class="line">          openAnalyzer: true,</span><br><span class="line">          generateStatsFile: false,</span><br><span class="line">          statsFilename: &#x27;stats.json&#x27;,</span><br><span class="line">          statsOptions: null,</span><br><span class="line">          logLevel: &#x27;info&#x27;</span><br><span class="line">        &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// package.json</span><br><span class="line">&quot;analyz&quot;: &quot;NODE_ENV=production npm_config_report=true npm run build&quot;</span><br></pre></td></tr></table></figure>

<h4 id="开启source-map"><a href="#开启source-map" class="headerlink" title="开启source-map"></a>开启source-map</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &#x27;production&#x27;,</span><br><span class="line">    devtool: &#x27;hidden-source-map&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package.json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;analyze&quot;: &quot;source-map-explorer &#x27;build/*.js&#x27;&quot;,</span><br></pre></td></tr></table></figure>

<p>npm run analyze</p>
<p><img src="https://blog.poetries.top/img/static/images/image-20210208103321371.png" alt="image-20210208103321371"></p>
<h2 id="二、WEB-API"><a href="#二、WEB-API" class="headerlink" title="二、WEB API"></a>二、WEB API</h2><p>工欲善其事，必先利其器。浏览器提供的一些分析API<code>至关重要</code></p>
<h3 id="1、监听视窗激活状态"><a href="#1、监听视窗激活状态" class="headerlink" title="1、监听视窗激活状态"></a>1、监听视窗激活状态</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b7ab11fc7b94fcf8c79bd3b28706b2c~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 窗口激活状态监听</span><br><span class="line">let vEvent = &#x27;visibilitychange&#x27;;</span><br><span class="line">if (document.webkitHidden != undefined) &#123;</span><br><span class="line">    vEvent = &#x27;webkitvisibilitychange&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function visibilityChanged() &#123;</span><br><span class="line">    if (document.hidden || document.webkitHidden) &#123;</span><br><span class="line">        document.title = &#x27;客官，别走啊~&#x27;</span><br><span class="line">        console.log(&quot;Web page is hidden.&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        document.title = &#x27;客官，你又回来了呢~&#x27;</span><br><span class="line">        console.log(&quot;Web page is visible.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.addEventListener(vEvent, visibilityChanged, false);</span><br></pre></td></tr></table></figure>

<p>其实有很多隐藏的api，这里大家有兴趣的可以去试试看：</p>
<h3 id="2、观察长任务（performance-中Task）"><a href="#2、观察长任务（performance-中Task）" class="headerlink" title="2、观察长任务（performance 中Task）"></a>2、观察长任务（performance 中Task）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const observer = new PerformanceObserver((list) =&gt; &#123;</span><br><span class="line">    for (const entry of list.getEntries()) &#123;</span><br><span class="line">        console.log(entry)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">observer.observe(&#123;entryTypes: [&#x27;longtask&#x27;]&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3、监听网络变化"><a href="#3、监听网络变化" class="headerlink" title="3、监听网络变化"></a>3、监听网络变化</h3><p>网络变化时给用户反馈网络问题，有时候看直播的时候自己的网络卡顿，直播平台也会提醒你或者自动给你切换清晰度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;</span><br><span class="line">var type = connection.effectiveType;</span><br><span class="line"></span><br><span class="line">function updateConnectionStatus() &#123;</span><br><span class="line">  console.log(&quot;Connection type changed from &quot; + type + &quot; to &quot; + connection.effectiveType);</span><br><span class="line">  type = connection.effectiveType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection.addEventListener(&#x27;change&#x27;, updateConnectionStatus);</span><br></pre></td></tr></table></figure>

<h3 id="4、计算DOMContentLoaded时间"><a href="#4、计算DOMContentLoaded时间" class="headerlink" title="4、计算DOMContentLoaded时间"></a>4、计算DOMContentLoaded时间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;DOMContentLoaded&#x27;, (event) =&gt; &#123;</span><br><span class="line">    let timing = performance.getEntriesByType(&#x27;navigation&#x27;)[0];</span><br><span class="line">    console.log(timing.domInteractive);</span><br><span class="line">    console.log(timing.fetchStart);</span><br><span class="line">    let diff = timing.domInteractive - timing.fetchStart;</span><br><span class="line">    console.log(&quot;TTI: &quot; + diff);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5、更多计算规则"><a href="#5、更多计算规则" class="headerlink" title="5、更多计算规则"></a>5、更多计算规则</h3><ul>
<li><code>DNS</code> 解析耗时: <code>domainLookupEnd - domainLookupStart</code></li>
<li><code>TCP</code> 连接耗时: <code>connectEnd - connectStart</code></li>
<li><code>SSL</code> 安全连接耗时: <code>connectEnd - secureConnectionStart</code></li>
<li>网络请求耗时 (<code>TTFB</code>): <code>responseStart - requestStart</code></li>
<li>数据传输耗时: <code>responseEnd - responseStart</code></li>
<li><code>DOM</code> 解析耗时: <code>domInteractive - responseEnd</code></li>
<li>资源加载耗时:<code>loadEventStart - domContentLoadedEventEnd</code></li>
<li><code>First Byte</code>时间: <code>responseStart - domainLookupStart</code></li>
<li>白屏时间: <code>responseEnd - fetchStart</code></li>
<li>首次可交互时间: <code>domInteractive - fetchStart</code></li>
<li><code>DOM Ready</code> 时间: <code>domContentLoadEventEnd - fetchStart</code></li>
<li>页面完全加载时间: <code>loadEventStart - fetchStart</code></li>
<li><code>http</code> 头部大小： <code>transferSize - encodedBodySize</code></li>
<li>重定向次数：<code>performance.navigation.redirectCount</code></li>
<li>重定向耗时: <code>redirectEnd - redirectStart</code></li>
</ul>
<h2 id="三、雅虎军规"><a href="#三、雅虎军规" class="headerlink" title="三、雅虎军规"></a>三、雅虎军规</h2><p>关于雅虎军规，你知道的有多少条，平时写用到的又有哪些？针对以下规则，我们可以做很多优化工作</p>
<p><img src="https://blog.poetries.top/img/static/images/image-20210208103918197.png" alt="image-20210208103918197"></p>
<h3 id="1、减少cookie传输"><a href="#1、减少cookie传输" class="headerlink" title="1、减少cookie传输"></a>1、减少cookie传输</h3><blockquote>
<p><code>cookie</code>传输会造成带宽浪费，可以：</p>
</blockquote>
<ul>
<li>减少<code>cookie</code>中存储的东西</li>
<li>静态资源不需要<code>cookie</code>，可以采用其他的域名，不会主动带上<code>cookie</code></li>
</ul>
<h3 id="2、避免过多的回流与重绘"><a href="#2、避免过多的回流与重绘" class="headerlink" title="2、避免过多的回流与重绘"></a>2、避免过多的回流与重绘</h3><p>连续触发页面回流操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let cards = document.getElementsByClassName(&quot;MuiPaper-rounded&quot;);</span><br><span class="line">const update = (timestamp) =&gt; &#123;</span><br><span class="line">  for (let i = 0; i &lt;cards.length; i++) &#123;</span><br><span class="line">    let top = cards[i].offsetTop;</span><br><span class="line">    cards[i].style.width = ((Math.sin(cards[i].offsetTop + timestamp / 100 + 1) * 500) + &#x27;px&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  window.requestAnimationFrame(update)</span><br><span class="line">&#125;</span><br><span class="line">update(1000);</span><br></pre></td></tr></table></figure>

<p>看下效果，很明显的卡顿</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7618dea1a4774c8685e9926b08d67fdd~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<blockquote>
<p><code>performance</code>分析结果，<code>load</code>事件之后存在大量的回流，并且<code>chrome</code>都给标记了红色</p>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b543d68fab7445da1dedb72bb224f69~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<blockquote>
<p>使用<code>fastDom</code>进行优化，将对dom的<code>读和写</code>分离，合并</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let cards = document.getElementsByClassName(&quot;MuiPaper-rounded&quot;);</span><br><span class="line">  const update = (timestamp) =&gt; &#123;</span><br><span class="line">    for (let i = 0; i &lt; cards.length; i++) &#123;</span><br><span class="line">      fastdom.measure(() =&gt; &#123;</span><br><span class="line">        let top = cards[i].offsetTop;</span><br><span class="line">        fastdom.mutate(() =&gt; &#123;</span><br><span class="line">          cards[i].style.width =</span><br><span class="line">            Math.sin(top + timestamp / 100 + 1) * 500 + &quot;px&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    window.requestAnimationFrame(update)</span><br><span class="line">  &#125;</span><br><span class="line">  update(1000);</span><br></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1df5c32c30494c13b3402305f866b327~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<blockquote>
<p><code>performance</code>分析结果，load事件之后也没有了那么多的红色标记</p>
</blockquote>
<p>感兴趣的可以去了解一下fastDom：<a target="_blank" rel="noopener" href="https://github.com/wilsonpage/fastdom">github fastdom</a> 在线预览：<a target="_blank" rel="noopener" href="http://wilsonpage.github.io/fastdom/examples/animation.html">fastdom demo</a></p>
<p>关于任务拆分与组合的思想，<code>react fiber</code>架构做的很牛逼，有兴趣的可以去了解一下调度算法在fiber中的实践</p>
<h2 id="四、压缩"><a href="#四、压缩" class="headerlink" title="四、压缩"></a>四、压缩</h2><h3 id="1、Gzip"><a href="#1、Gzip" class="headerlink" title="1、Gzip"></a>1、Gzip</h3><p>开启方式可参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903605187641357">nginx开启gzip</a></p>
<p><img src="https://blog.poetries.top/img/static/images/image-20210208104535672.png" alt="image-20210208104535672"></p>
<blockquote>
<p>还有一种方式：打包的时候生成gz文件，上传到服务器端，这样就不需要nginx来压缩了，可以降低服务器压力。 可参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020976930">gzip压缩文件&amp;webPack配置Compression-webpack-plugin</a></p>
</blockquote>
<h3 id="2、服务端压缩"><a href="#2、服务端压缩" class="headerlink" title="2、服务端压缩"></a>2、服务端压缩</h3><p>server.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">const app = express();</span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">const compression = require(&#x27;compression&#x27;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(compression());</span><br><span class="line">app.use(express.static(&#x27;build&#x27;));</span><br><span class="line"></span><br><span class="line">app.get(&#x27;*&#x27;, (req,res) =&gt;&#123;</span><br><span class="line">    res.sendFile(path.join(__dirname+&#x27;/build/index.html&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const listener = app.listen(process.env.PORT || 3000, function () &#123;</span><br><span class="line">    console.log(`Listening on port $&#123;listener.address().port&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>package.json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;start&quot;: &quot;npm run build &amp;&amp; node server.js&quot;,</span><br></pre></td></tr></table></figure>

<p><img src="https://blog.poetries.top/img/static/images/image-20210208104641677.png" alt="image-20210208104641677"></p>
<h3 id="3、JavaScript、Css、Html压缩"><a href="#3、JavaScript、Css、Html压缩" class="headerlink" title="3、JavaScript、Css、Html压缩"></a>3、JavaScript、Css、Html压缩</h3><p>工程化项目中直接使用对应的插件即可，webpack的主要有下面三个：</p>
<ul>
<li><code>UglifyJS</code></li>
<li><code>webpack-parallel-uglify-plugin</code></li>
<li><code>terser-webpack-plugin</code></li>
</ul>
<blockquote>
<p>具体优缺点可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24147051/article/details/103557728">webpack常用的三种JS压缩插件</a>。<code>压缩原理</code>简单的讲就是去除一些空格、换行、注释，借助es6模块化的功能，做了一些<code>tree-shaking</code>的优化。同时做了一些代码混淆，一方面是为了更小的体积，另一方面也是为了源码的安全性。</p>
</blockquote>
<p>css压缩主要是<code>mini-css-extract-plugin</code>，当然前面的js压缩插件也会给你做好css压缩。使用姿势</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">plugins:[</span><br><span class="line"> new MiniCssExtractPlugin(&#123;</span><br><span class="line">       filename: &quot;[name].css&quot;,</span><br><span class="line">       chunkFilename: &quot;[id].css&quot;</span><br><span class="line">   &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>html压缩可以用<code>HtmlWebpackPlugin</code>，单页项目就一个index.html,性能提升微乎其微~</p>
<h3 id="4、http2首部压缩"><a href="#4、http2首部压缩" class="headerlink" title="4、http2首部压缩"></a>4、http2首部压缩</h3><p><strong>http2的特点</strong></p>
<ul>
<li>二进制分帧</li>
<li>首部压缩</li>
<li>流量控制</li>
<li>多路复用</li>
<li>请求优先级</li>
<li>服务器推送<code>http2_push: &#39;xxx.jpg&#39;</code></li>
</ul>
<p>具体升级方式也很简单，修改一下<code>nginx</code>配置，方法请自行<code>Google</code></p>
<h2 id="五、webpack优化"><a href="#五、webpack优化" class="headerlink" title="五、webpack优化"></a>五、webpack优化</h2><p>上文中也提到了部分webpack插件，下面我再来看看还有哪些~</p>
<h3 id="1、DllPlugin-提升构建速度"><a href="#1、DllPlugin-提升构建速度" class="headerlink" title="1、DllPlugin 提升构建速度"></a>1、DllPlugin 提升构建速度</h3><blockquote>
<p>通过<code>DllPlugin</code>插件，将一些比较大的，基本很少升级的包拆分出来，生成<code>xx.dll.js</code>文件,通过<code>manifest.json</code>引用</p>
</blockquote>
<p>webpack.dll.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const webpack = require(&quot;webpack&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &quot;production&quot;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        react: [&quot;react&quot;, &quot;react-dom&quot;],</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].dll.js&quot;,</span><br><span class="line">        path: path.resolve(__dirname, &quot;dll&quot;),</span><br><span class="line">        library: &quot;[name]&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DllPlugin(&#123;</span><br><span class="line">            name: &quot;[name]&quot;,</span><br><span class="line">            path: path.resolve(__dirname, &quot;dll/[name].manifest.json&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>package.json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dll-build&quot;: &quot;NODE_ENV=production webpack --config webpack.dll.config.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>webpack4不需要配置dll了，因为webpack4打包性能已经足够优化，vue-cli3都已经移除<code>dll</code></p>
</blockquote>
<h3 id="2、splitChunks-拆包"><a href="#2、splitChunks-拆包" class="headerlink" title="2、splitChunks 拆包"></a>2、splitChunks 拆包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                vendor: &#123;</span><br><span class="line">                    name: &#x27;vendor&#x27;,</span><br><span class="line">                    test: /[\\/]node_modules[\\/]/,</span><br><span class="line">                    minSize: 0,</span><br><span class="line">                    minChunks: 1,</span><br><span class="line">                    priority: 10,</span><br><span class="line">                    chunks: &#x27;initial&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line">                common: &#123;</span><br><span class="line">                    name: &#x27;common&#x27;,</span><br><span class="line">                    test: /[\\/]src[\\/]/,</span><br><span class="line">                    chunks: &#x27;all&#x27;,</span><br><span class="line">                    minSize: 0,</span><br><span class="line">                    minChunks: 2</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="六、骨架屏"><a href="#六、骨架屏" class="headerlink" title="六、骨架屏"></a>六、骨架屏</h2><blockquote>
<p>用css提前占好位置，当资源加载完成即可填充，减少页面的回流与重绘，同时还能给用户最直接的反馈。 图中使用插件：<a target="_blank" rel="noopener" href="https://github.com/buildo/react-placeholder">react-placeholder</a></p>
</blockquote>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3666ae07b9eb4d839f7a893b89d83f47~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>关于实现骨架屏还有很多种方案，用<code>Puppeteer</code>服务端渲染的挺多的</p>
<p>使用css伪类：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020437426">只要css就能实现的骨架屏方案</a></p>
<h2 id="七、窗口化"><a href="#七、窗口化" class="headerlink" title="七、窗口化"></a>七、窗口化</h2><blockquote>
<p>原理：只加载当前窗口能显示的DOM元素，当视图变化时，删除隐藏的，添加要显示的DOM就可以保证页面上存在的dom元素数量永远不多，页面就不会卡顿</p>
</blockquote>
<p>图中使用的插件：<a target="_blank" rel="noopener" href="https://github.com/bvaughn/react-window">react-window</a></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a459cc811844b7793aff6c9878d19ad~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>安装：<code>npm i react-window</code></p>
<p>引入：<code>import &#123; FixedSizeList as List &#125; from &#39;react-window&#39;;</code></p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const Row = (&#123; index, style &#125;) =&gt; (</span><br><span class="line">  &lt;div style=&#123;style&#125;&gt;Row &#123;index&#125;&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">const Example = () =&gt; (</span><br><span class="line">  &lt;List</span><br><span class="line">    height=&#123;150&#125;</span><br><span class="line">    itemCount=&#123;1000&#125;</span><br><span class="line">    itemSize=&#123;35&#125;</span><br><span class="line">    width=&#123;300&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;Row&#125;</span><br><span class="line">  &lt;/List&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="八、缓存"><a href="#八、缓存" class="headerlink" title="八、缓存"></a>八、缓存</h2><h3 id="1、http缓存"><a href="#1、http缓存" class="headerlink" title="1、http缓存"></a>1、http缓存</h3><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>判断是否开启：看<code>response headers</code>中有没有<code>Connection: keep-alive</code> 。开启以后，看<code>network</code>的瀑布流中就没有 <code>Initial connection</code>耗时了</p>
<p><code>nginx</code>设置<code>keep-alive</code>（默认开启）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 0 为关闭</span><br><span class="line">#keepalive_timeout 0;</span><br><span class="line"># 65s无连接 关闭</span><br><span class="line">keepalive_timeout 65;</span><br><span class="line"># 连接数，达到100断开</span><br><span class="line">keepalive_requests 100;</span><br></pre></td></tr></table></figure>

<h4 id="Cache-Control-x2F-Expires-x2F-Max-Age"><a href="#Cache-Control-x2F-Expires-x2F-Max-Age" class="headerlink" title="Cache-Control &#x2F; Expires &#x2F; Max-Age"></a>Cache-Control &#x2F; Expires &#x2F; Max-Age</h4><p>设置资源是否缓存，以及缓存时间</p>
<h4 id="Etag-x2F-If-None-Match"><a href="#Etag-x2F-If-None-Match" class="headerlink" title="Etag &#x2F; If-None-Match"></a>Etag &#x2F; If-None-Match</h4><p>资源唯一标识作对比，如果有变化，从服务器拉取资源。如果没变化则取缓存资源，状态码304，也就是协商缓存</p>
<h4 id="Last-Modified-x2F-If-Modified-Since"><a href="#Last-Modified-x2F-If-Modified-Since" class="headerlink" title="Last-Modified &#x2F; If-Modified-Since"></a>Last-Modified &#x2F; If-Modified-Since</h4><p>通过对比时间的差异来觉得要不要从服务器获取资源</p>
<p>更多HTTP缓存参数可参考：<a target="_blank" rel="noopener" href="https://harttle.land/2017/04/04/using-http-cache.html">使用 HTTP 缓存：Etag, Last-Modified 与 Cache-Control</a></p>
<h3 id="2、Service-Worker"><a href="#2、Service-Worker" class="headerlink" title="2、Service Worker"></a>2、Service Worker</h3><blockquote>
<p>借助webpack插件<code>WorkboxWebpackPlugin</code>和<code>ManifestPlugin</code>,加载serviceWorker.js,通过<code>serviceWorker.register()</code>注册</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">new WorkboxWebpackPlugin.GenerateSW(&#123;</span><br><span class="line">    clientsClaim: true,</span><br><span class="line">    exclude: [/\.map$/, /asset-manifest\.json$/],</span><br><span class="line">    importWorkboxFrom: &#x27;cdn&#x27;,</span><br><span class="line">    navigateFallback: paths.publicUrlOrPath + &#x27;index.html&#x27;,</span><br><span class="line">    navigateFallbackBlacklist: [</span><br><span class="line">        new RegExp(&#x27;^/_&#x27;),</span><br><span class="line">        new RegExp(&#x27;/[^/?]+\\.[^/]+$&#x27;),</span><br><span class="line">    ],</span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line">new ManifestPlugin(&#123;</span><br><span class="line">    fileName: &#x27;asset-manifest.json&#x27;,</span><br><span class="line">    publicPath: paths.publicUrlOrPath,</span><br><span class="line">    generate: (seed, files, entrypoints) =&gt; &#123;</span><br><span class="line">        const manifestFiles = files.reduce((manifest, file) =&gt; &#123;</span><br><span class="line">            manifest[file.name] = file.path;</span><br><span class="line">            return manifest;</span><br><span class="line">        &#125;, seed);</span><br><span class="line">        const entrypointFiles = entrypoints.app.filter(</span><br><span class="line">            fileName =&gt; !fileName.endsWith(&#x27;.map&#x27;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            files: manifestFiles,</span><br><span class="line">            entrypoints: entrypointFiles,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>

<p><img src="https://blog.poetries.top/img/static/images/image-20210208105415279.png" alt="image-20210208105415279"></p>
<h2 id="九、预加载-amp-amp-懒加载"><a href="#九、预加载-amp-amp-懒加载" class="headerlink" title="九、预加载 &amp;&amp; 懒加载"></a>九、预加载 &amp;&amp; 懒加载</h2><h3 id="1、preload"><a href="#1、preload" class="headerlink" title="1、preload"></a>1、preload</h3><p>就拿demo中的字体举例，正常情况下的加载顺序是这样的：</p>
<p><img src="https://blog.poetries.top/img/static/images/image-20210208105446451.png" alt="image-20210208105446451"></p>
<p>加入preload：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;https://fonts.gstatic.com/s/longcang/v5/LYjAdGP8kkgoTec8zkRgqHAtXN-dRp6ohF_hzzTtOcBgYoCKmPpHHEBiM6LIGv3EnKLjtw.119.woff2&quot; as=&quot;font&quot; crossorigin=&quot;anonymous&quot;/&gt; </span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;https://fonts.gstatic.com/s/longcang/v5/LYjAdGP8kkgoTec8zkRgqHAtXN-dRp6ohF_hzzTtOcBgYoCKmPpHHEBiM6LIGv3EnKLjtw.118.woff2&quot; as=&quot;font&quot; crossorigin=&quot;anonymous&quot;/&gt; </span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;https://fonts.gstatic.com/s/longcang/v5/LYjAdGP8kkgoTec8zkRgqHAtXN-dRp6ohF_hzzTtOcBgYoCKmPpHHEBiM6LIGv3EnKLjtw.116.woff2&quot; as=&quot;font&quot; crossorigin=&quot;anonymous&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog.poetries.top/img/static/images/image-20210208105522277.png" alt="image-20210208105522277"></p>
<h3 id="2、prefetch"><a href="#2、prefetch" class="headerlink" title="2、prefetch"></a>2、prefetch</h3><blockquote>
<p>场景：首页不需要这样的字体文件，下个页面需要：首页会以最低优先级<code>Lowest</code>来提前加载</p>
</blockquote>
<p>加入<code>prefetch</code>：</p>
<p>需要的页面，从<code>prefetch cache</code>中取</p>
<p><img src="https://blog.poetries.top/img/static/images/image-20210208105625448.png" alt="image-20210208105625448"></p>
<p>webpack也是支持这两个属性的:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skychx/p/webpack-webpackChunkName-webpackPreload-webpackPreload.html">webpackPrefetch 和 webpackPreload</a></p>
<h3 id="3、懒加载"><a href="#3、懒加载" class="headerlink" title="3、懒加载"></a>3、懒加载</h3><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>机械图片</p>
<p><img src="https://blog.poetries.top/img/static/images/image-20210208105717958.png" alt="image-20210208105717958"></p>
<p><code>渐进式图片（类似高斯模糊）</code> 需要UI小姐姐出稿的时候指定这种格式</p>
<p><img src="https://blog.poetries.top/img/static/images/image-20210208105747314.png" alt="image-20210208105747314"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应式图片</span><br></pre></td></tr></table></figure>

<p>原生模式：&#96;&#96;</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7427e9243791461b8ffa49f47981cfba~tplv-k3u1fbpfcp-watermark.image?imageslim" alt="img"></p>
<h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><p>通过<code>函数 + import</code>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Page404 = () =&gt; import(/* webpackChunkName: &quot;error&quot; */&#x27;@views/errorPage/404&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="十、ssr-amp-amp-react-snap"><a href="#十、ssr-amp-amp-react-snap" class="headerlink" title="十、ssr &amp;&amp; react-snap"></a>十、ssr &amp;&amp; react-snap</h2><ul>
<li>服务端渲染<code>SSR</code>，vue使用<code>nuxt.js</code>，<code>react</code>使用<code>next.js</code></li>
<li><code>react-snap</code>可以借助<code>Puppeteer</code>实现先渲染单页，然后保留<code>DOM</code>，发送到客户端</li>
</ul>
<h2 id="十一、体验优化"><a href="#十一、体验优化" class="headerlink" title="十一、体验优化"></a>十一、体验优化</h2><h3 id="白屏loading"><a href="#白屏loading" class="headerlink" title="白屏loading"></a>白屏loading</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41557f3a361c4cf899a4eab3bde79154~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p><strong>loading.html</strong> 需要自取哦，还有种方式，使用<code>webpack</code>插件<code>HtmlWebpackPlugin</code>将loading资源插入到页面中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Loading&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      #loadding &#123;</span><br><span class="line">        position: fixed;</span><br><span class="line">        top: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        display: flex;</span><br><span class="line">        width: 100%;</span><br><span class="line">        align-items: center;</span><br><span class="line">        justify-content: center;</span><br><span class="line">      &#125;</span><br><span class="line">      #loadding &gt; span &#123;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        width: 8px;</span><br><span class="line">        height: 100%;</span><br><span class="line">        margin-right: 5px;</span><br><span class="line">        border-radius: 4px;</span><br><span class="line">        -webkit-animation: load 1.04s ease infinite;</span><br><span class="line">        animation: load 1.04s ease infinite;</span><br><span class="line">      &#125;</span><br><span class="line">      @keyframes load &#123;</span><br><span class="line">        0%,</span><br><span class="line">        100% &#123;</span><br><span class="line">          height: 40px;</span><br><span class="line">          background: #98beff;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">          height: 60px;</span><br><span class="line">          margin-top: -20px;</span><br><span class="line">          background: #3e7fee;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;loadding&quot;&gt;</span><br><span class="line">      &lt;span&gt;&lt;/span&gt;</span><br><span class="line">      &lt;span style=&quot;animation-delay: 0.13s&quot;&gt;&lt;/span&gt;</span><br><span class="line">      &lt;span style=&quot;animation-delay: 0.26s&quot;&gt;&lt;/span&gt;</span><br><span class="line">      &lt;span style=&quot;animation-delay: 0.39s&quot;&gt;&lt;/span&gt;</span><br><span class="line">      &lt;span style=&quot;animation-delay: 0.52s&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    window.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123;</span><br><span class="line">      const $loadding = document.getElementById(&quot;loadding&quot;);</span><br><span class="line">      if (!$loadding) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      $loadding.style.display = &quot;none&quot;;</span><br><span class="line">      $loadding.parentNode.removeChild($loadding);</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/22/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-js-原型链">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/18/html+css+js+ts/3-%E5%8E%9F%E5%9E%8B%E9%93%BE/">js-原型链</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-18
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/javascript/" class="cube-excerpt-tag-link">#javascript</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、JS内置对象"><a href="#一、JS内置对象" class="headerlink" title="一、JS内置对象"></a>一、JS内置对象</h2><blockquote>
<p>所谓的内置对象 指的是：<code>JavaScript</code>本身就自己有的对象 可以直接拿来就用。例如<code>Array</code> <code>String</code> 等等。<code>JavaScript</code>一共有12内置对象</p>
</blockquote>
<p><strong>函数类型(10个)</strong></p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Array</code></li>
<li><code>Function</code></li>
<li><code>Date</code></li>
<li><code>RegExp</code></li>
<li><code>Error</code></li>
<li><code>Object</code></li>
<li><code>Event</code></li>
</ul>
<blockquote>
<p>函数类型 有 <code>__proto__</code>和 <code>prototype</code> 属性</p>
</blockquote>
<p><strong>对象类型(2个)</strong></p>
<ul>
<li><code>Math</code></li>
<li><code>JSON</code></li>
</ul>
<blockquote>
<p>对象类型只有<code>__proto__</code>属性</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1480597-9b6c5ca4a84f967c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="二、JS原型链"><a href="#二、JS原型链" class="headerlink" title="二、JS原型链"></a>二、JS原型链</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p><img src="https://upload-images.jianshu.io/upload_images/1480597-86427eafb257f868.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。</li>
<li>每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>__proto__</code> 来访问</li>
<li>对象可以通过 <strong>proto</strong> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链</li>
</ul>
<blockquote>
<p>打开浏览器的控制面板，随便输入一个<code>JS</code>内置的构造器函数，比如<code>Array</code>，控制台输出的是一个名为<code>Array</code>的函数体，这好像并没有什么稀奇的，但是，当你接着输入<code>Array.prototype</code>，控制面板输出了一堆我们经常用到的<code>Array</code>构造器的方法，把目光转移到最下方，有一个叫<code>__proto__</code>的属性，好奇的点开。列表列出的不是<code>Object</code>构造器的方法么，里边有我们非常熟悉的<code>hasOwnProperty</code>还有<code>toString</code>等方法。如果<code>Array</code>是构造器，那么控制面板输出的<code>Array.prototype</code>的所有属性中<code>constructor</code>又是什么构造器？点开看看，之后就像身处德罗斯特效应中一样，<code>__proto__</code>和<code>constructor</code>，还有<code>Array</code>构造器中常用的方法名不断的出现，一层套一层，一层层展开，没有尽头</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/343.png" alt="img"></p>
<blockquote>
<p>拿<code>Array</code>举例，<code>Array.prototype</code>中有一个<code>constructor</code>属性，这个属性的值就是<code>Array</code>构造器自己</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.constructor === Array //true</span><br></pre></td></tr></table></figure>

<h3 id="2-2-prototype"><a href="#2-2-prototype" class="headerlink" title="2.2 prototype"></a>2.2 prototype</h3><blockquote>
<p>这是一个显式原型属性，只有函数才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fun = Function.prototype.bind()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你以上述方法创建一个函数，那么可以发现这个函数是不具有 <code>prototype</code> 属性的</p>
</blockquote>
<h4 id="2-2-1-prototype-如何产生的"><a href="#2-2-1-prototype-如何产生的" class="headerlink" title="2.2.1 prototype 如何产生的"></a>2.2.1 prototype 如何产生的</h4><blockquote>
<p>当我们声明一个函数时，这个属性就被自动创建了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>并且这个属性的值是一个对象（也就是原型），只有一个属性 <code>constructor</code></p>
</blockquote>
<ul>
<li><code>constructor</code> 对应着构造函数，也就是 <code>Foo</code></li>
</ul>
<h4 id="2-2-2-constructor"><a href="#2-2-2-constructor" class="headerlink" title="2.2.2 constructor"></a>2.2.2 constructor</h4><blockquote>
<p><code>constructor</code>是一个公有且不可枚举的属性。一旦我们改变了函数的 <code>prototype</code> ，那么新对象就没有这个属性了（当然可以通过原型链取到 <code>constructor</code>）</p>
</blockquote>
<p>那么你肯定也有一个疑问，这个属性到底有什么用呢？其实这个属性可以说是一个历史遗留问题，在大部分情况下是没用的，在我的理解里，我认为他有两个作用：</p>
<ul>
<li>让实例对象知道是什么函数构造了它</li>
<li>如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 <code>xx.constructor.method</code> 来扩展</li>
</ul>
<h3 id="2-3-proto"><a href="#2-3-proto" class="headerlink" title="2.3 __proto__"></a>2.3 <code>__proto__</code></h3><blockquote>
<p>这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>__proto__</code> 来访问</p>
</blockquote>
<ul>
<li>因为在 <code>JS</code> 中是没有类的概念的，为了实现类似继承的方式，通过 <code>__proto__</code> 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性</li>
</ul>
<h4 id="2-3-1-实例对象的-proto-如何产生的"><a href="#2-3-1-实例对象的-proto-如何产生的" class="headerlink" title="2.3.1 实例对象的 _proto_ 如何产生的"></a>2.3.1 实例对象的 <code>_proto_</code> 如何产生的</h4><blockquote>
<p>当我们使用 <code>new</code> 操作符时，生成的实例对象拥有了 <code>__proto__</code>属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line">// 这个函数是 Function 的实例对象</span><br><span class="line">// function 就是一个语法糖</span><br><span class="line">// 内部调用了 new Function(...)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以可以说，在 <code>new</code> 的过程中，新对象被添加了 <code>__proto__</code> 并且链接到构造函数的原型上</p>
</blockquote>
<h4 id="2-3-2-new-的过程"><a href="#2-3-2-new-的过程" class="headerlink" title="2.3.2 new 的过程"></a>2.3.2 new 的过程</h4><ul>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 <code>this</code></li>
<li>返回新对象</li>
</ul>
<blockquote>
<p>在调用 <code>new</code> 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 <code>new</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function create() &#123;</span><br><span class="line">    // 创建一个空的对象</span><br><span class="line">    let obj = new Object()</span><br><span class="line">    // 获得构造函数</span><br><span class="line">    let Con = [].shift.call(arguments)</span><br><span class="line">    // 链接到原型</span><br><span class="line">	obj.__proto__ = Con.prototype</span><br><span class="line">    // 绑定 this，执行构造函数</span><br><span class="line">    let result = Con.apply(obj, arguments)</span><br><span class="line">    // 确保 new 出来的是个对象</span><br><span class="line">    return typeof result === &#x27;object&#x27; ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于实例对象来说，都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = &#123; b : 1 &#125;</code></li>
<li>对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 <code>new Object()</code>的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// function 就是个语法糖</span><br><span class="line">// 内部等同于 new Function()</span><br><span class="line">let a = &#123; b: 1 &#125;</span><br><span class="line">// 这个字面量内部也是使用了 new Object()</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1480597-e4a91031a78eb153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>这里<code>Array</code> 内置对象 且是函数类型。所以<code>Array</code>有<code>__proto__</code>属性 指向的是函数类型 <code>(function（）&#123;&#125;)</code>。所以当我们在输出<code>Array.__proto__.proto__</code>;就会返回对象类型<code>(Object&#123;&#125;)</code>.但是再向上就<code>null</code>。因为<code>Object</code>就是父类了。所有的继承自<code>Object</code>。</p>
</blockquote>
<ul>
<li><code>JS</code>内置构造器其中之一的<code>Array</code>原本就是一个函数，而这个函数就是<code>Function</code>的<code>prototype</code>，所以<code>Function.prototype</code>有的方法，<code>JS</code>内置构造器都有，比如<code>call()</code>、<code>apply()</code>、<code>bind()</code>等（其实我们自定义的函数也是继承自<code>Function.prototype</code>，所以我们自己也可以定义构造器）。而<code>Function.prototype</code>的进化链指针又指向了<code>Object.prototype</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 数组实例的__proto__指向构造器的原型</span><br><span class="line"></span><br><span class="line">[].__proto__ === Array.prototype</span><br></pre></td></tr></table></figure>

<h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><ul>
<li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function.prototype</code> 和 <code>Object.prototype</code> 是两个特殊的对象，他们由引擎来创建</li>
<li>除了以上两个特殊对象，其他对象都是通过构造器 <code>new</code> 出来的</li>
<li>函数的 <code>prototype</code> 是一个对象，也就是原型</li>
<li>对象的 <code>__proto__</code> 指向原型， <code>__proto__</code>将对象和原型连接起来组成了原型链</li>
</ul>
<p><strong>关于原型有3个相关的概</strong>念:</p>
<ul>
<li>函数对象的<code>prototype</code>属性, 可以称之为显式原型属性(简称: 显式原型)</li>
<li>实例对象的<code>__proto__</code>属性, 可以称之为隐式原型属性(简称: 隐式原型)</li>
<li>原型对象: 也就是<code>prototype</code>属性和<code>_proto__</code>属性指向的对象</li>
</ul>
<p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt="img"></p>
<blockquote>
<p>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线</p>
</blockquote>
<h2 id="三、JSON和Math"><a href="#三、JSON和Math" class="headerlink" title="三、JSON和Math"></a>三、JSON和Math</h2><blockquote>
<p><code>JS</code>内置的构造器函数都可以使用<code>new</code>关键字实例化一个对象，我们称实例化后的这个对象就是某某构造器的一个实例</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/344.png" alt="img"></p>
<blockquote>
<p>我们试试<code>JSON</code> 和<code>Math</code> 能不能实例化对象</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/345.png" alt="img"></p>
<blockquote>
<p><code>JSON</code>和<code>Math</code>不是构造器函数，他们是普通的对象。只有构造器函数才能使用<code>new</code>关键字实例化一个对象，而<code>JSON</code>和<code>Math</code>已经是对象了，所以我们可以不用实例化直接使用<code>JSON</code>和<code>Math</code>中的属性和方法</p>
</blockquote>
<ul>
<li>所以<code>JSON</code>和<code>Math</code>不属于<code>10</code>个构造器函数，但他们<code>12</code>个共同属于<code>Javascript</code>的内置对象</li>
</ul>
<h2 id="四、更多参考"><a href="#四、更多参考" class="headerlink" title="四、更多参考"></a>四、更多参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/2">JavaScript深入之从原型到原型链</a></li>
</ul>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/18/html+css+js+ts/3-%E5%8E%9F%E5%9E%8B%E9%93%BE/">Read More</a>
    </footer>
</div>



<ul class="cube-pagination cube-pagination-9">
    
    <li class="cube-pagination-prev">
        <a href="/page/2/">« Prev</a>
    </li>
    
    
        
            
                
                <li class="cube-pagination-index">
                    <a href="/">1</a>
                </li>
                
            
                
                <li class="cube-pagination-index">
                    <a href="/page/2">2</a>
                </li>
                
            
                
                <li class="cube-pagination-index disabled">
                    <span>3</span>
                </li>
                
            
                
                <li class="cube-pagination-index">
                    <a href="/page/4">4</a>
                </li>
                
            
                <li class="cube-pagination-ellipses">
                    <span>...</span>
                </li>
                <li class="cube-pagination-index">
                    <a href="/page/19">19</a>
                </li>
        
    

    
    <li class="cube-pagination-next">
        <a href="/page/4/">Next »</a>
    </li>
    
</ul>

<!--其他组件后续添加-->
        </div>
        <div class="cube-right">
            

<div class="cube-search cube-sidebar" id="cube-search">
    <div class="search-container">
        <input type="text" placeholder="Search" class="cube-search-input" id="cube-search-input">
        <i class="cube-icon cube-icon-search cube-search-submit" aria-hidden="true"></i>
    </div>
    <!-- TODO 通过给window赋一个全局变量，通过脚本赋值 -->
</div>
<script>
    (function (window) {
        'use strict';
        window.searchModule = {}
        window.searchModule.JSONUrl = '/content.json'
        window.searchModule.rootUrl = '/'
    })(window)
</script>
<div class="cube-search-form">
    <div class="cube-search-control">
        <input type="text" placeholder="Search" class="search-input">
        <a class="close-button">
            <i class="cube-icon cube-close" aria-hidden="true"></i>
        </a>
    </div>
    <div class="cube-search-result"></div>
</div>


<div class="cube-author cube-sidebar" id="cube-author">
    
    
    <span>John Doe</span>
    
    
    <div class="count">
        <a class="count articles"><span>186</span>Article</a>
        <a class="count tags"><span>35</span>Tags</a>
        <a class="count categories"><span>23</span>Categories</a>
    </div>
</div>



<div class="cube-music cube-sidebar" id="cube-music">
    <div class="cube-player aplayer" id="cube-player"></div>
</div>
<script>
    (function (window) {
        window.musicModule = {}
        window.musicModule.musicConfig = '{"narrow":false,"autoplay":false,"showlrc":3,"theme":"#b7daff","mutex":true,"mode":"circulation","preload":"auto","listmaxheight":"513px","music":[{"title":"Dear friends","author":"TRIPLANE","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/TRIPLANE - Dear friends.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Dear friends - TRIPLANE.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/TRIPLANE - Dear friends.jpg"},{"title":"Butter-Fly","author":"和田光司","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/和田光司 - Butter-Fly (ピアノヴァージョン).mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Butter-Fly (ピアノヴァージョン) - 和田光司.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/和田光司 - Butter-Fly (ピアノヴァージョン).jpg"},{"title":"宵闇花火","author":"葉月ゆら","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/葉月ゆら - 宵闇花火.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/宵闇花火 - 葉月ゆら.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/葉月ゆら - 宵闇花火.jpg"}]}'
        window.musicModule.lrcConfig = {
            open: 'Open Lyrics',
            close: 'Close Lyrics'
        }
    })(window)
</script>



<div class="cube-recent-posts cube-sidebar" id="cube-recent-posts">
    <div class="title">
        <a>Recent Posts</a>
    </div>
    <ul class="list">
        
        
        <li>
            <!-- TODO 如果文章要显示图片，那么在front-matter上添加preview属性(url or path) -->
            
            <div class="normal">
                <p class="index first">
                    <span>1</span>
                </p>
                <p class="title">
                    <a href="/2022/08/25/Js%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="变量类型">变量类型</a>
                </p>
            </div>
            
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>2</span>
                </p>
                <p class="title">
                    <a href="/2022/07/15/bug/echarts%E5%9B%BE%E6%A0%87%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%B3%95/" title="echarts图标自适应方法">echarts图标自适应方法</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>3</span>
                </p>
                <p class="title">
                    <a href="/2022/07/15/bug/a01/" title="浏览器多进程与多线程">浏览器多进程与多线程</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>4</span>
                </p>
                <p class="title">
                    <a href="/2022/06/09/html+css+js+ts/3-js%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/" title="js-常用代码操作实例">js-常用代码操作实例</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>5</span>
                </p>
                <p class="title">
                    <a href="/2022/05/28/html+css+js+ts/1-%E9%9F%B3%E8%A7%86%E9%A2%91/" title="html-原生音视频">html-原生音视频</a>
                </p>
            </div>
        </li>
        
        
    </ul>
</div>



<div class="cube-categories cube-sidebar" id="cube-categories">
    <div class="title">
        <a href="/categories">Categories</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/categories/http/">#http</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/React/">#React</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">#数据可视化</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">#架构模式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/">#前端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">#移动端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E9%9F%B3%E8%A7%86%E9%A2%91/">#音视频</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/javascript/">#javascript</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">#问题</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/">#后端</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">#小程序</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">#前端工程化</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%B7%A5%E5%85%B7/">#工具</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">#正则表达式</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">#前端性能优化</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">#数据库</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/liunx/">#liunx</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a>
        </div>
        
    </div>
</div>



<div class="cube-tagcloud cube-sidebar" id="cube-tagcloud">
    <div class="title">
        <a href="/tags">Tagcloud</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/tags/http/">#http</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/vue/">#vue</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/React/">#React</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/Redux/">#Redux</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/echart/">#echart</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/vue3/">#vue3</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/react/">#react</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/html/">#html</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/xml/">#xml</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">#移动端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/css/">#css</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/javascript/">#javascript</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Promise/">#Promise</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/es6/">#es6</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/typescript/">#typescript</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/async-await/">#async/await</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/nodejs/">#nodejs</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">#小程序</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/python/">#python</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/glup/">#glup</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/webpack/">#webpack</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/git/">#git</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/Mock/">#Mock</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/eslint/">#eslint</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/RESTful/">#RESTful</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/hexo/">#hexo</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/vs-code/">#vs code</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">#正则表达式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E4%BC%98%E5%8C%96/">#优化</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/mongodb/">#mongodb</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/mysql/">#mysql</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/nginx/">#nginx</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a>
        </div>
        
    </div>
</div>



<div class="cube-links cube-sidebar" id="cube-links">
    <div class="title">
        <a>Links</a>
    </div>
    <ul class="list">
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/GitHub.png">
            
            <a href="https://github.com/ZEROKISEKI" target="_blank">GitHub</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/Coding.png">
            
            <a href="https://coding.net/u/SORA1" target="_blank">Coding</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/SF.png">
            
            <a href="https://segmentfault.com/u/aonosora" target="_blank">SF社区</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/开发者头条.png">
            
            <a href="https://toutiao.io/u/148070" target="_blank">开发者头条</a>
        </li>
        
    </ul>
</div>



<div class="cube-friend-links cube-sidebar" id="cube-friend-links">
    <div class="title">
        <a>Friend Links</a>
    </div>
    <ul class="list">
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/micblo.png">
            <a href="https://blog.micblo.com/" target="_blank">罗大佬</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/DIYgod.jpg">
            <a href="https://www.anotherhome.net/" target="_blank">DIYgod</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="/images/friend_links.jpg ">
            <a href="https://aonosora.com/" target="_blank">咪西西の部落格</a>
        </li>
        
    </ul>
</div>


        </div>
    </div>
</div>
<footer class="cube-footer">
    
© 2017 John Doe

<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.&nbsp;Theme by <a href="https://github.com/ZEROKISEKI" target="_blank">AONOSORA</a>
</footer>
<!-- inject:script -->
<script src="/js/script.js"></script>
<!-- endinject -->
<div class="cube-loading out"></div>
</body>
</html>