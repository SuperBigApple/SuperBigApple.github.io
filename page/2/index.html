<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-html+css+js+ts/5-Typescript总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/23/html+css+js+ts/5-Typescript%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-08-23T02:31:24.000Z" itemprop="datePublished">2021-08-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/23/html+css+js+ts/5-Typescript%E6%80%BB%E7%BB%93/">Typescript总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-1-什么是-TypeScript"><a href="#1-1-什么是-TypeScript" class="headerlink" title="1.1 什么是 TypeScript"></a>1.1 什么是 TypeScript</h2><ul>
<li><code>TypeScript</code> 是 <code>JavaScript</code> 的一个超集，主要提供了类型系统和对 <code>ES6</code>的支持</li>
<li><code>TypeScript</code> 是由微软开发的一款开源的编程语言</li>
<li><code>TypeScript</code> 是 <code>Javascript</code> 的超级，遵循最新的 <code>ES6</code>、<code>Es5</code> 规范。<code>TypeScript</code> 扩展了 <code>JavaScript</code> 的语法</li>
<li><code>TypeScript</code> 更像后端 <code>java</code>、<code>C#</code>这样的面向对象语言可以让 <code>js</code> 开发大型企业项目</li>
</ul>
<h2 id="1-2-为什么选择-TypeScript"><a href="#1-2-为什么选择-TypeScript" class="headerlink" title="1.2 为什么选择 TypeScript"></a>1.2 为什么选择 TypeScript</h2><blockquote>
<p><code>Typescript</code>和<code>es6</code>、<code>es5</code>关系</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/583.png" alt="img"></p>
<p><strong>TypeScript 增加了代码的可读性和可维护性</strong></p>
<ul>
<li>类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了</li>
<li>可以在编译阶段就发现大部分错误，这总比在运行时候出错好</li>
<li>增强了编辑器和 <code>IDE</code> 的功能，包括代码补全、接口提示、跳转到定义、重构等</li>
</ul>
<p><strong>TypeScript 非常包容</strong></p>
<ul>
<li><code>TypeScript</code> 是 <code>JavaScript</code> 的超集，<code>.js</code> 文件可以直接重命名为 <code>.ts</code> 即可</li>
<li>即使不显式的定义类型，也能够自动做出类型推论</li>
<li>可以定义从简单到复杂的几乎一切类型</li>
<li>即使 <code>TypeScript</code> 编译报错，也可以生成 <code>JavaScript</code> 文件</li>
<li>兼容第三方库，即使第三方库不是用 <code>TypeScript</code> 写的，也可以编写单独的类型文件供 <code>TypeScript</code> 读取</li>
</ul>
<p><strong>TypeScript 拥有活跃的社区</strong></p>
<ul>
<li>大部分第三方库都有提供给 <code>TypeScript</code> 的类型定义文件</li>
<li><code>Google</code> 开发的<code>Angular2</code> 就是使用 <code>TypeScript</code> 编写的</li>
<li><code>TypeScript</code> 拥抱了 <code>ES6</code> 规范，也支持部分 <code>ESNext</code> 草案的规范</li>
<li>最新的 <code>Vue</code> 、<code>React</code> 也可以集成 <code>TypeScript</code></li>
</ul>
<p><strong>TypeScript 的缺点</strong></p>
<ul>
<li>有一定的学习成本，需要理解接口（<code>Interfaces</code>）、泛型（<code>Generics</code>）、类（<code>Classes</code>）、枚举类型（<code>Enums</code>）等前端工程师可能不是很熟悉的概念</li>
<li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，<code>TypeScript</code> 能够减少其维护成本</li>
<li>集成到构建流程需要一些工作量</li>
<li>可能和一些库结合的不是很完美</li>
</ul>
<h2 id="1-3-安装-TypeScript"><a href="#1-3-安装-TypeScript" class="headerlink" title="1.3 安装 TypeScript"></a>1.3 安装 TypeScript</h2><p><strong>typescript 安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局安装完成后，我们新建一个<code>hello.ts</code>的<code>ts</code>文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.ts内容</span><br><span class="line">let a = &quot;poet&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来我们在命令行输入<code>tsc hello.ts</code>来编译这个<code>ts</code>文件，然后会在同级目录生成一个编译好了的<code>hello.js</code>文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.js内容</span><br><span class="line">var = &quot;poet&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么我们每次都要输<code>tsc hello.ts</code>命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，使用<code>vscode</code>来开发，需要配置一下<code>vscode</code>就可以。</p>
</blockquote>
<blockquote>
<p>首先我们在命令行执行<code>tsc --init</code>来生成配置文件，然后我们在目录下看到生成了一个<code>tsconfig.json</code>文件</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/584.png" alt="img"></p>
<blockquote>
<p>这个<code>json</code>文件里有很多选项</p>
</blockquote>
<ul>
<li><code>target</code>是选择编译到什么语法</li>
<li><code>module</code>则是模块类型</li>
<li><code>outDir</code>则是输出目录，可以指定这个参数到指定目录</li>
</ul>
<blockquote>
<p>更多细节 <a target="_blank" rel="noopener" href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html</a></p>
</blockquote>
<blockquote>
<p>接下来我们需要开启监控了，在<code>vscode</code>任务栏中</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/585.png" alt="img"></p>
<h2 id="1-4-Hello-TypeScript"><a href="#1-4-Hello-TypeScript" class="headerlink" title="1.4 Hello TypeScript"></a>1.4 Hello TypeScript</h2><blockquote>
<p>将以下代码复制到 <code>hello.ts</code> 中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(person: string) &#123;</span><br><span class="line">    return &#x27;Hello, &#x27; + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = &#x27;poetries&#x27;;</span><br><span class="line">console.log(sayHello(user));</span><br><span class="line">tsc hello.ts</span><br><span class="line">//这时候会生成一个编译好的文件 hello.js：</span><br><span class="line"></span><br><span class="line">function sayHello(person) &#123;</span><br><span class="line">    return &#x27;Hello, &#x27; + person;</span><br><span class="line">&#125;</span><br><span class="line">var user = &#x27;poetries&#x27;;</span><br><span class="line">console.log(sayHello(user));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>TypeScript</code> 中，使用 <code>:</code> 指定变量的类型，<code>:</code> 的前后有没有空格都可以</p>
</blockquote>
<ul>
<li><code>TypeScript</code> 只会进行静态检查，如果发现有错误，编译的时候就会报错</li>
<li><code>TypeScript</code> 编译的时候即使报错了，还是会生成编译结果，我们仍然可以使用这个编译之后的文件</li>
</ul>
<h1 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h1><h2 id="2-1-原始数据类型"><a href="#2-1-原始数据类型" class="headerlink" title="2.1 原始数据类型"></a>2.1 原始数据类型</h2><blockquote>
<p><code>JavaScript</code> 的类型分为两种：原始数据类型（<code>Primitive data types</code>）和对象类型（<code>Object types</code>）。</p>
</blockquote>
<ul>
<li>原始数据类型包括：<code>布尔值</code>、<code>数值</code>、<code>字符串</code>、<code>null</code>、<code>undefined</code> 以及 <code>ES6</code>中的新类型 <code>Symbol</code>。</li>
</ul>
<blockquote>
<p>本节主要介绍前五种原始数据类型在 <code>TypeScript</code> 中的应用</p>
</blockquote>
<h3 id="2-1-1-布尔值"><a href="#2-1-1-布尔值" class="headerlink" title="2.1.1 布尔值"></a>2.1.1 布尔值</h3><blockquote>
<p>布尔值是最基础的数据类型，在 <code>TypeScript</code> 中，使用 <code>boolean</code> 定义布尔值类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let isDone: boolean = false;</span><br><span class="line"></span><br><span class="line">// 编译通过</span><br><span class="line">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，使用构造函数 <code>Boolean</code> 创造的对象不是布尔值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let createdByNewBoolean: boolean = new Boolean(1);</span><br><span class="line"></span><br><span class="line">// index.ts(1,5): error TS2322: Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.</span><br><span class="line">// 后面约定，注释中标出了编译报错的代码片段，表示编译未通过</span><br></pre></td></tr></table></figure>

<ul>
<li>事实上 <code>new Boolean()</code> 返回的是一个 <code>Boolean</code> 对象：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let createdByNewBoolean: Boolean = new Boolean(1);</span><br></pre></td></tr></table></figure>

<ul>
<li>直接调用 <code>Boolean</code> 也可以返回一个 <code>boolean</code> 类型：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let createdByBoolean: boolean = Boolean(1);</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>TypeScript</code> 中，<code>boolean</code>是 <code>JavaScript</code> 中的基本类型，而 <code>Boolean</code> 是 <code>JavaScript</code>中的构造函数。其他基本类型（除了 <code>null</code> 和 <code>undefined</code>）一样</li>
</ul>
<h3 id="2-1-2-数值"><a href="#2-1-2-数值" class="headerlink" title="2.1.2 数值"></a>2.1.2 数值</h3><blockquote>
<p>使用 <code>number</code> 定义数值类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line"></span><br><span class="line">// ES6 中的二进制表示法</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line"></span><br><span class="line">// ES6 中的八进制表示法</span><br><span class="line">let octalLiteral: number = 0o744;</span><br><span class="line">let notANumber: number = NaN;</span><br><span class="line">let infinityNumber: number = Infinity;</span><br><span class="line">//编译结果：</span><br><span class="line"></span><br><span class="line">var decLiteral = 6;</span><br><span class="line">var hexLiteral = 0xf00d;</span><br><span class="line">// ES6 中的二进制表示法</span><br><span class="line">var binaryLiteral = 10;</span><br><span class="line">// ES6 中的八进制表示法</span><br><span class="line">var octalLiteral = 484;</span><br><span class="line">var notANumber = NaN;</span><br><span class="line">var infinityNumber = Infinity;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中 <code>0b101</code>0 和 <code>0o744</code>是 <code>ES6</code> 中的二进制和八进制表示法，它们会被编译为十进制数字</p>
</blockquote>
<h3 id="2-1-3-字符串"><a href="#2-1-3-字符串" class="headerlink" title="2.1.3 字符串"></a>2.1.3 字符串</h3><blockquote>
<p>使用 <code>string</code> 定义字符串类型：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let myName: string = &#x27;Tom&#x27;;</span><br><span class="line">let myAge: number = 25;</span><br><span class="line"></span><br><span class="line">// 模板字符串</span><br><span class="line">let sentence: string = `Hello, my name is $&#123;myName&#125;.</span><br><span class="line">I&#x27;ll be $&#123;myAge + 1&#125; years old next month.`;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-空值"><a href="#2-1-4-空值" class="headerlink" title="2.1.4 空值"></a>2.1.4 空值</h3><blockquote>
<p><code>JavaScript</code> 没有空值（<code>Void</code>）的概念，在 <code>TypeScript</code> 中，可以用 <code>void</code> 表示没有任何返回值的函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function alertName(): void &#123;</span><br><span class="line">    alert(&#x27;My name is Tom&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code>和 <code>null</code>：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-Null-和-Undefined"><a href="#2-1-5-Null-和-Undefined" class="headerlink" title="2.1.5 Null 和 Undefined"></a>2.1.5 Null 和 Undefined</h3><blockquote>
<p>在 <code>TypeScript</code> 中，可以使用 <code>null</code> 和 <code>undefined</code>来定义这两个原始数据类型：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined` 类型的变量只能被赋值为 `undefined`，`null` 类型的变量只能被赋值为 `null</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>与 <code>void</code> 的区别是，<code>undefined</code>和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 这样不会报错</span><br><span class="line">let num: number = undefined;</span><br><span class="line"></span><br><span class="line">// 这样也不会报错</span><br><span class="line">let u: undefined;</span><br><span class="line">let num: number = u;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而 <code>void</code> 类型的变量不能赋值给 <code>number</code> 类型的变量：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let u: void;</span><br><span class="line">let num: number = u;</span><br><span class="line"></span><br><span class="line">// index.ts(2,5): error TS2322: Type &#x27;void&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="2-2-任意值Any"><a href="#2-2-任意值Any" class="headerlink" title="2.2 任意值Any"></a>2.2 任意值Any</h2><blockquote>
<p>如果是一个普通类型，在赋值过程中改变类型是不被允许的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: any = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure>

<p><strong>任意值的属性和方法</strong></p>
<p>在任意值上访问任何属性都是允许的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let anyThing: any = &#x27;hello&#x27;;</span><br><span class="line"></span><br><span class="line">console.log(anyThing.myName);</span><br><span class="line">console.log(anyThing.myName.firstName);</span><br></pre></td></tr></table></figure>

<p><strong>也允许调用任何方法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let anyThing: any = &#x27;Tom&#x27;;</span><br><span class="line"></span><br><span class="line">anyThing.setName(&#x27;Jerry&#x27;);</span><br><span class="line">anyThing.setName(&#x27;Jerry&#x27;).sayHello();</span><br><span class="line">anyThing.myName.setFirstName(&#x27;Cat&#x27;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</p>
</blockquote>
<p><strong>未声明类型的变量</strong></p>
<blockquote>
<p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let something;</span><br><span class="line">something = &#x27;seven&#x27;;</span><br><span class="line">something = 7;</span><br><span class="line"></span><br><span class="line">something.setName(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let something: any;</span><br><span class="line">something = &#x27;seven&#x27;;</span><br><span class="line">something = 7;</span><br><span class="line"></span><br><span class="line">something.setName(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="2-3-类型推论"><a href="#2-3-类型推论" class="headerlink" title="2.3 类型推论"></a>2.3 类型推论</h2><blockquote>
<p>如果没有明确的指定类型，那么 <code>TypeScript</code> 会依照类型推论（<code>Type Inference</code>）的规则推断出一个类型</p>
</blockquote>
<p><strong>什么是类型推论</strong></p>
<p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>

<p>事实上，它等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>

<p><code>TypeScript</code> 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论</p>
<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber;</span><br><span class="line"></span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-联合类型"><a href="#2-4-联合类型" class="headerlink" title="2.4 联合类型"></a>2.4 联合类型</h2><blockquote>
<p>联合类型（<code>Union Types</code>）表示取值可以为多种类型中的一种</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 简单例子</span><br><span class="line"></span><br><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = true;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;boolean&#x27; is not assignable to type &#x27;string | number&#x27;.</span><br><span class="line">//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<ul>
<li>联合类型使用 <code>|</code> 分隔每个类型。</li>
<li>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型</li>
</ul>
<p><strong>访问联合类型的属性或方法</strong></p>
<blockquote>
<p>当 <code>TypeScript</code> 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// length 不是 string 和 number 的共有属性，所以会报错</span><br><span class="line">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getString(something: string | number): string &#123;</span><br><span class="line">    return something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line"></span><br><span class="line">console.log(myFavoriteNumber.length); // 5</span><br><span class="line"></span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line">console.log(myFavoriteNumber.length); // 编译时报错</span><br><span class="line"></span><br><span class="line">// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</li>
<li>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了</li>
</ul>
<h2 id="2-5-对象的类型——接口"><a href="#2-5-对象的类型——接口" class="headerlink" title="2.5 对象的类型——接口"></a>2.5 对象的类型——接口</h2><h3 id="2-5-1-简单例子"><a href="#2-5-1-简单例子" class="headerlink" title="2.5.1 简单例子"></a>2.5.1 简单例子</h3><blockquote>
<p>在 <code>TypeScript</code> 中，我们使用接口（<code>Interfaces</code>）来定义对象的类型</p>
</blockquote>
<p><strong>什么是接口</strong></p>
<ul>
<li>在面向对象语言中，接口（<code>Interfaces</code>）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（<code>classes</code>）去实现（<code>implements</code>）。</li>
<li><code>TypeScript</code> 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（<code>Shape</code>）」进行描述。</li>
</ul>
<p>接口一般首字母大写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致</p>
</blockquote>
<p><strong>定义的变量比接口少了一些属性是不允许的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(6,5): error TS2322: Type &#x27;&#123; name: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27;.</span><br></pre></td></tr></table></figure>

<p><strong>多一些属性也是不允许的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(9,5): error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见，赋值的时候，变量的形状必须和接口的形状保持一致。</p>
</blockquote>
<h3 id="2-5-2-可选属性"><a href="#2-5-2-可选属性" class="headerlink" title="2.5.2 可选属性"></a>2.5.2 可选属性</h3><blockquote>
<p>有时我们希望不要完全匹配一个形状，那么可以用可选属性</p>
</blockquote>
<p>可选属性的含义是该属性可以不存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-3-任意属性"><a href="#2-5-3-任意属性" class="headerlink" title="2.5.3 任意属性"></a>2.5.3 任意属性</h3><blockquote>
<p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值</li>
<li>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span><br><span class="line">// index.ts(7,5): error TS2322: Type &#x27;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Index signatures are incompatible.</span><br><span class="line">//     Type &#x27;string | number&#x27; is not assignable to type &#x27;string&#x27;.</span><br><span class="line">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code>不是 <code>string</code> 的子属性，所以报错了。</li>
<li>另外，在报错信息中可以看出，此时 <code>&#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;</code>的类型被推断成了 <code>&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;</code>，这是联合类型和接口的结合</li>
</ul>
<h3 id="2-5-4-只读属性"><a href="#2-5-4-只读属性" class="headerlink" title="2.5.4 只读属性"></a>2.5.4 只读属性</h3><blockquote>
<p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code>定义只读属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    id: 89757,</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 9527;</span><br><span class="line"></span><br><span class="line">// index.ts(14,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了</p>
</blockquote>
<p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 89757;</span><br><span class="line"></span><br><span class="line">// index.ts(8,5): error TS2322: Type &#x27;&#123; name: string; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; gender: string; &#125;&#x27;.</span><br><span class="line">// index.ts(13,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</li>
<li>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了</li>
</ul>
<h2 id="2-6-数组的类型"><a href="#2-6-数组的类型" class="headerlink" title="2.6 数组的类型"></a>2.6 数组的类型</h2><blockquote>
<p>在 <code>TypeScript</code> 中，数组类型有多种定义方式，比较灵活。</p>
</blockquote>
<h3 id="2-6-1「类型-方括号」表示法"><a href="#2-6-1「类型-方括号」表示法" class="headerlink" title="2.6.1「类型 + 方括号」表示法"></a>2.6.1「类型 + 方括号」表示法</h3><blockquote>
<p>最简单的方法是使用「类型 + 方括号」来表示数组：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组的项中不允许出现其他的类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, &#x27;1&#x27;, 2, 3, 5];</span><br><span class="line"></span><br><span class="line">// index.ts(1,5): error TS2322: Type &#x27;(number | string)[]&#x27; is not assignable to type &#x27;number[]&#x27;.</span><br><span class="line">//   Type &#x27;number | string&#x27; is not assignable to type &#x27;number&#x27;.</span><br><span class="line">//     Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，<code>[1, &#39;1&#39;, 2, 3, 5]</code> 的类型被推断为 <code>(number | string)[]</code>，这是联合类型和数组的结合。</li>
<li>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br><span class="line">fibonacci.push(&#x27;8&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(2,16): error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>string</code> 类型的参数，所以报错了</p>
</blockquote>
<h3 id="2-6-2-数组泛型"><a href="#2-6-2-数组泛型" class="headerlink" title="2.6.2 数组泛型"></a>2.6.2 数组泛型</h3><blockquote>
<p>也可以使用数组泛型（<code>Array Generic</code>）<code>Array</code>来表示数组</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure>

<h3 id="2-6-3-用接口表示数组"><a href="#2-6-3-用接口表示数组" class="headerlink" title="2.6.3 用接口表示数组"></a>2.6.3 用接口表示数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index: number]: number;</span><br><span class="line">&#125;</span><br><span class="line">let fibonacci: NumberArray = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NumberArray` 表示：只要 `index` 的类型是 `number`，那么值的类型必须是 `number</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-6-4-any-在数组中的应用"><a href="#2-6-4-any-在数组中的应用" class="headerlink" title="2.6.4 any 在数组中的应用"></a>2.6.4 any 在数组中的应用</h3><blockquote>
<p>一个比较常见的做法是，用 <code>any</code> 表示数组中允许出现任意类型：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] = [&#x27;poetries&#x27;, 22, &#123; website: &#x27;http://blog.poetries.top&#x27; &#125;];</span><br></pre></td></tr></table></figure>

<h3 id="2-6-5-类数组"><a href="#2-6-5-类数组" class="headerlink" title="2.6.5 类数组"></a>2.6.5 类数组</h3><blockquote>
<p>类数组（<code>Array-like Object</code>）不是数组类型，比如 <code>arguments</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let args: number[] = arguments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,7): error TS2322: Type &#x27;IArguments&#x27; is not assignable to type &#x27;number[]&#x27;.</span><br><span class="line">//   Property &#x27;push&#x27; is missing in type &#x27;IArguments&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上常见的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let args: IArguments = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-函数的类型"><a href="#2-7-函数的类型" class="headerlink" title="2.7 函数的类型"></a>2.7 函数的类型</h2><h3 id="2-7-1-函数声明"><a href="#2-7-1-函数声明" class="headerlink" title="2.7.1 函数声明"></a>2.7.1 函数声明</h3><blockquote>
<p>在 <code>JavaScript</code> 中，有两种常见的定义函数的方式——函数声明（<code>Function Declaration</code>）和函数表达式（<code>Function Expression</code>）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明（Function Declaration）</span><br><span class="line">function sum(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式（Function Expression）</span><br><span class="line">let mySum = function (x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个函数有输入和输出，要在 <code>TypeScript</code> 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，输入多余的（或者少于要求的）参数，是不被允许的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1, 2, 3);</span><br><span class="line"></span><br><span class="line">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1);</span><br><span class="line"></span><br><span class="line">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-函数表达式"><a href="#2-7-2-函数表达式" class="headerlink" title="2.7.2 函数表达式"></a>2.7.2 函数表达式</h3><blockquote>
<p>如果要我们现在写一个对函数表达式（<code>Function Expression</code>）的定义，可能会写成这样</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let mySum = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// =&gt;左边 (x: number, y: number) 是输入类型 </span><br><span class="line">// =&gt;右边number是输出类型</span><br><span class="line">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意不要混淆了 TypeScript 中的 &#x3D;&gt; 和 ES6 中的 &#x3D;&gt;</strong></p>
<blockquote>
<p>在 <code>TypeScript</code> 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>
</blockquote>
<h3 id="2-7-3-用接口定义函数的形状"><a href="#2-7-3-用接口定义函数的形状" class="headerlink" title="2.7.3 用接口定义函数的形状"></a>2.7.3 用接口定义函数的形状</h3><blockquote>
<p>我们也可以使用接口的方式来定义一个函数需要符合的形状</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必须参数了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName?: string, lastName: string) &#123;</span><br><span class="line">    if (firstName) &#123;</span><br><span class="line">        return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(undefined, &#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span><br></pre></td></tr></table></figure>

<h3 id="2-7-4-参数默认值"><a href="#2-7-4-参数默认值" class="headerlink" title="2.7.4 参数默认值"></a>2.7.4 参数默认值</h3><blockquote>
<p>在 <code>ES6</code>中，我们允许给函数的参数添加默认值，<code>TypeScript</code> 会将添加了默认值的参数识别为可选参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName: string = &#x27;Cat&#x27;) &#123;</span><br><span class="line">    return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>此时就不受「可选参数必须接在必需参数后面」的限制了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string = &#x27;Tom&#x27;, lastName: string) &#123;</span><br><span class="line">    return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let cat = buildName(undefined, &#x27;Cat&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="2-7-5-剩余参数"><a href="#2-7-5-剩余参数" class="headerlink" title="2.7.5 剩余参数"></a>2.7.5 剩余参数</h3><blockquote>
<p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（<code>rest</code> 参数）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上，items 是一个数组。所以我们可以用数组的类型来定义它</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function push(array: any[], ...items: any[]) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，rest 参数只能是最后一个参数</p>
</blockquote>
<h3 id="2-7-6-函数重载"><a href="#2-7-6-函数重载" class="headerlink" title="2.7.6 函数重载"></a>2.7.6 函数重载</h3><ul>
<li>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</li>
</ul>
<blockquote>
<p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code></p>
</blockquote>
<p><strong>利用联合类型，我们可以这么实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串</p>
</blockquote>
<p><strong>这时，我们可以使用重载定义多个 reverse 的函数类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line"></span><br><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</li>
</ul>
<blockquote>
<p><strong>注意</strong>，<code>TypeScript</code> 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面</p>
</blockquote>
<h2 id="2-8-类型断言"><a href="#2-8-类型断言" class="headerlink" title="2.8 类型断言"></a>2.8 类型断言</h2><blockquote>
<p>类型断言（<code>Type Assertion</code>）可以用来手动指定一个值的类型。</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">值 as 类型</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>tsx</code> 语法（<code>React</code> 的 <code>jsx</code> 语法的 <code>ts</code> 版）中必须用后一种</p>
</blockquote>
<p><strong>例子：将一个联合类型的变量指定为一个更加具体的类型</strong></p>
<blockquote>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if (something.length) &#123;</span><br><span class="line">        return something.length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br><span class="line">// index.ts(3,26): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，获取 <code>something.length</code>的时候会报错</p>
</blockquote>
<p><strong>此时可以使用类型断言，将 something 断言成 string</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if ((&lt;string&gt;something).length) &#123;</span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类型断言的用法如上，在需要断言的变量前加上 &#96;&#96; 即可</p>
</blockquote>
<p><strong>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function toBoolean(something: string | number): boolean &#123;</span><br><span class="line">    return &lt;boolean&gt;something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,10): error TS2352: Type &#x27;string | number&#x27; cannot be converted to type &#x27;boolean&#x27;.</span><br><span class="line">//   Type &#x27;number&#x27; is not comparable to type &#x27;boolean&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="2-9-声明文件"><a href="#2-9-声明文件" class="headerlink" title="2.9 声明文件"></a>2.9 声明文件</h2><blockquote>
<p>当使用第三方库时，我们需要引用它的声明文件</p>
</blockquote>
<h3 id="2-9-1-声明-declare-语句"><a href="#2-9-1-声明-declare-语句" class="headerlink" title="2.9.1 声明(declare)语句"></a>2.9.1 声明(declare)语句</h3><blockquote>
<p>假如我们想使用第三方库，比如 <code>jQuery</code>，我们通常这样获取一个 <code>id</code> 是 <code>foo</code> 的元素</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;#foo&#x27;);</span><br><span class="line">// or</span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是在 <code>TypeScript</code> 中，我们并不知道 <code>$</code> 或 <code>jQuery</code>是什么东西</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery(&#x27;#foo&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(1,1): error TS2304: Cannot find name &#x27;jQuery&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这时，我们需要使用 <code>declare</code> 关键字来定义它的类型，帮助<code>TypeScript</code> 判断我们传入的参数类型对不对</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare var jQuery: (selector: string) =&gt; any;</span><br><span class="line"></span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//上例的编译结果是：</span><br><span class="line"></span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="2-9-2-声明文件-约定-d-ts后缀"><a href="#2-9-2-声明文件-约定-d-ts后缀" class="headerlink" title="2.9.2 声明文件(约定.d.ts后缀)"></a>2.9.2 声明文件(约定.d.ts后缀)</h3><blockquote>
<p>通常我们会把类型声明放到一个单独的文件中，这就是声明文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// jQuery.d.ts</span><br><span class="line"></span><br><span class="line">declare var jQuery: (string) =&gt; any;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们约定声明文件以 <code>.d.ts</code> 为后缀。</li>
<li>然后在使用到的文件的开头，用<code>「三斜线指令」///</code>表示引用了声明文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;reference path=&quot;./jQuery.d.ts&quot; /&gt;</span><br><span class="line"></span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="2-9-3-第三方声明文件"><a href="#2-9-3-第三方声明文件" class="headerlink" title="2.9.3 第三方声明文件"></a>2.9.3 第三方声明文件</h3><blockquote>
<p>当然，<code>jQuery</code> 的声明文件不需要我们定义了，已经有人帮我们定义好了：<a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/index.d.ts">jQuery in DefinitelyTyped</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/index.d.ts</span><br><span class="line"></span><br><span class="line">// Type definitions for jquery 3.3</span><br><span class="line">// Project: https://jquery.com</span><br><span class="line">// Definitions by: Leonard Thieu &lt;https://github.com/leonard-thieu&gt;</span><br><span class="line">//                 Boris Yankov &lt;https://github.com/borisyankov&gt;</span><br><span class="line">//                 Christian Hoffmeister &lt;https://github.com/choffmeister&gt;</span><br><span class="line">//                 Steve Fenton &lt;https://github.com/Steve-Fenton&gt;</span><br><span class="line">//                 Diullei Gomes &lt;https://github.com/Diullei&gt;</span><br><span class="line">//                 Tass Iliopoulos &lt;https://github.com/tasoili&gt;</span><br><span class="line">//                 Jason Swearingen &lt;https://github.com/jasons-novaleaf&gt;</span><br><span class="line">//                 Sean Hill &lt;https://github.com/seanski&gt;</span><br><span class="line">//                 Guus Goossens &lt;https://github.com/Guuz&gt;</span><br><span class="line">//                 Kelly Summerlin &lt;https://github.com/ksummerlin&gt;</span><br><span class="line">//                 Basarat Ali Syed &lt;https://github.com/basarat&gt;</span><br><span class="line">//                 Nicholas Wolverson &lt;https://github.com/nwolverson&gt;</span><br><span class="line">//                 Derek Cicerone &lt;https://github.com/derekcicerone&gt;</span><br><span class="line">//                 Andrew Gaspar &lt;https://github.com/AndrewGaspar&gt;</span><br><span class="line">//                 Seikichi Kondo &lt;https://github.com/seikichi&gt;</span><br><span class="line">//                 Benjamin Jackman &lt;https://github.com/benjaminjackman&gt;</span><br><span class="line">//                 Poul Sorensen &lt;https://github.com/s093294&gt;</span><br><span class="line">//                 Josh Strobl &lt;https://github.com/JoshStrobl&gt;</span><br><span class="line">//                 John Reilly &lt;https://github.com/johnnyreilly&gt;</span><br><span class="line">//                 Dick van den Brink &lt;https://github.com/DickvdBrink&gt;</span><br><span class="line">//                 Thomas Schulz &lt;https://github.com/King2500&gt;</span><br><span class="line">//                 Terry Mun &lt;https://github.com/terrymun&gt;</span><br><span class="line">// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped</span><br><span class="line">// TypeScript Version: 2.3</span><br><span class="line"></span><br><span class="line">// 引入声明文件</span><br><span class="line">/// &lt;reference types=&quot;sizzle&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;</span><br><span class="line"></span><br><span class="line">export = jQuery;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以直接下载下来使用，但是更推荐的是使用工具统一管理第三方库的声明文件- 社区已经有多种方式引入声明文件，不过 <code>TypeScript 2.0</code>推荐使用 <code>@types</code> 来管理。</li>
<li><code>@types</code> 的使用方式很简单，直接用 <code>npm</code> 安装对应的声明模块即可，以 <code>jQuery</code> 举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure>

<p><strong>可以在这个页面搜索你需要的声明文件</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://microsoft.github.io/TypeSearch/">http://microsoft.github.io/TypeSearch/</a></p>
</blockquote>
<h2 id="2-10-内置对象"><a href="#2-10-内置对象" class="headerlink" title="2.10 内置对象"></a>2.10 内置对象</h2><blockquote>
<p><code>JavaScript</code> 中有很多内置对象，它们可以直接在 <code>TypeScript</code> 中当做定义好了的类型</p>
</blockquote>
<blockquote>
<p>内置对象是指根据标准在全局作用域（<code>Global</code>）上存在的对象。这里的标准是指 <code>ECMAScript</code> 和其他环境（比如 <code>DOM</code>）的标准</p>
</blockquote>
<h3 id="2-10-1-ECMAScript-的内置对象"><a href="#2-10-1-ECMAScript-的内置对象" class="headerlink" title="2.10.1 ECMAScript 的内置对象"></a>2.10.1 ECMAScript 的内置对象</h3><p><strong>ECMAScript 标准提供的内置对象有</strong></p>
<blockquote>
<p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等</p>
</blockquote>
<p>我们可以在 <code>TypeScript</code> 中将变量定义为这些类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let b: Boolean = new Boolean(1);</span><br><span class="line"></span><br><span class="line">let e: Error = new Error(&#x27;Error occurred&#x27;);</span><br><span class="line"></span><br><span class="line">let d: Date = new Date();</span><br><span class="line"></span><br><span class="line">let r: RegExp = /[a-z]/;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多的内置对象，可以查看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">MDN 的文档</a></p>
</blockquote>
<blockquote>
<p>而他们的定义文件，则在 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件中</a></p>
</blockquote>
<h3 id="2-10-2-DOM-和-BOM-的内置对象"><a href="#2-10-2-DOM-和-BOM-的内置对象" class="headerlink" title="2.10.2 DOM 和 BOM 的内置对象"></a>2.10.2 DOM 和 BOM 的内置对象</h3><p><strong>DOM 和 BOM 提供的内置对象有</strong></p>
<blockquote>
<p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p>
</blockquote>
<blockquote>
<p>TypeScript 中会经常用到这些类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let body: HTMLElement = document.body;</span><br><span class="line">let allDiv: NodeList = document.querySelectorAll(&#x27;div&#x27;);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#x27;click&#x27;, function(e: MouseEvent) &#123;</span><br><span class="line">  // Do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>它们的定义文件同样在 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件中</a></p>
</blockquote>
<h3 id="2-10-3-TypeScript-核心库的定义文件"><a href="#2-10-3-TypeScript-核心库的定义文件" class="headerlink" title="2.10.3 TypeScript 核心库的定义文件"></a>2.10.3 TypeScript 核心库的定义文件</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库</a>的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的</p>
</blockquote>
<blockquote>
<p>当你在使用一些常用的方法的时候，<code>TypeScript</code> 实际上已经帮你做了很多类型判断的工作了，比如</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(10, &#x27;2&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(1,14): error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code>的类型定义如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Math &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the value of a base expression taken to a specified power.</span><br><span class="line">     * @param x The base value of the expression.</span><br><span class="line">     * @param y The exponent value of the expression.</span><br><span class="line">     */</span><br><span class="line">    pow(x: number, y: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再举一个 <code>DOM</code> 中的例子</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;click&#x27;, function(e) &#123;</span><br><span class="line">    console.log(e.targetCurrent);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// index.ts(2,17): error TS2339: Property &#x27;targetCurrent&#x27; does not exist on type &#x27;MouseEvent&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，<code>addEventListener</code> 方法是在 <code>TypeScript</code> 核心库中定义的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;</span><br><span class="line">    addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?: boolean): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了</p>
</blockquote>
<p><strong>注意，TypeScript 核心库的定义中不包含 Node.js 部分</strong></p>
<h3 id="2-10-4-用-TypeScript-写-Node-js"><a href="#2-10-4-用-TypeScript-写-Node-js" class="headerlink" title="2.10.4 用 TypeScript 写 Node.js"></a>2.10.4 用 TypeScript 写 Node.js</h3><blockquote>
<p><code>Node.js</code> 不是内置对象的一部分，如果想用 <code>TypeScript</code> 写 <code>Node.js</code>，则需要引入第三方声明文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/node --save-dev</span><br></pre></td></tr></table></figure>

<h1 id="三、进阶"><a href="#三、进阶" class="headerlink" title="三、进阶"></a>三、进阶</h1><h2 id="3-1-类型别名"><a href="#3-1-类型别名" class="headerlink" title="3.1 类型别名"></a>3.1 类型别名</h2><blockquote>
<p>类型别名用来给一个类型起个新名字</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Name = string;</span><br><span class="line"></span><br><span class="line">type NameResolver = () =&gt; string;</span><br><span class="line"></span><br><span class="line">type NameOrResolver = Name | NameResolver; // 联合类型</span><br><span class="line"></span><br><span class="line">function getName(n: NameOrResolver): Name &#123;</span><br><span class="line">    if (typeof n === &#x27;string&#x27;) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，我们使用 <code>type</code> 创建类型别名。</p>
<blockquote>
<p>类型别名常用于联合类型</p>
</blockquote>
<h2 id="3-2-字符串字面量类型"><a href="#3-2-字符串字面量类型" class="headerlink" title="3.2 字符串字面量类型"></a>3.2 字符串字面量类型</h2><blockquote>
<p>字符串字面量类型用来约束取值只能是某几个字符串中的一个</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type EventNames = &#x27;click&#x27; | &#x27;scroll&#x27; | &#x27;mousemove&#x27;;</span><br><span class="line">function handleEvent(ele: Element, event: EventNames) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleEvent(document.getElementById(&#x27;hello&#x27;), &#x27;scroll&#x27;);  // 没问题</span><br><span class="line">handleEvent(document.getElementById(&#x27;world&#x27;), &#x27;dbclick&#x27;); // 报错，event 不能为 &#x27;dbclick&#x27;</span><br><span class="line"></span><br><span class="line">// index.ts(7,47): error TS2345: Argument of type &#x27;&quot;dbclick&quot;&#x27; is not assignable to parameter of type &#x27;EventNames&#x27;.</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</li>
</ul>
<p><strong>注意，类型别名与字符串字面量类型都是使用 type 进行定</strong></p>
<h2 id="3-3-元组"><a href="#3-3-元组" class="headerlink" title="3.3 元组"></a>3.3 元组</h2><ul>
<li>数组合并了相同类型的对象，而元组（<code>Tuple</code>）合并了不同类型的对象。</li>
<li>元组起源于函数编程语言,在这些语言中频繁使用元组。</li>
</ul>
<h3 id="3-3-1-简单的例子"><a href="#3-3-1-简单的例子" class="headerlink" title="3.3.1 简单的例子"></a>3.3.1 简单的例子</h3><blockquote>
<p>定义一对值分别为 <code>string</code> 和 <code>number</code>的元组</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number] = [&#x27;poetries&#x27;, 22];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当赋值或访问一个已知索引的元素时，会得到正确的类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number];</span><br><span class="line">user[0] = &#x27;poetries&#x27;;</span><br><span class="line">user[1] = 22;</span><br><span class="line"></span><br><span class="line">user[0].slice(1);</span><br><span class="line">user[1].toFixed(2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以只赋值其中一项</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number];</span><br><span class="line">user[0] = &#x27;poetries&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-越界的元素"><a href="#3-3-2-越界的元素" class="headerlink" title="3.3.2 越界的元素"></a>3.3.2 越界的元素</h3><blockquote>
<p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number];</span><br><span class="line">user = [&#x27;poetries&#x27;, 22];</span><br><span class="line">user.push(&#x27;http://blog.poetries.top&#x27;);</span><br><span class="line">user.push(true);</span><br><span class="line"></span><br><span class="line">// index.ts(4,14): error TS2345: Argument of type &#x27;boolean&#x27; is not assignable to parameter of type &#x27;string | number&#x27;.</span><br><span class="line">//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="3-4-枚举"><a href="#3-4-枚举" class="headerlink" title="3.4 枚举"></a>3.4 枚举</h2><blockquote>
<p>枚举（<code>Enum</code>）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等</p>
</blockquote>
<h3 id="3-4-1-简单的例子"><a href="#3-4-1-简单的例子" class="headerlink" title="3.4.1 简单的例子"></a>3.4.1 简单的例子</h3><blockquote>
<p>枚举使用 <code>enum</code> 关键字来定义：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>枚举成员会被赋值为从 <code>0</code> 开始递增的数字，同时也会对枚举值到枚举名进行反向映射</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 0); // true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1); // true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2); // true</span><br><span class="line">console.log(Days[&quot;Sat&quot;] === 6); // true</span><br><span class="line"></span><br><span class="line">console.log(Days[0] === &quot;Sun&quot;); // true</span><br><span class="line">console.log(Days[1] === &quot;Mon&quot;); // true</span><br><span class="line">console.log(Days[2] === &quot;Tue&quot;); // true</span><br><span class="line">console.log(Days[6] === &quot;Sat&quot;); // true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上，上面的例子会被编译为</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;</span><br><span class="line">    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;</span><br><span class="line">    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;</span><br><span class="line">    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;</span><br><span class="line">    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-手动赋值"><a href="#3-4-2-手动赋值" class="headerlink" title="3.4.2 手动赋值"></a>3.4.2 手动赋值</h3><blockquote>
<p>我们也可以给枚举项手动赋值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 7); // true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1); // true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2); // true</span><br><span class="line">console.log(Days[&quot;Sat&quot;] === 6); // true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增</p>
</blockquote>
<p>如果未手动赋值的枚举项与手动赋值的重复了，<code>TypeScript</code> 是不会察觉到这一点的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 3); // true</span><br><span class="line">console.log(Days[&quot;Wed&quot;] === 3); // true</span><br><span class="line">console.log(Days[3] === &quot;Sun&quot;); // false</span><br><span class="line">console.log(Days[3] === &quot;Wed&quot;); // true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，递增到 <code>3</code> 的时候与前面的 <code>Sun</code> 的取值重复了，但是 <code>TypeScript</code> 并没有报错，导致 <code>Days[3]</code>的值先是 <code>&quot;Sun&quot;</code>，而后又被 <code>&quot;Wed&quot;</code> 覆盖了。编译的结果是</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 3] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;</span><br><span class="line">    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;</span><br><span class="line">    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;</span><br><span class="line">    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;</span><br><span class="line">    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>所以使用的时候需要注意，最好不要出现这种覆盖的情况。</p>
<blockquote>
<p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 <code>tsc</code> 无视类型检查 (编译出的 <code>js</code> 仍然是可用的)：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;&quot;S&quot;&#125;;</span><br><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 7] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 8] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 9] = &quot;Tue&quot;;</span><br><span class="line">    Days[Days[&quot;Wed&quot;] = 10] = &quot;Wed&quot;;</span><br><span class="line">    Days[Days[&quot;Thu&quot;] = 11] = &quot;Thu&quot;;</span><br><span class="line">    Days[Days[&quot;Fri&quot;] = 12] = &quot;Fri&quot;;</span><br><span class="line">    Days[Days[&quot;Sat&quot;] = &quot;S&quot;] = &quot;Sat&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 <code>1</code>：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 7, Mon = 1.5, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 7); // true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1.5); // true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2.5); // true</span><br><span class="line">console.log(Days[&quot;Sat&quot;] === 6.5); // true</span><br></pre></td></tr></table></figure>

<h3 id="3-4-3-常数项和计算所得项"><a href="#3-4-3-常数项和计算所得项" class="headerlink" title="3.4.3 常数项和计算所得项"></a>3.4.3 常数项和计算所得项</h3><blockquote>
<p>枚举项有两种类型：常数项（<code>constant member</code>）和计算所得项（<code>computed member</code>）</p>
</blockquote>
<p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue = &quot;blue&quot;.length&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，<code>&quot;blue&quot;.length</code> 就是一个计算所得项。</p>
</blockquote>
<p>上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = &quot;red&quot;.length, Green, Blue&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(1,33): error TS1061: Enum member must have initializer.</span><br><span class="line">// index.ts(1,40): error TS1061: Enum member must have initializer.</span><br></pre></td></tr></table></figure>

<h3 id="3-4-4-常数枚举"><a href="#3-4-4-常数枚举" class="headerlink" title="3.4.4 常数枚举"></a>3.4.4 常数枚举</h3><blockquote>
<p>常数枚举是使用 <code>const enum</code> 定义的枚举类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//上例的编译结果是：</span><br><span class="line"></span><br><span class="line">var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];</span><br><span class="line">// 假如包含了计算成员，则会在编译阶段报错：</span><br><span class="line"></span><br><span class="line">const enum Color &#123;Red, Green, Blue = &quot;blue&quot;.length&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(1,38): error TS2474: In &#x27;const&#x27; enum declarations member initializer must be constant expression.</span><br></pre></td></tr></table></figure>

<h3 id="3-4-5-外部枚举"><a href="#3-4-5-外部枚举" class="headerlink" title="3.4.5 外部枚举"></a>3.4.5 外部枚举</h3><blockquote>
<p>外部枚举（<code>Ambient Enums</code>）是使用 <code>declare enum</code> 定义的枚举类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>

<ul>
<li>之前提到过，<code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除。</li>
</ul>
<p>上例的编译结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>

<ul>
<li>外部枚举与声明语句一样，常出现在声明文件中。</li>
<li>同时使用 <code>declare</code> 和 <code>const</code> 也是可以的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">declare const enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br><span class="line">// 编译结果：</span><br><span class="line"></span><br><span class="line">var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];</span><br></pre></td></tr></table></figure>

<h2 id="3-5-类"><a href="#3-5-类" class="headerlink" title="3.5 类"></a>3.5 类</h2><h3 id="3-5-1-类的概念"><a href="#3-5-1-类的概念" class="headerlink" title="3.5.1 类的概念"></a>3.5.1 类的概念</h3><blockquote>
<p>类相关的概念做一个简单的介绍</p>
</blockquote>
<ul>
<li>类(<code>Class</code>)：定义了一件事物的抽象特点，包含它的属性和方法</li>
<li>对象（<code>Object</code>）：类的实例，通过 <code>new</code> 生成</li>
<li>面向对象（<code>OOP</code>）的三大特性：封装、继承、多态</li>
<li>封装（<code>Encapsulation</code>）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li>
<li>继承（<code>Inheritance</code>）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>
<li>多态（<code>Polymorphism</code>）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code>还是 <code>Dog</code>，就可以直接调用 <code>eat</code>方法，程序会自动判断出来应该如何执行 <code>eat</code></li>
<li>存取器（<code>getter &amp; setter</code>）：用以改变属性的读取和赋值行为</li>
<li>修饰符（<code>Modifiers</code>）：修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code> 表示公有属性或方法</li>
<li>抽象类（<code>Abstract Class</code>）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>
<li>接口（<code>Interfaces</code>）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（<code>implements</code>）。一个类只能继承自另一个类，但是可以实现多个接口</li>
</ul>
<h3 id="3-5-2-public-private-和-protected"><a href="#3-5-2-public-private-和-protected" class="headerlink" title="3.5.2 public private 和 protected"></a>3.5.2 public private 和 protected</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeScript` 可以使用三种访问修饰符（`Access Modifiers`），分别是 `public`、`private` 和 `protected</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li>
<li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.name); // Jack</span><br><span class="line">a.name = &#x27;Tom&#x27;;</span><br><span class="line">console.log(a.name); // Tom</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p>
</blockquote>
<p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lass Animal &#123;</span><br><span class="line">    private name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.name); // Jack</span><br><span class="line">a.name = &#x27;Tom&#x27;;</span><br><span class="line"></span><br><span class="line">// index.ts(9,13): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br><span class="line">// index.ts(10,1): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子编译后的代码是：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Animal = (function () &#123;</span><br><span class="line">    function Animal(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    return Animal;</span><br><span class="line">&#125;());</span><br><span class="line">var a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.name);</span><br><span class="line">a.name = &#x27;Tom&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(11,17): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    protected name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-3-抽象类"><a href="#3-5-3-抽象类" class="headerlink" title="3.5.3 抽象类"></a>3.5.3 抽象类</h3><blockquote>
<p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p>
</blockquote>
<p><strong>什么是抽象类？</strong></p>
<blockquote>
<p>首先，抽象类是不允许被实例化的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p>
</blockquote>
<p>其次，抽象类中的抽象方法必须被子类实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    public eat() &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; is eating.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = new Cat(&#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(9,7): error TS2515: Non-abstract class &#x27;Cat&#x27; does not implement inherited abstract member &#x27;sayHi&#x27; from class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p>
</blockquote>
<p>下面是一个正确使用抽象类的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    public sayHi() &#123;</span><br><span class="line">        console.log(`Meow, My name is $&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = new Cat(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p>
<blockquote>
<p>需要注意的是，即使是抽象方法，<code>TypeScript</code> 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var __extends = (this &amp;&amp; this.__extends) || function (d, b) &#123;</span><br><span class="line">    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];</span><br><span class="line">    function __() &#123; this.constructor = d; &#125;</span><br><span class="line">    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());</span><br><span class="line">&#125;;</span><br><span class="line">var Animal = (function () &#123;</span><br><span class="line">    function Animal(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    return Animal;</span><br><span class="line">&#125;());</span><br><span class="line">var Cat = (function (_super) &#123;</span><br><span class="line">    __extends(Cat, _super);</span><br><span class="line">    function Cat() &#123;</span><br><span class="line">        _super.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    Cat.prototype.sayHi = function () &#123;</span><br><span class="line">        console.log(&#x27;Meow, My name is &#x27; + this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return Cat;</span><br><span class="line">&#125;(Animal));</span><br><span class="line">var cat = new Cat(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="3-5-4-类的类型"><a href="#3-5-4-类的类型" class="headerlink" title="3.5.4 类的类型"></a>3.5.4 类的类型</h3><blockquote>
<p>给类加上 <code>TypeScript</code> 的类型很简单，与接口类似：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi(): string &#123;</span><br><span class="line">      return `My name is $&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a: Animal = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.sayHi()); // My name is Jack</span><br></pre></td></tr></table></figure>

<h2 id="3-6-类与接口"><a href="#3-6-类与接口" class="headerlink" title="3.6 类与接口"></a>3.6 类与接口</h2><h3 id="3-6-1-类实现接口"><a href="#3-6-1-类实现接口" class="headerlink" title="3.6.1 类实现接口"></a>3.6.1 类实现接口</h3><blockquote>
<p>实现（<code>implements</code>）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（<code>interfaces</code>），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性</p>
</blockquote>
<p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Door &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SecurityDoor extends Door implements Alarm &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        console.log(&#x27;SecurityDoor alert&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car implements Alarm &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        console.log(&#x27;Car alert&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个类可以实现多个接口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Light &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car implements Alarm, Light &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        console.log(&#x27;Car alert&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOn() &#123;</span><br><span class="line">        console.log(&#x27;Car light on&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOff() &#123;</span><br><span class="line">        console.log(&#x27;Car light off&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code>接口，既能报警，也能开关车灯</p>
</blockquote>
<h3 id="3-6-2-接口继承接口"><a href="#3-6-2-接口继承接口" class="headerlink" title="3.6.2 接口继承接口"></a>3.6.2 接口继承接口</h3><blockquote>
<p>接口与接口之间可以是继承关系</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface LightableAlarm extends Alarm &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，我们使用 <code>extends</code> 使 <code>LightableAlarm</code> 继承 <code>Alarm</code></p>
</blockquote>
<h3 id="3-6-3-接口继承类"><a href="#3-6-3-接口继承类" class="headerlink" title="3.6.3 接口继承类"></a>3.6.3 接口继承类</h3><blockquote>
<p>接口也可以继承类：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">    z: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-4-混合类型"><a href="#3-6-4-混合类型" class="headerlink" title="3.6.4 混合类型"></a>3.6.4 混合类型</h3><blockquote>
<p>可以使用接口的方式来定义一个函数需要符合的形状</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有时候，一个函数还可以有自己的属性和方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">    (start: number): string;</span><br><span class="line">    interval: number;</span><br><span class="line">    reset(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getCounter(): Counter &#123;</span><br><span class="line">    let counter = &lt;Counter&gt;function (start: number) &#123; &#125;;</span><br><span class="line">    counter.interval = 123;</span><br><span class="line">    counter.reset = function () &#123; &#125;;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = getCounter();</span><br><span class="line">c(10);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = 5.0;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-泛型"><a href="#3-7-泛型" class="headerlink" title="3.7 泛型"></a>3.7 泛型</h2><blockquote>
<p>泛型（<code>Generics</code>）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p>
</blockquote>
<h3 id="3-7-1-简单的例子"><a href="#3-7-1-简单的例子" class="headerlink" title="3.7.1 简单的例子"></a>3.7.1 简单的例子</h3><blockquote>
<p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray(length: number, value: any): Array&lt;any&gt; &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>

<ul>
<li>上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。</li>
<li>这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：<code>Array</code> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的<code>value</code> 的类型。</li>
</ul>
<blockquote>
<p>这时候，泛型就派上用场了：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray&lt;string&gt;(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，我们在函数名后添加了 &#96;&#96;，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code>和输出 <code>Array</code>中即可使用了</p>
</blockquote>
<p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="3-7-2-多个类型参数"><a href="#3-7-2-多个类型参数" class="headerlink" title="3.7.2 多个类型参数"></a>3.7.2 多个类型参数</h3><blockquote>
<p>定义泛型的时候，可以一次定义多个类型参数：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;</span><br><span class="line">    return [tuple[1], tuple[0]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([7, &#x27;seven&#x27;]); // [&#x27;seven&#x27;, 7]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组</p>
</blockquote>
<h3 id="3-7-3-泛型约束"><a href="#3-7-3-泛型约束" class="headerlink" title="3.7.3 泛型约束"></a>3.7.3 泛型约束</h3><blockquote>
<p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;T&#x27;.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p>
</blockquote>
<blockquote>
<p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含<code>length</code> 属性的变量。这就是泛型约束</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，我们使用了 <code>extends</code>约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p>
</blockquote>
<blockquote>
<p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code>不包含 <code>length</code>，那么在编译阶段就会报错了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loggingIdentity(7);</span><br><span class="line"></span><br><span class="line">// index.ts(10,17): error TS2345: Argument of type &#x27;7&#x27; is not assignable to parameter of type &#x27;Lengthwise&#x27;.</span><br></pre></td></tr></table></figure>

<p><strong>多个类型参数之间也可以互相约束：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123;</span><br><span class="line">    for (let id in source) &#123;</span><br><span class="line">        target[id] = (&lt;T&gt;source)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;</span><br><span class="line"></span><br><span class="line">copyFields(x, &#123; b: 10, d: 20 &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，我们使用了两个类型参数，其中要求 <code>T</code> 继承 <code>U</code>，这样就保证了<code>U</code> 上不会出现 <code>T</code> 中不存在的字段</p>
</blockquote>
<h3 id="3-7-4-泛型接口"><a href="#3-7-4-泛型接口" class="headerlink" title="3.7.4 泛型接口"></a>3.7.4 泛型接口</h3><blockquote>
<p>可以使用接口的方式来定义一个函数需要符合的形状</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然也可以使用含有泛型的接口来定义函数的形状</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface CreateArrayFunc &#123;</span><br><span class="line">    &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let createArray: CreateArrayFunc;</span><br><span class="line">createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进一步，我们可以把泛型参数提前到接口名上</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface CreateArrayFunc&lt;T&gt; &#123;</span><br><span class="line">    (length: number, value: T): Array&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let createArray: CreateArrayFunc&lt;any&gt;;</span><br><span class="line">createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，此时在使用泛型接口的时候，需要定义泛型的类型</p>
</blockquote>
<h3 id="3-7-5-泛型类"><a href="#3-7-5-泛型类" class="headerlink" title="3.7.5 泛型类"></a>3.7.5 泛型类</h3><blockquote>
<p>与泛型接口类似，泛型也可以用于类的类型定义中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myGenericNumber = new GenericNumber&lt;number&gt;();</span><br><span class="line"></span><br><span class="line">myGenericNumber.zeroValue = 0;</span><br><span class="line">myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-6-泛型参数的默认类型"><a href="#3-7-6-泛型参数的默认类型" class="headerlink" title="3.7.6 泛型参数的默认类型"></a>3.7.6 泛型参数的默认类型</h3><blockquote>
<p>在 <code>TypeScript 2.3</code>以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-8-声明合并"><a href="#3-8-声明合并" class="headerlink" title="3.8 声明合并"></a>3.8 声明合并</h2><blockquote>
<p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型</p>
</blockquote>
<h3 id="3-8-1-函数的合并"><a href="#3-8-1-函数的合并" class="headerlink" title="3.8.1 函数的合并"></a>3.8.1 函数的合并</h3><blockquote>
<p>我们可以使用重载定义多个函数类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line"></span><br><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-2-接口的合并"><a href="#3-8-2-接口的合并" class="headerlink" title="3.8.2 接口的合并"></a>3.8.2 接口的合并</h3><blockquote>
<p>接口中的属性在合并时会简单的合并到一个接口中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相当于：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，合并的属性的类型必须是唯一的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;  // 虽然重复了，但是类型都是 `number`，所以不会报错</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: string;  // 类型不一致，会报错</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable &#x27;price&#x27; must be of type &#x27;number&#x27;, but here has type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>

<p><strong>接口中方法的合并，与函数的合并一样</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    alert(s: string): string;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    weight: number;</span><br><span class="line">    alert(s: string, n: number): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    weight: number;</span><br><span class="line">    alert(s: string): string;</span><br><span class="line">    alert(s: string, n: number): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-3-类的合并"><a href="#3-8-3-类的合并" class="headerlink" title="3.8.3 类的合并"></a>3.8.3 类的合并</h3><blockquote>
<p>类的合并与接口的合并规则一致</p>
</blockquote>
<h1 id="四、工程"><a href="#四、工程" class="headerlink" title="四、工程"></a>四、工程</h1><h2 id="4-1-tsconfig-json"><a href="#4-1-tsconfig-json" class="headerlink" title="4.1 tsconfig.json"></a>4.1 tsconfig.json</h2><p><strong>编译选项</strong></p>
<blockquote>
<p>你可以通过 <code>compilerOptions</code> 来定制你的编译选项</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    /* 基本选项 */</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br><span class="line">    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件</span><br><span class="line">    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件</span><br><span class="line">    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误</span><br><span class="line">    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br><span class="line">    &quot;declaration&quot;: true,                   // 生成相应的 &#x27;.d.ts&#x27; 文件</span><br><span class="line">    &quot;sourceMap&quot;: true,                     // 生成相应的 &#x27;.map&#x27; 文件</span><br><span class="line">    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件</span><br><span class="line">    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录</span><br><span class="line">    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.</span><br><span class="line">    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释</span><br><span class="line">    &quot;noEmit&quot;: true,                        // 不生成输出文件</span><br><span class="line">    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数</span><br><span class="line">    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><span class="line"></span><br><span class="line">    /* 严格的类型检查选项 */</span><br><span class="line">    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项</span><br><span class="line">    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错</span><br><span class="line">    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查</span><br><span class="line">    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误</span><br><span class="line">    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><span class="line"></span><br><span class="line">    /* 额外的检查 */</span><br><span class="line">    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误</span><br><span class="line">    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误</span><br><span class="line">    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误</span><br><span class="line">    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><span class="line"></span><br><span class="line">    /* 模块解析选项 */</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br><span class="line">    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录</span><br><span class="line">    &quot;paths&quot;: &#123;&#125;,                           // 模块名到基于 baseUrl 的路径映射的列表</span><br><span class="line">    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br><span class="line">    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表</span><br><span class="line">    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。</span><br><span class="line"></span><br><span class="line">    /* Source Map Options */</span><br><span class="line">    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br><span class="line">    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置</span><br><span class="line">    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br><span class="line">    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><span class="line"></span><br><span class="line">    /* 其他选项 */</span><br><span class="line">    &quot;experimentalDecorators&quot;: true,        // 启用装饰器</span><br><span class="line">    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-TypeScript-编译"><a href="#4-2-TypeScript-编译" class="headerlink" title="4.2 TypeScript 编译"></a>4.2 TypeScript 编译</h2><blockquote>
<p>运行 <code>tsc -p ./path-to-project-directory</code> 。<code>tsc -w</code>来启用 <code>TypeScript</code>编译器的观测模式，在检测到文件改动之后，它将重新编译</p>
</blockquote>
<p><strong>指定需要编译的文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;./some/file.ts&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 include 和 exclude 选项来指定需要包含的文件，和排除的文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;./folder&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;exclude&quot;: [</span><br><span class="line">    &quot;./folder/**/*.spec.ts&quot;,</span><br><span class="line">    &quot;./folder/someSubFolder&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、一些例子演示"><a href="#五、一些例子演示" class="headerlink" title="五、一些例子演示"></a>五、一些例子演示</h1><h2 id="5-1-定义ajax请求数据接口"><a href="#5-1-定义ajax请求数据接口" class="headerlink" title="5.1 定义ajax请求数据接口"></a>5.1 定义ajax请求数据接口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">interface Config&#123;</span><br><span class="line">    type:string;</span><br><span class="line">    url:string;</span><br><span class="line">    data?:string;</span><br><span class="line">    dataType:string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//原生js封装的ajax </span><br><span class="line">function ajax(config:Config)&#123;</span><br><span class="line"></span><br><span class="line">   var xhr=new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">   xhr.open(config.type,config.url,true);</span><br><span class="line"></span><br><span class="line">   xhr.send(config.data);</span><br><span class="line"></span><br><span class="line">   xhr.onreadystatechange=function()&#123;</span><br><span class="line"></span><br><span class="line">        if(xhr.readyState==4 &amp;&amp; xhr.status==200)&#123;</span><br><span class="line">            console.log(&#x27;chengong&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if(config.dataType==&#x27;json&#x27;)&#123;</span><br><span class="line"></span><br><span class="line">                console.log(JSON.parse(xhr.responseText));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                console.log(xhr.responseText)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">    type:&#x27;get&#x27;,</span><br><span class="line">    data:&#x27;name=zhangsan&#x27;,</span><br><span class="line">    url:&#x27;http://a.itying.com/api/productlist&#x27;, //api</span><br><span class="line">    dataType:&#x27;json&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-2-函数类型接口-对方法约束"><a href="#5-2-函数类型接口-对方法约束" class="headerlink" title="5.2 函数类型接口-对方法约束"></a>5.2 函数类型接口-对方法约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 函数类型接口:对方法传入的参数 以及返回值进行约束   批量约束</span><br><span class="line"></span><br><span class="line">// 加密的函数类型接口</span><br><span class="line"></span><br><span class="line">interface encrypt&#123;</span><br><span class="line">    (key:string,value:string):string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var md5:encrypt=function(key:string,value:string):string&#123;</span><br><span class="line">        //模拟操作</span><br><span class="line">        return key+value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(md5(&#x27;name&#x27;,&#x27;zhangsan&#x27;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var sha1:encrypt=function(key:string,value:string):string&#123;</span><br><span class="line"></span><br><span class="line">    //模拟操作</span><br><span class="line">    return key+&#x27;----&#x27;+value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sha1(&#x27;name&#x27;,&#x27;lisi&#x27;));</span><br></pre></td></tr></table></figure>

<h2 id="5-3-可索引接口：数组、对象的约束（不常用）"><a href="#5-3-可索引接口：数组、对象的约束（不常用）" class="headerlink" title="5.3 可索引接口：数组、对象的约束（不常用）"></a>5.3 可索引接口：数组、对象的约束（不常用）</h2><h3 id="5-3-1-可索引接口-对数组的约束"><a href="#5-3-1-可索引接口-对数组的约束" class="headerlink" title="5.3.1 可索引接口-对数组的约束"></a>5.3.1 可索引接口-对数组的约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface UserArr&#123;</span><br><span class="line">    [index:number]:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr:UserArr=[&#x27;aaa&#x27;,&#x27;bbb&#x27;];</span><br><span class="line"></span><br><span class="line">console.log(arr[0]);</span><br></pre></td></tr></table></figure>

<h3 id="5-3-2-可索引接口-对对象的约束"><a href="#5-3-2-可索引接口-对对象的约束" class="headerlink" title="5.3.2 可索引接口-对对象的约束"></a>5.3.2 可索引接口-对对象的约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface UserObj&#123;</span><br><span class="line">    [index:string]:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr:UserObj=&#123;name:&#x27;张三&#x27;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-3-类类型接口-对类的约束"><a href="#5-3-3-类类型接口-对类的约束" class="headerlink" title="5.3.3 类类型接口:对类的约束"></a>5.3.3 类类型接口:对类的约束</h3><ul>
<li>抽象类抽象有点相似</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    eat(str:string):void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog implements Animal&#123;</span><br><span class="line"></span><br><span class="line">    name:string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line"></span><br><span class="line">        this.name=name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;吃粮食&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var d=new Dog(&#x27;小黑&#x27;);</span><br><span class="line">d.eat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat implements Animal&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line"></span><br><span class="line">        this.name=name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    eat(food:string)&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;吃&#x27;+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c=new Cat(&#x27;小花&#x27;);</span><br><span class="line">c.eat(&#x27;老鼠&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="5-4-接口的扩展"><a href="#5-4-接口的扩展" class="headerlink" title="5.4 接口的扩展"></a>5.4 接口的扩展</h2><blockquote>
<p>接口继承接口 类实现接口</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    eat():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person extends Animal&#123;</span><br><span class="line"></span><br><span class="line">    work():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Programmer&#123;</span><br><span class="line"></span><br><span class="line">    public name:string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coding(code:string)&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+code)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Web extends Programmer implements Person&#123;</span><br><span class="line">    </span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">       super(name)</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;喜欢吃馒头&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    work()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;写代码&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var w=new Web(&#x27;小李&#x27;);</span><br><span class="line"></span><br><span class="line">// w.eat();</span><br><span class="line"></span><br><span class="line">w.coding(&#x27;写ts代码&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="5-5-泛型类接口"><a href="#5-5-泛型类接口" class="headerlink" title="5.5 泛型类接口"></a>5.5 泛型类接口</h2><h3 id="5-5-1-泛型类-泛型方法"><a href="#5-5-1-泛型类-泛型方法" class="headerlink" title="5.5.1 泛型类 泛型方法"></a>5.5.1 泛型类 泛型方法</h3><ul>
<li>泛型：软件工程中，我们不仅要创建一致的定义良好的<code>API</code>，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</li>
<li>在像<code>C#</code>和<code>Java</code>这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</li>
<li>通俗理解：泛型就是解决类接口方法的复用性、以及对不特定数据类型的支持(类型校验)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 只能返回string类型的数据</span><br><span class="line">function getData(value:string):string&#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同时返回 string类型 和number类型  （代码冗余）</span><br><span class="line">function getData1(value:string):string&#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">function getData2(value:number):number&#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">//同时返回 string类型 和number类型  any可以解决这个问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> function getData(value:any):any&#123;</span><br><span class="line">    return &#x27;哈哈哈&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData(123);</span><br><span class="line">getData(&#x27;str&#x27;);</span><br><span class="line">//any放弃了类型检查,传入什么 返回什么。比如:传入number 类型必须返回number类型  传入 string类型必须返回string类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//传入的参数类型和返回的参数类型可以不一致</span><br><span class="line">function getData(value:any):any&#123;</span><br><span class="line">  return &#x27;哈哈哈&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>T</code>表示泛型，具体什么类型是调用这个方法的时候决定的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// T表示泛型，具体什么类型是调用这个方法的时候决定的</span><br><span class="line"></span><br><span class="line">function getData&lt;T&gt;(value:T):T&#123;</span><br><span class="line">   return value;</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;number&gt;(123);</span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(&#x27;1214231&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData&lt;number&gt;(&#x27;2112&#x27;);       /*错误的写法*/</span><br><span class="line">function getData&lt;T&gt;(value:T):any&#123;</span><br><span class="line">   return &#x27;2145214214&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData&lt;number&gt;(123);  //参数必须是number</span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(&#x27;这是一个泛型&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>泛型类</strong></p>
<blockquote>
<p>泛型类：比如有个最小堆算法，需要同时支持返回数字和字符串 <code>a - z</code>两种类型。 通过类的泛型来实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 基本写法 但是不能传入字符串</span><br><span class="line">class MinClass&#123;</span><br><span class="line">    public list:number[]=[];</span><br><span class="line">    add(num:number)&#123;</span><br><span class="line">        this.list.push(num)</span><br><span class="line">    &#125;</span><br><span class="line">    min():number&#123;</span><br><span class="line">        var minNum=this.list[0];</span><br><span class="line">        for(var i=0;i&lt;this.list.length;i++)&#123;</span><br><span class="line">            if(minNum&gt;this.list[i])&#123;</span><br><span class="line">                minNum=this.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m=new MinClass();</span><br><span class="line"></span><br><span class="line">m.add(3);</span><br><span class="line">m.add(22);</span><br><span class="line">m.add(23);</span><br><span class="line">m.add(6);</span><br><span class="line"></span><br><span class="line">m.add(7);</span><br><span class="line">alert(m.min());</span><br></pre></td></tr></table></figure>

<p><strong>类的泛型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 通过泛型改写 可以同时传入number 字符串等</span><br><span class="line">//类的泛型</span><br><span class="line">class MinClas&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    public list:T[]=[];</span><br><span class="line"></span><br><span class="line">    add(value:T):void&#123;</span><br><span class="line"></span><br><span class="line">        this.list.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    min():T&#123;        </span><br><span class="line">        var minNum=this.list[0];</span><br><span class="line">        for(var i=0;i&lt;this.list.length;i++)&#123;</span><br><span class="line">            if(minNum&gt;this.list[i])&#123;</span><br><span class="line">                minNum=this.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m1=new MinClas&lt;number&gt;();   /*实例化类 并且制定了类的T代表的类型是number*/</span><br><span class="line">m1.add(11);</span><br><span class="line">m1.add(3);</span><br><span class="line">m1.add(2);</span><br><span class="line">alert(m1.min())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var m2=new MinClas&lt;string&gt;();   /*实例化类 并且制定了类的T代表的类型是string*/</span><br><span class="line"></span><br><span class="line">m2.add(&#x27;c&#x27;);</span><br><span class="line">m2.add(&#x27;a&#x27;);</span><br><span class="line">m2.add(&#x27;v&#x27;);</span><br><span class="line">alert(m2.min())</span><br></pre></td></tr></table></figure>

<h3 id="5-5-2-泛型接口"><a href="#5-5-2-泛型接口" class="headerlink" title="5.5.2 泛型接口"></a>5.5.2 泛型接口</h3><p><strong>1. 方式1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface ConfigFn&#123;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt;(value:T):T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var getData:ConfigFn=function&lt;T&gt;(value:T):T&#123;</span><br><span class="line"></span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(&#x27;张三&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// getData&lt;string&gt;(1243);  //错误</span><br></pre></td></tr></table></figure>

<p><strong>2. 方式2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface ConfigFn&lt;T&gt;&#123;</span><br><span class="line">    (value:T):T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getData&lt;T&gt;(value:T):T&#123;</span><br><span class="line"></span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var myGetData:ConfigFn&lt;string&gt;=getData;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myGetData(&#x27;20&#x27;);  /*正确*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// myGetData(20)  //错误</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/23/html+css+js+ts/5-Typescript%E6%80%BB%E7%BB%93/" data-id="cl7ibzolf008kuguna4bmeksd" data-title="Typescript总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/5-Typescript实践总结[基础+工程+实践]" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/15/html+css+js+ts/5-Typescript%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%5B%E5%9F%BA%E7%A1%80+%E5%B7%A5%E7%A8%8B+%E5%AE%9E%E8%B7%B5%5D/" class="article-date">
  <time class="dt-published" datetime="2021-08-15T06:31:08.000Z" itemprop="datePublished">2021-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/15/html+css+js+ts/5-Typescript%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%5B%E5%9F%BA%E7%A1%80+%E5%B7%A5%E7%A8%8B+%E5%AE%9E%E8%B7%B5%5D/">Typescript实践总结[基础+工程+实践]</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第一章-基础篇"><a href="#第一章-基础篇" class="headerlink" title="第一章 基础篇"></a>第一章 基础篇</h1><blockquote>
<p>TS基础篇</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/base-1.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-2.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-3.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-4.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-5.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-6.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-7.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-8.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-9.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-10.webp" alt="img"></p>
<h2 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h2><ul>
<li><code>JavaScript</code> 的类型分为两种：原始数据类型和对象类型。</li>
<li>原始数据类型包括：布尔值、数值、字符串、<code>null</code>、<code>undefined</code> 以及 ES6 中的新类型 <code>Symbol</code></li>
<li>本节主要介绍前五种原始数据类型在 <code>TypeScript</code> 中的应用。</li>
<li>布尔值是最基础的数据类型，在 <code>TypeScript</code> 中，使用 <code>boolean</code> 定义布尔值类型</li>
</ul>
<p><strong>ES6数据类型</strong></p>
<ul>
<li><code>Boolean</code></li>
<li><code>Number</code></li>
<li><code>String</code></li>
<li><code>Array</code></li>
<li><code>Function</code></li>
<li><code>Object</code></li>
<li><code>Symbol</code></li>
<li><code>undefined</code></li>
<li><code>null</code></li>
</ul>
<p><strong>Typescript数据类型</strong></p>
<ul>
<li><code>Boolean</code></li>
<li><code>Number</code></li>
<li><code>String</code></li>
<li><code>Array</code></li>
<li><code>Function</code></li>
<li><code>Object</code></li>
<li><code>Symbol</code></li>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>void</code></li>
<li><code>any</code></li>
<li><code>never</code></li>
<li>元组</li>
<li>枚举</li>
<li>高级类型</li>
</ul>
<p><strong>正确的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">➖➖➖➖➖➖➖➖➖布尔➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 布尔值</span><br><span class="line">let isDone: boolean = false;  </span><br><span class="line"></span><br><span class="line">// 事实上 `new Boolean()` 返回的是一个 `Boolean` 对象</span><br><span class="line">let createdByNewBoolean: Boolean = new Boolean(1);</span><br><span class="line"></span><br><span class="line">//(直接调用 `Boolean` 也可以返回一个 `boolean` 类型) </span><br><span class="line">let createdByBoolean: boolean = Boolean(1); </span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖数值➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 数值</span><br><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line"></span><br><span class="line">// ES6 中的二进制表示法</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line"></span><br><span class="line">// ES6 中的八进制表示法</span><br><span class="line">let octalLiteral: number = 0o744;</span><br><span class="line">let notANumber: number = NaN;</span><br><span class="line">let infinityNumber: number = Infinity;</span><br><span class="line">➖➖➖➖➖➖➖➖➖字符串➖➖➖➖➖➖➖➖➖</span><br><span class="line">let myName: string = &#x27;Tom&#x27;;</span><br><span class="line">➖➖➖➖➖➖➖➖➖空值➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 没有返回值的函数为void</span><br><span class="line">function alertName(): void &#123;</span><br><span class="line">    alert(&#x27;My name is Tom&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//声明一个 void 类型的只能将它赋值为 undefined 和 null</span><br><span class="line">let unusable: void = undefined;</span><br><span class="line">➖➖➖➖➖➖➖➖➖Null 和 Undefined➖➖➖➖➖➖➖➖➖</span><br><span class="line">// undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null</span><br><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure>

<p><strong>错误的写法</strong></p>
<blockquote>
<p>注意:正确的很好记,大多数人都会写正确的,关键是要记住这些错误的!!!</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➖➖➖➖➖➖➖➖➖布尔➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 注意，使用构造函数 `Boolean` 创造的对象不是布尔值</span><br><span class="line">let createdByNewBoolean: boolean = new Boolean(1);❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖数值➖➖➖➖➖➖➖➖➖</span><br><span class="line">let decLiteral: number = &quot;6&quot;;❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖字符串➖➖➖➖➖➖➖➖➖</span><br><span class="line">let myName: string = 999;❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖空值➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 没有返回值的函数为void</span><br><span class="line">function alertName(): void &#123;❌</span><br><span class="line">   return 666;</span><br><span class="line">&#125;</span><br><span class="line">//声明一个 void 类型的只能将它赋值为 undefined 和 null</span><br><span class="line">let unusable: void = &#x27;I love you&#x27;;❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖Null 和 Undefined➖➖➖➖➖➖➖➖➖</span><br><span class="line">// undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null</span><br><span class="line">let u: undefined = 888;❌</span><br><span class="line">let n: null = 999;❌</span><br></pre></td></tr></table></figure>

<h2 id="二、任意值"><a href="#二、任意值" class="headerlink" title="二、任意值"></a>二、任意值</h2><p><strong>正确的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 顾名思义,可以被任何值赋值</span><br><span class="line">let anyThing: any = &#x27;hello&#x27;;</span><br><span class="line">let anyThing: any = 888;</span><br><span class="line">let anyThing: any = true;</span><br><span class="line">let anyThing: any = null;</span><br><span class="line">let anyThing: any = undefined;</span><br><span class="line"></span><br><span class="line">// 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</span><br><span class="line">let any;</span><br><span class="line">any =true;</span><br></pre></td></tr></table></figure>

<h2 id="三、类型推论"><a href="#三、类型推论" class="headerlink" title="三、类型推论"></a>三、类型推论</h2><p><strong>正确的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</span><br><span class="line">let myFavoriteNumber = &#x27;seven&#x27;;  </span><br><span class="line">//等价于</span><br><span class="line">let myFavoriteNumber :string= &#x27;seven&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>错误的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 第一句已经被推论为String类型了</span><br><span class="line">let myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;❌</span><br></pre></td></tr></table></figure>

<h2 id="四、联合类型"><a href="#四、联合类型" class="headerlink" title="四、联合类型"></a>四、联合类型</h2><p><strong>正确的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 联合类型（Union Types）表示取值可以为多种类型中的一种。</span><br><span class="line">// 当你允许某个变量被赋值多种类型的时候,使用联合类型,管道符进行连接</span><br><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// 也可用于方法的参数定义, 都有toString方法,访问 string 和 number 的共有属性是没问题的</span><br><span class="line">function getString(something: string | number): string &#123;</span><br><span class="line">    return something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>错误的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// number类型没有length属性.所以编译错误,因为我们只能访问此联合类型的所有类型里共有的属性或方法：</span><br><span class="line">function getLength(something: string | number): number &#123;❌</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、对象的类型——接口"><a href="#五、对象的类型——接口" class="headerlink" title="五、对象的类型——接口"></a>五、对象的类型——接口</h2><p><strong>正确的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// 赋值的时候，变量的形状必须和接口的形状保持一致(不能多也不能少,类型还必须一致)</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IUserInfo&#123;</span><br><span class="line">  age : any;//定义一个任何变量的 age.</span><br><span class="line">  userName :string;//定义一个 username.</span><br><span class="line">&#125;</span><br><span class="line">function getUserInfo(user : IUserInfo):string&#123;</span><br><span class="line">    return user.age+&quot;======&quot;+user.userName; 	</span><br><span class="line">&#125;</span><br><span class="line">  ➖➖➖➖➖➖➖➖➖可选属性➖➖➖➖➖➖➖➖➖</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number; // 表示这个属性可有可无</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">// 可索引签名</span><br><span class="line">interface StringArrary &#123;</span><br><span class="line">  [index]: string // 数字索引。通过数字索引，返回string类型</span><br><span class="line">  [string]: string // 字符串索引签名。两者不能混用，一起使用的前提是数字索引是字符串索引的子集</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myArr: StringArrary</span><br><span class="line">myArr = [&#x27;test1&#x27;,&#x27;test2&#x27;]</span><br><span class="line">let myString = myArr[0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ➖➖➖➖➖➖➖➖➖任意属性➖➖➖➖➖➖➖➖➖</span><br><span class="line"></span><br><span class="line">//希望一个接口允许有任意的属性，可以使用如下方式：旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27; // 可以加其他的属性</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖只读属性➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number; // </span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    id: 89757, // 只读</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>错误的写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;❌</span><br><span class="line">&#125;;</span><br><span class="line">上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖只读属性➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 89757; // 不能被二次赋值❌</span><br></pre></td></tr></table></figure>

<p><strong>数组只读属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myARr:readonlyArrary&lt;number&gt; = [1,2,3]</span><br></pre></td></tr></table></figure>

<h2 id="六、数组的类型"><a href="#六、数组的类型" class="headerlink" title="六、数组的类型"></a>六、数组的类型</h2><p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br><span class="line">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖用接口表示数组➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index: number]: number;</span><br><span class="line">&#125;</span><br><span class="line">let fibonacci: NumberArray = [1, 1, 2, 3, 5];</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖any 在数组中的应用➖➖➖➖➖➖➖➖➖</span><br><span class="line">let list: any[] = [&#x27;Xcat Liu&#x27;, 25, &#123; website: &#x27;http://xcatliu.com&#x27; &#125;];</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖类数组➖➖➖➖➖➖➖➖➖</span><br><span class="line">function sum() &#123;</span><br><span class="line">    let args: IArguments = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>错误的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 数组的项中不允许出现其他的类型：</span><br><span class="line">let fibonacci: number[] = [1, &#x27;1&#x27;, 2, 3, 5];❌</span><br><span class="line"></span><br><span class="line">// push 方法只允许传入 number 类型的参数，但是却传了一个 string 类型的参数，所以报错了。</span><br><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br><span class="line">fibonacci.push(&#x27;8&#x27;);❌</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 类数组（Array-like Object）不是数组类型，比如 arguments</span><br><span class="line">function sum() &#123;❌</span><br><span class="line">    let args: number[] = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、函数的类型"><a href="#七、函数的类型" class="headerlink" title="七、函数的类型"></a>七、函数的类型</h2><p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 需要把输入和输出都考虑到</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖函数表达式➖➖➖➖➖➖➖➖➖</span><br><span class="line">let mySum = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line">// 不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;</span><br><span class="line">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line">➖➖➖➖➖➖➖➖➖接口定义函数的形状➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source, subString) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖可选参数➖➖➖➖➖➖➖➖➖</span><br><span class="line">function buildName(firstName: string, lastName?: string) &#123;</span><br><span class="line">    if (lastName) &#123;</span><br><span class="line">        return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(&#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖参数默认值➖➖➖➖➖➖➖➖➖</span><br><span class="line">function buildName(firstName: string, lastName: string = &#x27;Cat&#x27;) &#123;</span><br><span class="line">    return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖剩余参数➖➖➖➖➖➖➖➖➖</span><br><span class="line">// rest 参数只能是最后一个参数，关于 rest 参数,是一个数组</span><br><span class="line">function push(array: any[], ...items: any[]) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></table></figure>

<p><strong>错误的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 输入多余的（或者少于要求的）参数，是不被允许的：</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1, 2, 3); ❌</span><br><span class="line">sum(1);❌</span><br><span class="line"></span><br><span class="line">// 输入多余的（或者少于要求的）参数，是不被允许的：</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1, 2, 3);</span><br><span class="line"></span><br><span class="line">// 可选参数后面不允许再出现必须参数了：</span><br><span class="line">function buildName(firstName?: string, lastName: string) &#123;❌</span><br><span class="line">    if (firstName) &#123;</span><br><span class="line">        return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(undefined, &#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="7-1-函数相关知识点梳理"><a href="#7-1-函数相关知识点梳理" class="headerlink" title="7.1 函数相关知识点梳理"></a>7.1 函数相关知识点梳理</h3><p><strong>四种声明方式：</strong></p>
<ul>
<li>通过<code>function</code></li>
<li>通过变量</li>
<li>通过接口</li>
<li>通过类型别名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数定义</span><br><span class="line">function add1(x: number, y: number) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过变量</span><br><span class="line">let add2: (x: number, y: number) =&gt; number</span><br><span class="line"></span><br><span class="line">// 通过类型别名</span><br><span class="line">let add3 = (x: number, y: number) =&gt; number</span><br><span class="line"></span><br><span class="line">// 通过类型别名</span><br><span class="line">interface add4 &#123;</span><br><span class="line">    (x: number, y: number): number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用interface定义函数和用type定义函数有区别?</strong></p>
<ul>
<li><code>type</code>：不是创建新的类型，只是为一个给定的类型起一个名字。<code>type</code>还可以进行联合、交叉等操作，引用起来更简洁</li>
<li><code>interface</code>：创建新的类型，接口之间还可以继承、声明合并</li>
<li>如果可能，建议优先使用 <code>interface</code>。</li>
<li>混合接口一般是为第三方类库写声明文件时会用到，很多类库名称可以直接当函数调用，也可以有些属性和方法。例子可以看一下<code>@types/jest/index.d.ts</code> 里面有一些混合接口。</li>
<li>用混合接口声明函数和用接口声明类的区别是，接口不能声明类的构造函数（既不带名称的函数），但混合接口可以，其他都一样。</li>
</ul>
<p><strong>函数重载</strong></p>
<p>函数名相同，返回类型不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add8(...rest: number[]): number;</span><br><span class="line">function add8(...rest: string[]): string;</span><br><span class="line">function add8(...rest: any[]): any &#123;</span><br><span class="line">    let first = rest[0];</span><br><span class="line">    if(typeof first === &#x27;string&#x27;) &#123;</span><br><span class="line">        return rest.join(&#x27;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof first === &#x27;number&#x27;) &#123;</span><br><span class="line">        return rest.reduce((pre, cur) =&gt; pre + cur)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、类型断言"><a href="#八、类型断言" class="headerlink" title="八、类型断言"></a>八、类型断言</h2><ul>
<li>有时候你会遇到这样的情况，你会比 <code>TypeScript</code> 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</li>
<li>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 <code>TypeScript</code> 会假设你，程序员，已经进行了必须的检查。</li>
</ul>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &#x27;this is a string&#x27;</span><br><span class="line"></span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另一个为 <code>as</code> 语法：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &#x27;this is a string&#x27;</span><br><span class="line"></span><br><span class="line">let strLength: number = (someValue as string).length</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 <code>TypeScript</code> 里使用 <code>JSX</code>时，只有<code>as</code> 语法断言是被允许</p>
</blockquote>
<p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 可以使用类型断言，将 something 断言成 string</span><br><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if ((&lt;string&gt;something).length) &#123;</span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>错误的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 只能访问此联合类型的所有类型里共有的属性或方法</span><br><span class="line">function getLength(something: string | number): number &#123; ❌</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、类型别名"><a href="#九、类型别名" class="headerlink" title="九、类型别名"></a>九、类型别名</h2><p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用 type 创建类型别名,类型别名常用于联合类型</span><br><span class="line">type Name = string;</span><br><span class="line">type NameResolver = () =&gt; string;</span><br><span class="line">type NameOrResolver = Name | NameResolver;</span><br><span class="line">function getName(n: NameOrResolver): Name &#123;</span><br><span class="line">    if (typeof n === &#x27;string&#x27;) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十、枚举"><a href="#十、枚举" class="headerlink" title="十、枚举"></a>十、枚举</h2><p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天	</span><br><span class="line">// 枚举就是枚举值到枚举名进行反向映射</span><br><span class="line"></span><br><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line">console.log(Days[&quot;Sun&quot;]); // 0</span><br><span class="line">console.log(Days[0]); // &#x27;Sun&#x27;</span><br><span class="line"></span><br><span class="line">enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line">console.log(Days[&quot;Sun&quot;]); // 7</span><br></pre></td></tr></table></figure>

<h2 id="十一、类"><a href="#十一、类" class="headerlink" title="十一、类"></a>十一、类</h2><p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">➖➖➖➖➖➖➖➖➖类➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `My name is $&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.sayHi()); // My name is Jack</span><br><span class="line">➖➖➖➖➖➖➖➖➖继承➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        super(name); // 调用父类的 constructor(name)</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return &#x27;Meow, &#x27; + super.sayHi(); // 调用父类的 sayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = new Cat(&#x27;Tom&#x27;); // Tom</span><br><span class="line">console.log(c.sayHi()); // Meow, My name is Tom</span><br><span class="line">➖➖➖➖➖➖➖➖➖存储器➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    get name() &#123;</span><br><span class="line">        return &#x27;Jack&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    set name(value) &#123;</span><br><span class="line">        console.log(&#x27;setter: &#x27; + value);</span><br><span class="line">        this.name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Kitty&#x27;); // setter: Kitty</span><br><span class="line">a.name = &#x27;Tom&#x27;; // setter: Tom</span><br><span class="line">console.log(a.name); // Jack</span><br><span class="line">➖➖➖➖➖➖➖➖➖静态方法➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Animal &#123;</span><br><span class="line">    static isAnimal(a) &#123;</span><br><span class="line">        return a instanceof Animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">Animal.isAnimal(a); // true</span><br><span class="line">// 只能通过类名调用</span><br><span class="line">a.isAnimal(a); // TypeError: a.isAnimal is not a function ❌</span><br><span class="line">➖➖➖➖➖➖➖➖➖抽象类➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 只能被继承，不能被实例化</span><br><span class="line">abstract class Animal &#123;</span><br><span class="line">  eat()&#123;</span><br><span class="line">    console.log(&#x27;eat&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  abstract sleep(): void</span><br><span class="line">&#125;</span><br><span class="line">// 子类必须实现抽象类的抽象方法</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super()</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    name: string;</span><br><span class="line">    run() &#123;&#125;</span><br><span class="line">    sleep() &#123;</span><br><span class="line">        console.log(&#x27;dog sleep&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dog = new Dog(&#x27;wang&#x27;)</span><br><span class="line">dog.eat()</span><br></pre></td></tr></table></figure>

<h3 id="11-1类与接口的关系"><a href="#11-1类与接口的关系" class="headerlink" title="11.1类与接口的关系"></a>11.1类与接口的关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface Human &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    eat(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现接口中声明的属性</span><br><span class="line">class Person implements Human &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    name: string;</span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 接口可以像类一样实现继承</span><br><span class="line">interface Man extends Human &#123;</span><br><span class="line">    run(): voild</span><br><span class="line">&#125;</span><br><span class="line">interface Child &#123;</span><br><span class="line">    cry(): voild</span><br><span class="line">&#125;</span><br><span class="line">interface Boy extends Man,Child &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 添加被继承过来的属性</span><br><span class="line">let body: Boy = &#123;</span><br><span class="line">    name: &#x27;xx&#x27;,</span><br><span class="line">    run() &#123;&#125;,</span><br><span class="line">    eat() &#123;&#125;,</span><br><span class="line">    cry() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十二、public-private-和-protected"><a href="#十二、public-private-和-protected" class="headerlink" title="十二、public private 和 protected"></a>十二、public private 和 protected</h2><ul>
<li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li>
<li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li>
</ul>
<h2 id="十三、泛型"><a href="#十三、泛型" class="headerlink" title="十三、泛型"></a>十三、泛型</h2><blockquote>
<p>更多详情 <a target="_blank" rel="noopener" href="http://blog.poetries.top/ts-axios/chapter2/generic.html">http://blog.poetries.top/ts-axios/chapter2/generic.html</a></p>
</blockquote>
<blockquote>
<p>泛型就是解决 类 接口 方法的复用性、以及对不特定数据类型的支持。<strong>泛型理解为代表类型的参数，只是另一个维度的参数</strong></p>
</blockquote>
<p><strong>正确的做法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//只能返回string类型的数据</span><br><span class="line">function getData(value:string):string&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同时返回 string类型 和number类型  （代码冗余）</span><br><span class="line">function getData1(value:string):string&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line">function getData2(value:number):number&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;使用泛型后就可以解决这个问题</span><br><span class="line">// T表示泛型，具体什么类型是调用这个方法的时候决定的</span><br><span class="line">// 表示参数是什么类型就返回什么类型~~~</span><br><span class="line">function getData&lt;T&gt;(value:T):T&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;number&gt;(123);</span><br><span class="line">getData&lt;string&gt;(&#x27;1214231&#x27;);</span><br><span class="line"></span><br><span class="line">// 定义接口</span><br><span class="line">interface ConfigFn&#123;</span><br><span class="line">    &lt;T&gt;(value:T):T;</span><br><span class="line">&#125;</span><br><span class="line">var getData:ConfigFn=function&lt;T&gt;(value:T):T&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;string&gt;(&#x27;张三&#x27;);</span><br><span class="line">getData&lt;string&gt;(1243);  //错误</span><br></pre></td></tr></table></figure>

<h3 id="13-1-泛型函数和接口"><a href="#13-1-泛型函数和接口" class="headerlink" title="13.1 泛型函数和接口"></a>13.1 泛型函数和接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 这两个等价的，使用时无需指定类型</span><br><span class="line">type Log = &lt;T&gt;(value: T) =&gt; T;</span><br><span class="line"></span><br><span class="line">// 只约束改成员</span><br><span class="line">interface Log &#123;</span><br><span class="line">  &lt;T&gt;(value: T):T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这两个等价的，使用时必须指定类型</span><br><span class="line">type Log&lt;T&gt; = (value: T) =&gt; T;</span><br><span class="line"></span><br><span class="line">// 约束接口的所有成员</span><br><span class="line">interface Log&lt;T&gt; &#123;</span><br><span class="line">  (value: T):T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-2-泛型类与泛型约束"><a href="#13-2-泛型类与泛型约束" class="headerlink" title="13.2 泛型类与泛型约束"></a>13.2 泛型类与泛型约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 把泛型放到类的后面，就可以约束所有成员</span><br><span class="line">class Log&lt;T&gt; &#123;</span><br><span class="line">    run(value: T) &#123;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line">    // 不能约束静态成员</span><br><span class="line">   // static eat() // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化类 传入类型</span><br><span class="line">let log1 = new Log&lt;number&gt;()</span><br><span class="line">log1.run(1)</span><br><span class="line"></span><br><span class="line">// 不指定类型参数传任意都允许</span><br><span class="line">let log2 = new Log()</span><br><span class="line">log2.run(&#x27;1&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>类型约束</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Length &#123;</span><br><span class="line">    length: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// T继承了接口 约束了不是任意类型都可传。传入的参数必须有length属性</span><br><span class="line">function log&lt;T extends Length&gt;(value: T): T &#123;</span><br><span class="line">    console.log(value, value.length)</span><br><span class="line">    return value</span><br><span class="line">&#125;</span><br><span class="line">// 如数组、字符串、对象都有length属性</span><br><span class="line">log([1])</span><br><span class="line">log(&#x27;1&#x27;)</span><br><span class="line">log(&#123;a:1&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>函数和类可以轻松支持多种类型，增强程序的扩展性</li>
<li>不必写多条函数重载</li>
<li>灵活控制类型之间的约束</li>
</ul>
<p><strong>对象属性约束</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 泛型约束对象中的属性</span><br><span class="line">function getProp&lt;T,K extends keyof T&gt;(obj:T,key: K) &#123;</span><br><span class="line">    return obj[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十四、类型检查机制"><a href="#十四、类型检查机制" class="headerlink" title="十四、类型检查机制"></a>十四、类型检查机制</h2><h3 id="14-1-类型检查机制"><a href="#14-1-类型检查机制" class="headerlink" title="14.1 类型检查机制"></a>14.1 类型检查机制</h3><blockquote>
<p>编译器在做类型检查时，秉承的一些原则，表现出的一些行为</p>
</blockquote>
<p>作用：辅助开发，提高开发效率</p>
<ul>
<li>类型推断</li>
<li>类型兼容性</li>
<li>类型保护</li>
</ul>
<blockquote>
<p>所谓类型推断：不需要指定变量的类型（函数的返回值类型），TS可以根据某些规则自动的为其推断出一个类型</p>
</blockquote>
<ul>
<li>基础类型推断</li>
<li>最佳通用类型推断</li>
<li>上下文类型推断</li>
</ul>
<blockquote>
<p>基础类型推断，从右向左。但是有些是从左向右推断</p>
</blockquote>
<p>如事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ts 根据onkeydown推断出类型</span><br><span class="line">window.onkeydown = event=&gt;&#123;</span><br><span class="line">    console.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过类型断言阻断TS的类型推断</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">    bar: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//let foo = &#123;&#125; as Foo</span><br><span class="line">//foo.bar = 1</span><br><span class="line"></span><br><span class="line">let foo: Foo = &#123;</span><br><span class="line">    bar: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-2-类型保护机制"><a href="#14-2-类型保护机制" class="headerlink" title="14.2 类型保护机制"></a>14.2 类型保护机制</h3><blockquote>
<p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 Fish 或者是 Bird 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员</p>
</blockquote>
<p><strong>不同的判断方法有不同的使用场景：</strong></p>
<ul>
<li><code>typeof</code>：判断一个变量的类型</li>
<li><code>instanceof</code>：判断一个实例是否属于某个类</li>
<li><code>in</code>：判断一个属性是否属于某个对象</li>
<li>类型保护函数：某些判断可能不是一条语句能够搞定的，需要更多复杂的逻辑，适合封装到一个函数内</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function getLanguage(type: Type) &#123;</span><br><span class="line">    let lang = type === type.Strong ? new Java(): new Javascript()</span><br><span class="line">    </span><br><span class="line">    // 类型保护instanceof</span><br><span class="line">    if(lang instanceof Java)&#123;</span><br><span class="line">        lang.hellJava()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        lang.hellJavaScript()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // in</span><br><span class="line">    if(&#x27;java&#x27; in lang) &#123;</span><br><span class="line">        lang.hellJava()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        lang.hellJavaScript()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 类型保护函数方式</span><br><span class="line">    if(isJava(lang)) &#123;</span><br><span class="line">        lang.hellJava()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        lang.hellJavaScript()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一种类型保护函数</span><br><span class="line">function isJava(lang: Java | Javascript): lang is Java &#123;</span><br><span class="line">    // 类型断言</span><br><span class="line">    return (lang as Java).lang.helloJava !== undefined</span><br><span class="line">&#125;</span><br><span class="line">let pet = getSmallPet()</span><br><span class="line"></span><br><span class="line">// 每一个成员访问都会报错</span><br><span class="line">if (pet.swim) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125; else if (pet.fly) &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让这段代码工作，我们要使用类型断言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let pet = getSmallPet()</span><br><span class="line"></span><br><span class="line">if ((pet as Fish).swim) &#123;</span><br><span class="line">  (pet as Fish).swim()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  (pet as Bird).fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-2-1-用户自定义的类型保护"><a href="#14-2-1-用户自定义的类型保护" class="headerlink" title="14.2.1 用户自定义的类型保护"></a>14.2.1 用户自定义的类型保护</h4><ul>
<li>这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</li>
<li><code>TypeScript</code> 里的类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个类型谓词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isFish(pet: Fish | Bird): pet is Fish &#123;</span><br><span class="line">  return (pet as Fish).swim !== undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code>必须是来自于当前函数签名里的一个参数名。</li>
<li>每当使用一些变量调用 <code>isFish</code> 时，TypeScript 会将变量缩减为那个具体的类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (isFish(pet)) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 TypeScript 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在<code>else</code> 分支里，一定不是 <code>Fish</code>类型而是 <code>Bird</code> 类型</p>
</blockquote>
<h4 id="14-2-2-typeof-类型保护"><a href="#14-2-2-typeof-类型保护" class="headerlink" title="14.2.2 typeof 类型保护"></a>14.2.2 typeof 类型保护</h4><p>我们可以像下面这样利用类型断言来写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function isNumber (x: any):x is string &#123;</span><br><span class="line">  return typeof x === &#x27;number&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isString (x: any): x is string &#123;</span><br><span class="line">  return typeof x === &#x27;string&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function padLeft (value: string, padding: string | number) &#123;</span><br><span class="line">  if (isNumber(padding)) &#123;</span><br><span class="line">    return Array(padding + 1).join(&#x27; &#x27;) + value</span><br><span class="line">  &#125;</span><br><span class="line">  if (isString(padding)) &#123;</span><br><span class="line">    return padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 <code>typeof x === &#39;number&#39;</code>抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function padLeft (value: string, padding: string | number) &#123;</span><br><span class="line">  if (typeof padding === &#x27;number&#x27;) &#123;</span><br><span class="line">    return Array(padding + 1).join(&#x27; &#x27;) + value</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof padding === &#x27;string&#x27;) &#123;</span><br><span class="line">    return padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这些 <code>typeof</code> 类型保护只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code>必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>，<code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。</p>
</blockquote>
<h4 id="14-2-3-instanceof-类型保护"><a href="#14-2-3-instanceof-类型保护" class="headerlink" title="14.2.3 instanceof 类型保护"></a>14.2.3 instanceof 类型保护</h4><ul>
<li>如果你已经阅读了 <code>typeof</code> 类型保护并且对 JavaScript 里的 <code>instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</li>
<li><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Bird &#123;</span><br><span class="line">  fly () &#123;</span><br><span class="line">    console.log(&#x27;bird fly&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  layEggs () &#123;</span><br><span class="line">    console.log(&#x27;bird lay eggs&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fish &#123;</span><br><span class="line">  swim () &#123;</span><br><span class="line">    console.log(&#x27;fish swim&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  layEggs () &#123;</span><br><span class="line">    console.log(&#x27;fish lay eggs&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getRandomPet () &#123;</span><br><span class="line">  return Math.random() &gt; 0.5 ? new Bird() : new Fish()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let pet = getRandomPet()</span><br><span class="line"></span><br><span class="line">if (pet instanceof Bird) &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br><span class="line">if (pet instanceof Fish) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十五、高级类型"><a href="#十五、高级类型" class="headerlink" title="十五、高级类型"></a>十五、高级类型</h2><h3 id="15-1-交叉类型（取并集）"><a href="#15-1-交叉类型（取并集）" class="headerlink" title="15.1 交叉类型（取并集）"></a>15.1 交叉类型（取并集）</h3><blockquote>
<p>交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Loggable</code>。就是说这个类型的对象同时拥有了这两种类型的成员。</p>
</blockquote>
<blockquote>
<p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript里发生这种情况的场合很多！）下面是如何创建混入的一个简单例子</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">function extend&lt;T, U&gt; (first: T, second: U): T &amp; U &#123;</span><br><span class="line">  let result = &#123;&#125; as T &amp; U</span><br><span class="line">  for (let id in first) &#123;</span><br><span class="line">    result[id] = first[id] as any</span><br><span class="line">  &#125;</span><br><span class="line">  for (let id in second) &#123;</span><br><span class="line">    if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      result[id] = second[id] as any</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  constructor (public name: string) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Loggable &#123;</span><br><span class="line">  log (): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConsoleLogger implements Loggable &#123;</span><br><span class="line">  log () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var jim = extend(new Person(&#x27;Jim&#x27;), new ConsoleLogger())</span><br><span class="line">var n = jim.name</span><br><span class="line">jim.log()</span><br><span class="line">interface DogInterface &#123;</span><br><span class="line">    run(): void</span><br><span class="line">&#125;</span><br><span class="line">interface CatInterface &#123;</span><br><span class="line">    jump(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// pet 具备两个接口的所有方法</span><br><span class="line">let pet: DogInterface &amp; CatInterface = &#123;</span><br><span class="line">    run() &#123;&#125;,</span><br><span class="line">    jump() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 联合类型</span><br><span class="line">let a: number | string = 1</span><br><span class="line">let b: &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; // 字面量联合类型</span><br><span class="line">let c: 1 | 2 | 3 // 数字联合类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog implements DogInterface &#123;</span><br><span class="line">    run() &#123;&#125;</span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat  implements CatInterface &#123;</span><br><span class="line">    jump() &#123;&#125;</span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">enum Master &#123; Boy, Girl &#125;</span><br><span class="line">function getPet(master: Master) &#123;</span><br><span class="line">    let pet = master === Master.Boy ? new Dog() : new Cat();</span><br><span class="line">    // pet.run()</span><br><span class="line">    // pet.jump()</span><br><span class="line">    pet.eat()</span><br><span class="line">    return pet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square &#123;</span><br><span class="line">    kind: &quot;square&quot;;</span><br><span class="line">    size: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Rectangle &#123;</span><br><span class="line">    kind: &quot;rectangle&quot;;</span><br><span class="line">    width: number;</span><br><span class="line">    height: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Circle &#123;</span><br><span class="line">    kind: &quot;circle&quot;;</span><br><span class="line">    radius: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Shape = Square | Rectangle | Circle</span><br><span class="line"></span><br><span class="line">function area(s: Shape) &#123;</span><br><span class="line">    switch (s.kind) &#123;</span><br><span class="line">        case &quot;square&quot;:</span><br><span class="line">            return s.size * s.size;</span><br><span class="line">        case &quot;rectangle&quot;:</span><br><span class="line">            return s.height * s.width;</span><br><span class="line">        case &#x27;circle&#x27;:</span><br><span class="line">            return Math.PI * s.radius ** 2</span><br><span class="line">        default:</span><br><span class="line">            return ((e: never) =&gt; &#123;throw new Error(e)&#125;)(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(area(&#123;kind: &#x27;circle&#x27;, radius: 1&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="15-2-索引类型"><a href="#15-2-索引类型" class="headerlink" title="15.2 索引类型"></a>15.2 索引类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// function getValues(obj: any, keys: string[]) &#123;</span><br><span class="line">//     return keys.map(key =&gt; obj[key])</span><br><span class="line">// &#125;</span><br><span class="line">function getValues&lt;T, K extends keyof T&gt;(obj: T, keys: K[]): T[K][] &#123;</span><br><span class="line">    return keys.map(key =&gt; obj[key])</span><br><span class="line">&#125;</span><br><span class="line">console.log(getValues(obj, [&#x27;a&#x27;, &#x27;b&#x27;]))</span><br><span class="line">// console.log(getValues(obj, [&#x27;d&#x27;, &#x27;e&#x27;]))</span><br><span class="line"></span><br><span class="line">// keyof T</span><br><span class="line">interface Obj &#123;</span><br><span class="line">    a: number;</span><br><span class="line">    b: string;</span><br><span class="line">&#125;</span><br><span class="line">let key: keyof Obj</span><br><span class="line"></span><br><span class="line">// T[K]</span><br><span class="line">let value: Obj[&#x27;a&#x27;]</span><br><span class="line"></span><br><span class="line">// T extends U</span><br></pre></td></tr></table></figure>

<h3 id="15-3-映射类型"><a href="#15-3-映射类型" class="headerlink" title="15.3 映射类型"></a>15.3 映射类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Obj &#123;</span><br><span class="line">    a: string;</span><br><span class="line">    b: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使得每个成员属性变为只读</span><br><span class="line">type ReadonlyObj = Readonly&lt;Obj&gt;</span><br><span class="line"></span><br><span class="line">// 把一个接口属性变为可选</span><br><span class="line">type PartialObj = Partial&lt;Obj&gt;</span><br><span class="line"></span><br><span class="line">// 抽取obj的子集</span><br><span class="line">type PickObj = Pick&lt;Obj, &#x27;a&#x27; | &#x27;b&#x27;&gt;</span><br><span class="line"></span><br><span class="line">type RecordObj = Record&lt;&#x27;x&#x27; | &#x27;y&#x27;, Obj&gt;</span><br></pre></td></tr></table></figure>

<h3 id="15-4-条件类型"><a href="#15-4-条件类型" class="headerlink" title="15.4 条件类型"></a>15.4 条件类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// T extends U ? X : Y</span><br><span class="line"></span><br><span class="line">type TypeName&lt;T&gt; =</span><br><span class="line">    T extends string ? &quot;string&quot; :</span><br><span class="line">    T extends number ? &quot;number&quot; :</span><br><span class="line">    T extends boolean ? &quot;boolean&quot; :</span><br><span class="line">    T extends undefined ? &quot;undefined&quot; :</span><br><span class="line">    T extends Function ? &quot;function&quot; :</span><br><span class="line">    &quot;object&quot;;</span><br><span class="line">type T1 = TypeName&lt;string&gt;</span><br><span class="line">type T2 = TypeName&lt;string[]&gt;</span><br><span class="line"></span><br><span class="line">// (A | B) extends U ? X : Y</span><br><span class="line">// (A extends U ? X : Y) | (B extends U ? X : Y)</span><br><span class="line">type T3 = TypeName&lt;string | string[]&gt;</span><br><span class="line"></span><br><span class="line">type Diff&lt;T, U&gt; = T extends U ? never : T</span><br><span class="line">type T4 = Diff&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;</span><br><span class="line">// Diff&lt;&quot;a&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;b&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;</span><br><span class="line">// never | &quot;b&quot; | &quot;c&quot;</span><br><span class="line">// &quot;b&quot; | &quot;c&quot;</span><br><span class="line"></span><br><span class="line">type NotNull&lt;T&gt; = Diff&lt;T, null | undefined&gt;</span><br><span class="line">type T5 = NotNull&lt;string | number | undefined | null&gt;</span><br><span class="line"></span><br><span class="line">// Exclude&lt;T, U&gt;</span><br><span class="line">// NonNullable&lt;T&gt;</span><br><span class="line"></span><br><span class="line">// Extract&lt;T, U&gt;</span><br><span class="line">type T6 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;</span><br><span class="line"></span><br><span class="line">// ReturnType&lt;T&gt;</span><br><span class="line">type T8 = ReturnType&lt;() =&gt; string&gt;</span><br></pre></td></tr></table></figure>

<h3 id="15-5-联合类型"><a href="#15-5-联合类型" class="headerlink" title="15.5 联合类型"></a>15.5 联合类型</h3><blockquote>
<p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。 例如下面的函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function padLeft(value: string, padding: any) &#123;</span><br><span class="line">  if (typeof padding === &#x27;number&#x27;) &#123;</span><br><span class="line">    return Array(padding + 1).join(&#x27; &#x27;) + value</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof padding === &#x27;string&#x27;) &#123;</span><br><span class="line">    return padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">padLeft(&#x27;Hello world&#x27;, 4) // returns &quot;    Hello world&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>padLeft 存在一个问题，padding 参数的类型指定成了 any。 这就是说我们可以传入一个既不是 number 也不是 string 类型的参数，但是 TypeScript 却不报错</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let indentedString = padLeft(&#x27;Hello world&#x27;, true) // 编译阶段通过，运行时报错</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了解决这个问题，我们可以使用 联合类型做为 <code>padding</code> 的参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function padLeft(value: string, padding: string | number) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let indentedString = padLeft(&#x27;Hello world&#x27;, true) // 编译阶段报错</span><br></pre></td></tr></table></figure>

<ul>
<li>联合类型表示一个值可以是几种类型之一。我们用竖线（<code>|</code>）分隔每个类型，所以 <code>number | string</code> 表示一个值可以是 <code>number</code>或<code>string</code>。</li>
</ul>
<blockquote>
<p>如果一个值是联合类型，<strong>我们只能访问此联合类型的所有类型里共有的成员</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">  fly()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Fish &#123;</span><br><span class="line">  swim()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getSmallPet(): Fish | Bird &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let pet = getSmallPet()</span><br><span class="line">pet.layEggs() // okay</span><br><span class="line">pet.swim()    // error</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，Fish 具有一个 <code>swim</code> 方法，我们不能确定一个 <code>Bird | Fish</code>类型的变量是否有 <code>swim</code>方法。 如果变量在运行时是 Bird 类型，那么调用 <code>pet.swim()</code>就出错了</p>
</blockquote>
<h2 id="十六、初学者的困惑"><a href="#十六、初学者的困惑" class="headerlink" title="十六、初学者的困惑"></a>十六、初学者的困惑</h2><h3 id="16-1-如何优雅的声明类型"><a href="#16-1-如何优雅的声明类型" class="headerlink" title="16.1 如何优雅的声明类型"></a>16.1 如何优雅的声明类型</h3><h4 id="16-1-1-基础"><a href="#16-1-1-基础" class="headerlink" title="16.1.1 基础"></a>16.1.1 基础</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Basic &#123;</span><br><span class="line">  num: number;</span><br><span class="line">  str: string | null;</span><br><span class="line">  bol?: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>五种 JS 值类型就声明好了。那数组、函数呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Func &#123;</span><br><span class="line">  func(str: string): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Arr &#123;</span><br><span class="line">  str: string[];</span><br><span class="line">  mixed: Array&lt;string | number&gt;;</span><br><span class="line">  fixedStructure: [string, number];</span><br><span class="line">  basics: Basic[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>枚举类型也是很常用的，比如声明一个状态机的各个状态</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">  Draft,</span><br><span class="line">  Published</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 也可指定值</span><br><span class="line">enum Status &#123;</span><br><span class="line">  Draft = &#x27;Draft&#x27;,</span><br><span class="line">  Published = &#x27;Published&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-1-2-糅合"><a href="#16-1-2-糅合" class="headerlink" title="16.1.2 糅合"></a>16.1.2 糅合</h4><p><strong>独立声明</strong></p>
<blockquote>
<p>一个 <code>ts</code> 文件只声明一个类型或者接口，文件名为需要暴露的类型名称，方便检索和管理</p>
</blockquote>
<p><strong>就近声明</strong></p>
<blockquote>
<p>当一个声明没有被外部引用或者依赖时，可以考虑就近放在使用的地方，典型的场景是 <code>React</code> 组件的 <code>Props</code> 和 <code>State</code> 的类型声明</p>
</blockquote>
<p><strong>按职责分组</strong></p>
<ul>
<li>在项目中，需要声明类型的可大致分为两类：一类是 <code>model</code>，也就是接口请求相关的，包括入参和出参；另一类是 <code>view</code>，界面渲染相关的。因此，我在 独立声明 的基础上，可以类型按照<code>model</code> 和 <code>view</code> 的维度进行分组，相互独立。</li>
<li>那么问题来了，如果是独立的类型声明的话，怎么把 model 的数据应用到 <code>view</code> 呢？ 可能你需要一个 <code>adapter</code> 来做类型的的转换：<code>DTOTypes</code> -&gt; <code>adapter</code> -&gt; <code>ViewTypes</code>, 完成类似于将接口中的字符串映射成枚举类型这之类的转换</li>
</ul>
<p><strong>any</strong></p>
<blockquote>
<p>当遇到确实解决不了的类型报错的时候，<code>as any</code> 能带给你不一样的快感，但是不建议使用啊</p>
</blockquote>
<h3 id="16-2-如何引用外部库"><a href="#16-2-如何引用外部库" class="headerlink" title="16.2 如何引用外部库"></a>16.2 如何引用外部库</h3><blockquote>
<p>在 <code>JS</code> 中，<code>npm</code> 上有丰富的海量的库帮我们完成日常的编码，可能并不是所有的库都能完全被应用到 <code>TS</code> 中，因为有些缺少类型声明</p>
</blockquote>
<p>比如，在 <code>TS</code> 中使用 <code>react</code>, 你会得到这样的一个类型检查错误：</p>
<p><img src="https://pic2.zhimg.com/80/v2-fdfb8e5f2be67d8c978e216254b80a9d_hd.jpg" alt="img"></p>
<ul>
<li>因为 react 的库中并没有类型声明</li>
<li>现在比较通用的做法是，实现和类型实现独立成两个库，也就是你需要再安装类型声明的库: <code>@types/react</code></li>
<li>当遇到上述问题的时候，尝试安装一下 <code>@types/[package]</code></li>
<li>然而，并不是所有的库都有类型声明的实现，也会有很多不支持 TS 的存在，然而又必须得使用这个库的时候该怎么办？</li>
</ul>
<p><strong>自己写声明</strong></p>
<blockquote>
<p>以 <code>progressbar.js</code>为例，基本使用方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import * as ProgressBar from &#x27;progressbar.js&#x27;;</span><br><span class="line"></span><br><span class="line">new ProgressBar.Circle(this.$progress, &#123;</span><br><span class="line">  strokeWidth: 8,</span><br><span class="line">  trailColor: &#x27;#e5e4e5&#x27;,</span><br><span class="line">  trailWidth: 8,</span><br><span class="line">  easing: &#x27;easeInOut&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们需要对库中暴露出的 api 去做声明，对上述例子做个分解：暴露了 Circle 类，Circle 构造函数包含两个参数，一个 HTMLElement，一个 options. OK</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 首先声明一下模块：</span><br><span class="line">declare module &#x27;progressbar.js&#x27; &#123;</span><br><span class="line">  // 模块中暴露了 Circle 类</span><br><span class="line">  export class Circle &#123;</span><br><span class="line">    constructor(container: HTMLElement, options: Options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 构造函数的 Options 需要单独声明 </span><br><span class="line">  interface Options &#123;</span><br><span class="line">    easing?: string;</span><br><span class="line">    strokeWidth?: number;</span><br><span class="line">    trailColor?: string;</span><br><span class="line">    trailWidth?: number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如此我们便完成了一个简单的声明，当然实际使用中的 API 肯定比上述情况复杂，根据使用情况，用了哪些 API 或者参数，就补充那些的声明即可</p>
</blockquote>
<h3 id="16-3-如何组织一个-TS-项目"><a href="#16-3-如何组织一个-TS-项目" class="headerlink" title="16.3 如何组织一个 TS 项目"></a>16.3 如何组织一个 TS 项目</h3><ul>
<li>TS 项目的目录组织上，跟 JS 项目一样，补充好 types 的声明就可以了</li>
<li>需要注意的是，将你希望对外暴露的能力相关的类型声明都暴露出去，不友好的声明会让接入你项目的人非常的痛苦，同时，在 package.json 中需要指定 type 的 path, 比如：”types”: “dist&#x2F;types&#x2F;index.d.ts”</li>
<li>另外，务必加上 tslint, 更规范的去用 TS 实现功能，对于入门而言尤为重要</li>
</ul>
<h3 id="16-4-TSX-和-JSX"><a href="#16-4-TSX-和-JSX" class="headerlink" title="16.4 TSX 和 JSX"></a>16.4 TSX 和 JSX</h3><ul>
<li>之前我们在用 <code>JavaScript</code> 写 <code>React</code> 时，对文件的扩展名没有什么特别的要求，<code>.js</code> 或者 <code>.jsx</code> 都行。</li>
<li>但在 <code>TypeScript</code> 中，如果你要使用 <code>JSX</code> 语法，就不能使用 <code>.ts</code>，必须使用 <code>.tsx</code>。如果你不知道，或者忘了这么做，那么你会在使用了 <code>JSX</code> 代码的地方收到类型报错，但代码本身怎么看都没有问题。这也是刚上手 <code>TypeScript + React</code> 时几乎每个人都会遇到的坑。</li>
<li>关于这一点，<code>TypeScript</code> 只是在官方教程的示例代码中直接用了 <code>*.tsx</code>，但并没有明确说明这一问题</li>
</ul>
<h3 id="16-5-变量的-Type-怎么找"><a href="#16-5-变量的-Type-怎么找" class="headerlink" title="16.5 变量的 Type 怎么找"></a>16.5 变量的 Type 怎么找</h3><ul>
<li>上手 <code>TypeScript</code> 之后很快我们就发现，即便是原生的 <code>DOM</code>、或是 <code>React</code> 的 <code>API</code>，也经常会要我们手动指定类型。但这些结构并不是简单的 <code>JavaScript</code>原始类型，在使用 <code>JavaScript</code> 编写相关代码时候由于没有这种需要，我们也没关心过这些东西的类型，突然问起来，还真不知道这些类型叫什么名字。</li>
<li>不光是这些标准类型，同样的问题在很多第三方的库中也会遇到，比如一些组件库会检查你传入的 <code>Props</code></li>
<li>在我看来，这中间其实缺少了一部分的文档，来指导新用户如何找到所需要的类型。既然社区没有提供，那就我来吧。</li>
<li>当然，让每个开发者都熟记所有的类型肯定是不现实的，总不能每接触一个新的库，就要去记一堆类型吧。放心，世界还是美好的，这种事情，当然是有方法的。</li>
<li>最直白的方法就是去看库的 <code>Types Definition</code>，也就是那些 <code>.*d.ts</code> 文件。如果你刚好有在用 <code>VS Code</code> 的话，有一个非常方便的操作：把鼠标移动到你想知道它类型的代码上（比如某个变量、某个函数调用，或是某个 JSX 标签、某个组件的 props），右键选择「Go to Definition」（或者光标选中后按 F12），就可以跳转到它的类型定义文件了。</li>
<li>如果你更习惯使用 VS Code 之外的编辑器，我相信时至今日，它们应该也都早就对 <code>TypeScript</code> 提供了支持。具体操作我不太熟悉，你可以自己探索下（我一直用 VS Code，其它的不太熟）</li>
<li>一般来说，这个操作可以直接把你带到你想要的地方，但考虑到类型是可以继承的，有时候一次跳转可能不太够，遇到这种情况，那就需要你随机应变一下，沿着继承关系多跳几次，直到找到你想要的内容。</li>
<li>对于不熟悉的类型，可以通过这个方法去寻找，慢慢熟悉以后，你会发现，一些常见的类型还是很好找的，稍微联想一下英文的表达方式，配合自动补全的提示，一般都不难找到</li>
</ul>
<h3 id="16-6-常见-Types-之-DOM"><a href="#16-6-常见-Types-之-DOM" class="headerlink" title="16.6 常见 Types 之 DOM"></a>16.6 常见 Types 之 DOM</h3><ul>
<li><code>TypeScript</code> 自带了一些基本的类型定义，包括 ECMAScript 和 DOM 的类型定义，所有你需要的类型都可以从这里找到。如果你想做一些「纯 TypeScript 开发」的话，有这些就够了</li>
<li>比如下面这张截图，就是对 &#96;&#96; 标签的类型定义。我们可以看到，它继承了更加通用的 <code>HTMLElement</code> 类型，并且扩展了一个即将被废弃的 <code>align</code> 属性，以及两组 <code>addEventListener</code> 和 <code>removeEventListener</code>，注意这里使用了重载。</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/3.png" alt="img"></p>
<blockquote>
<p>这里的命名也不是随便起的，都是在 MDN 上可以查到的。还是以 &#96;&#96; 为例，我们已经知道它继承自 <code>HTMLElement</code>，其实再往上，<code>HTMLElement</code> 继承自 <code>Element</code>，<code>Element</code> 又继承自 <code>Node</code>，顺着这条路，你可以挖掘出所有 <code>HTML</code> 标签的类型</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/4.png" alt="img"></p>
<blockquote>
<p>对于一些 DOM 相关的属性，比如 <code>onclick</code>、<code>onchange</code> 等，你都可以如法炮制，找到它们的定义。</p>
</blockquote>
<h3 id="16-7-常见-Types-之-React"><a href="#16-7-常见-Types-之-React" class="headerlink" title="16.7 常见 Types 之 React"></a>16.7 常见 Types 之 React</h3><ul>
<li>关于 TypeScript 的问题，有不少其实是在使用第三方库的时候遇到的，React 就是其中比较典型的一个</li>
<li>其实方法都一样，只不过相关的类型定义不在 <code>TypeScript</code> 中，而是在 <code>@types/react</code> 中。</li>
<li><code>React</code> 的类型定义的名称其实也很直观，比如我们常见的 <code>React.Component</code>，在定义 <code>Class</code> 组件时，我们需要对 <code>Props</code> 和 <code>State</code> 预先进行类型定义，为什么呢？答案就在它的类型定义中</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/5.png" alt="img"></p>
<ul>
<li>再比如，当我们在写一些组件时，我们可能会需要向下传递 <code>this.props.children</code>，但 <code>children</code> 并没有被设为默认值，需要我们自己定义到 <code>props</code> 上，那么它的类型应该是什么呢</li>
<li>到类型定义中搜一下关键字 <code>children</code>，很快我们就找到了下面的定义</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/6.png" alt="img"></p>
<blockquote>
<p>所有 <code>React</code> 中 <code>JSX</code> 所代表的内容，无论是 <code>render()</code> 的返回，还是 <code>children</code>，我们都可以定义为一个 <code>ReactNode</code>。那这个 <code>ReactNode</code> 长什么样呢？我们通过右键继续寻找</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/7.png" alt="img"></p>
<blockquote>
<p>看到这里，我们不光找到了我们想要的类型，还顺带明白了为什么 <code>render()</code> 可以返回 <code>boolean</code>、<code>null</code>、<code>undefined</code> 表示不渲染任何内容。<br>那么事件呢？当我们给组件定义事件处理函数的时候，也经常会被要求指定类型。还是老办法，找不到咱就搜，比如 <code>onClick</code> 不清楚，那我们就以它为关键字去搜</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/8.png" alt="img"></p>
<blockquote>
<p>据此我们找到一个叫 <code>MouseEventHandler</code> 的定义，这名字，够直白吧。好了，我们找到想要的了。不过既然来了，不如继续看一下，看看还能发现什么。我们右键 <code>MouseEventHandler</code> 急需往下看：</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/9.png" alt="img"></p>
<blockquote>
<p>看到了吗，所有的事件处理函数都有对应的定义，每个都需要一个泛型参数，传递了事件的类型，名称也挺直白的</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/20190903/10.png" alt="img"></p>
<blockquote>
<p>事件的类型也被我们挖出来了，以后如果需要单独定义一个事件相关的类型，就可以直接用了。以此类推，不管是什么东西的类型，都可以去它们对应的 <code>@types/xxx</code>里，按关键字搜</p>
</blockquote>
<h3 id="16-8-多重-extends"><a href="#16-8-多重-extends" class="headerlink" title="16.8 多重 extends"></a>16.8 多重 extends</h3><ul>
<li>我们知道 <code>Interface</code> 是可以多继承的，<code>extends</code> 后面可以跟多个其它 <code>Interface</code>，我们不能保证被继承的多个 <code>Interface</code> 一定没有重复的属性，那么当属性重复，但类型定义不同时，最终的结果会怎么样呢？</li>
<li>在 <code>TypeScript</code> 中，<code>Interface</code> 会按照从右往左的顺序去合并多个被继承的 <code>Interface</code>，也就是说，同名属性，左边的会覆盖右边的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">  value?: string</span><br><span class="line">&#125;</span><br><span class="line">interface B &#123;</span><br><span class="line">  value: string</span><br><span class="line">&#125;</span><br><span class="line">interface C &#123;</span><br><span class="line">  value: number</span><br><span class="line">&#125;</span><br><span class="line">interface D extends A, B &#123;&#125;// value?: string</span><br><span class="line">interface E extends B, C &#123;&#125;// value: string</span><br></pre></td></tr></table></figure>

<h3 id="16-9-obj-prop-无法访问怎么办"><a href="#16-9-obj-prop-无法访问怎么办" class="headerlink" title="16.9 obj[prop] 无法访问怎么办"></a>16.9 obj[prop] 无法访问怎么办</h3><ul>
<li>有时候我们会定义一些集合型的数据，例如对象、枚举等，但在调用的时候，我们未必会直接通过 <code>obj.prop</code> 的形式去调用，可能会是以 <code>obj[prop]</code> 这种动态索引的形式去访问，但通过动态索引的方式就无法确定最终访问的元素是否存在，因此在 <code>TypeScript</code> 中，默认是不允许这种操作的</li>
<li>但这又是个非常合理，而且非常常见的场景，怎么办呢？<code>TypeScript</code> 允许为类型添加索引，以实现这一点。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">  x: string,</span><br><span class="line">  y: number</span><br><span class="line">  [index: string]: string | number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个方法虽然有效，但每次都要手动为类型加索引，重复多了也挺心累的。包括在一些「配置对象」中，我们甚至无法确定有哪些类型，有没有一种更加通用、更加一劳永逸的方法。</li>
<li>其实在 <code>TypeScript</code>的官方文档中就有提到这个方案，官方管它叫 <code>OptionBag</code>，大概就是指 <code>config</code>、o<code>ption</code> 等用于提供配置信息的这么一类参数。我不是很确定这到底是个常规的英文单词，还是 <code>TypeScript</code> 中特定的术语（个人感觉是前者），反正就这么个意思吧。<br>简单说来，我们可以定义下面这样一个类型：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface OptionBag &#123;</span><br><span class="line">  [index: string]: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个非常通用的结构，以字符串为键，值可以是任何类型，并且支持索引 —— 这不就是 <code>Object</code> 么。</li>
<li>之后所有需要动态索引的结构，或是作为配置对象的结构，都可以直接指定为，或是继承 <code>OptionBag</code>。这个方案以牺牲一定的类型检查为代价，换取了操作上的便利。</li>
<li>理论上讲，<code>OptionBag</code> 可以适用于所有类似对象这样的结构，但不建议各位真就这么做。这个方案只能是用在一些对类型要求不那么严格，或是无法预知类型的场景中，能够确定的类型还是尽可能地写一下，否则就失去了使用 <code>TypeScript</code> 意义了</li>
</ul>
<h2 id="十七、其他技巧"><a href="#十七、其他技巧" class="headerlink" title="十七、其他技巧"></a>十七、其他技巧</h2><p><strong>1. 安全导航操作符 ( ?. )和非空断言操作符（!.）</strong></p>
<ul>
<li><strong>安全导航操作符 ( ?. ) 和空属性路径</strong>：</li>
</ul>
<blockquote>
<p>为了解决导航时变量值为null时，页面运行时出错的问题</p>
</blockquote>
<ul>
<li><strong>非空断言操作符</strong></li>
</ul>
<blockquote>
<p>能确定变量值一定不为空时使用。与安全导航操作符不同的是，非空断言操作符不会防止出现 <code>null</code> 或 <code>undefined</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s = e!.name; // 断言e是非空并访问name属性</span><br></pre></td></tr></table></figure>

<h1 id="第二章-工程篇"><a href="#第二章-工程篇" class="headerlink" title="第二章 工程篇"></a>第二章 工程篇</h1><p><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-1.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-2.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-3.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-4.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-5.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-6.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-7.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-8.webp" alt="img"></p>
<h2 id="一、使用命名空间"><a href="#一、使用命名空间" class="headerlink" title="一、使用命名空间"></a>一、使用命名空间</h2><blockquote>
<p>不要在一个模块中使用命名空间，最好在一个全局中使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// a.ts</span><br><span class="line">namespace Shape &#123;</span><br><span class="line">    const pi = Math.PI</span><br><span class="line">    export function cricle(r: number) &#123;</span><br><span class="line">        return pi * r ** 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// b.ts</span><br><span class="line"></span><br><span class="line">// 三斜线引用a</span><br><span class="line">/// &lt;reference path=&quot;a.ts&quot; /&gt;</span><br><span class="line">namespace Shape &#123;</span><br><span class="line">    export function square(x: number) &#123;</span><br><span class="line">        return x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Shape.cricle(2))</span><br><span class="line">console.log(Shape.square(2))</span><br><span class="line"></span><br><span class="line">// 更方便使用 不是es6中的import</span><br><span class="line">import cricle = Shape.cricle</span><br><span class="line">console.log(cricle(2))</span><br></pre></td></tr></table></figure>

<h2 id="二、理解联合声明"><a href="#二、理解联合声明" class="headerlink" title="二、理解联合声明"></a>二、理解联合声明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 接口声明合并</span><br><span class="line">interface A &#123;</span><br><span class="line">    x: number;</span><br><span class="line">    // y: string;</span><br><span class="line">    foo(bar: number): number; // 5</span><br><span class="line">    foo(bar: &#x27;a&#x27;): string; // 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A &#123;</span><br><span class="line">    y: number;</span><br><span class="line">    foo(bar: string): string; // 3</span><br><span class="line">    foo(bar: string[]): string[]; // 4</span><br><span class="line">    foo(bar: &#x27;b&#x27;): string; // 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a: A = &#123;</span><br><span class="line">    x: 1,</span><br><span class="line">    y: 2,</span><br><span class="line">    foo(bar: any) &#123;</span><br><span class="line">        return bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 命名空间和类声明合并--命名空间需要放到后面</span><br><span class="line">class C &#123;&#125;</span><br><span class="line">namespace C &#123;</span><br><span class="line">    export let state = 1</span><br><span class="line">&#125;</span><br><span class="line">console.log(C.state)</span><br><span class="line"></span><br><span class="line">// 命名空间和函数声明合并--命名空间需要放到后面</span><br><span class="line">function Lib() &#123;&#125;</span><br><span class="line">namespace Lib &#123;</span><br><span class="line">    export let version = &#x27;1.0&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Lib.version)</span><br><span class="line"></span><br><span class="line">// 命名空间和枚举声明合并--位置没有要求</span><br><span class="line">enum Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Yellow,</span><br><span class="line">    Blue</span><br><span class="line">&#125;</span><br><span class="line">namespace Color &#123;</span><br><span class="line">    export function mix() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Color)</span><br></pre></td></tr></table></figure>

<h2 id="三、如何编写声明文件–引入类库"><a href="#三、如何编写声明文件–引入类库" class="headerlink" title="三、如何编写声明文件–引入类库"></a>三、如何编写声明文件–引入类库</h2><blockquote>
<p>类库分为三类：全局类库、模块类库、<code>UMD</code>类库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare var // 声明全局变量</span><br><span class="line">declare function // 声明全局方法</span><br><span class="line">declare class // 声明全局类</span><br><span class="line">declare enum // 声明全局枚举类型</span><br><span class="line">declare global // 扩展全局变量</span><br><span class="line">declare module // 扩展模块</span><br></pre></td></tr></table></figure>

<blockquote>
<p>大多数的声明文件社区已经帮我们安装好了，使用<code>@types/包名</code>声明文件即可</p>
</blockquote>
<blockquote>
<p>Typescript声明文件查找 <a target="_blank" rel="noopener" href="https://microsoft.github.io/TypeSearch/">https://microsoft.github.io/TypeSearch/</a></p>
</blockquote>
<p><strong>以jquery为例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @types/jquery</span><br></pre></td></tr></table></figure>

<p><strong>引入了一个JS类库，但是社区又没有提供类型声明文件，我该如何去编写它的类型声明文件</strong></p>
<blockquote>
<p>先确定这个库的类型，全局库、模块库、还是UMD库，然后参照下面介绍的方法，把它的<code>API</code>声明逐步添加进来（暂时用不到的<code>API</code>也可以不写）</p>
</blockquote>
<h3 id="3-1-三种类库声明文件写法"><a href="#3-1-三种类库声明文件写法" class="headerlink" title="3.1 三种类库声明文件写法"></a>3.1 三种类库声明文件写法</h3><h4 id="3-1-1-全局库"><a href="#3-1-1-全局库" class="headerlink" title="3.1.1 全局库"></a>3.1.1 全局库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// global-lib.d.ts</span><br><span class="line">    </span><br><span class="line">declare function globalLib(options: globalLib.Options): void;</span><br><span class="line">// 函数和命名空间的声明合并 为这个函数提供了一些属性</span><br><span class="line">declare namespace globalLib &#123;</span><br><span class="line">    const version: string;</span><br><span class="line">    function doSomething(): void;</span><br><span class="line">    interface Options &#123;</span><br><span class="line">        [key: string]: any</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// global-lib.js</span><br><span class="line">// 和声明文件对应</span><br><span class="line">function globalLib(options) &#123;</span><br><span class="line">    console.log(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">globalLib.version = &#x27;1.0.0&#x27;;</span><br><span class="line"></span><br><span class="line">globalLib.doSomething = function() &#123;</span><br><span class="line">    console.log(&#x27;globalLib do something&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">// 全局使用 index.ts</span><br><span class="line">globalLib(&#123;x:1&#125;)</span><br><span class="line">globalLib.doSomething()</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-模块类库"><a href="#3-1-2-模块类库" class="headerlink" title="3.1.2 模块类库"></a>3.1.2 模块类库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// module-lib.d.ts</span><br><span class="line">declare function moduleLib(options: Options): void</span><br><span class="line"></span><br><span class="line">interface Options &#123;</span><br><span class="line">    [key: string]: any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare namespace moduleLib &#123;</span><br><span class="line">    const version: string</span><br><span class="line">    function doSomething(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export = moduleLib</span><br><span class="line">// module-lib.js</span><br><span class="line">const version = &#x27;1.0.0&#x27;;</span><br><span class="line"></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    console.log(&#x27;moduleLib do something&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function moduleLib(options) &#123;</span><br><span class="line">    console.log(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moduleLib.version = version;</span><br><span class="line">moduleLib.doSomething = doSomething;</span><br><span class="line"></span><br><span class="line">module.exports = moduleLib;</span><br><span class="line">// index.ts 使用</span><br><span class="line">import umdLib from &#x27;./umd-lib&#x27;</span><br><span class="line"></span><br><span class="line">umdLib.doSomething()</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-UMD类库"><a href="#3-1-3-UMD类库" class="headerlink" title="3.1.3 UMD类库"></a>3.1.3 UMD类库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// umd-lib.d.ts</span><br><span class="line"></span><br><span class="line">declare namespace umdLib &#123;</span><br><span class="line">    // 省略了export</span><br><span class="line">    const version: string</span><br><span class="line">    function doSomething(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UMD库不可缺少的语句</span><br><span class="line">export as namespace umdLib</span><br><span class="line"></span><br><span class="line">export = umdLib</span><br><span class="line">// umd-lib.js</span><br><span class="line">(function (root, factory) &#123;</span><br><span class="line">    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;</span><br><span class="line">        define(factory);</span><br><span class="line">    &#125; else if (typeof module === &quot;object&quot; &amp;&amp; module.exports) &#123;</span><br><span class="line">        module.exports = factory();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        root.umdLib = factory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(this, function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        // 需要为这两个成员编写声明文件</span><br><span class="line">        version: &#x27;1.0.0&#x27;,</span><br><span class="line">        doSomething() &#123;</span><br><span class="line">            console.log(&#x27;umdLib do something&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line">// index.ts使用</span><br><span class="line">import umdLib from &#x27;./umd-lib&#x27;</span><br><span class="line">// 可以不用导入umd-lib模块。但是需要打开tsconfig.tson中的umd配置</span><br><span class="line">umdLib.doSomething()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-两种插件声明文件写法"><a href="#3-2-两种插件声明文件写法" class="headerlink" title="3.2 两种插件声明文件写法"></a>3.2 两种插件声明文件写法</h3><h4 id="3-2-1-模块化插件declare-module"><a href="#3-2-1-模块化插件declare-module" class="headerlink" title="3.2.1 模块化插件declare module"></a>3.2.1 模块化插件declare module</h4><blockquote>
<p><code>declare module</code> 可以给类库添加一些自定义方法。 扩展模块</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 模块插件</span><br><span class="line">import m from &#x27;moment&#x27;;</span><br><span class="line">declare module &#x27;moment&#x27; &#123;</span><br><span class="line">    // 给moment自定义一些方法</span><br><span class="line">    export function myFunction(): void;</span><br><span class="line">&#125;</span><br><span class="line">m.myFunction = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-全局插件declare-global"><a href="#3-2-2-全局插件declare-global" class="headerlink" title="3.2.2 全局插件declare global"></a>3.2.2 全局插件declare global</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 全局插件</span><br><span class="line">declare global &#123;</span><br><span class="line">    namespace globalLib &#123;</span><br><span class="line">        function doAnyting(): void</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在全局变量添加方法</span><br><span class="line">// 会对全局变量造成污染 一般不这么做</span><br><span class="line">globalLib.doAnyting = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-jquery声明文件示例"><a href="#3-3-jquery声明文件示例" class="headerlink" title="3.3 jquery声明文件示例"></a>3.3 jquery声明文件示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// index.d.ts入口</span><br><span class="line"></span><br><span class="line">// Type definitions for jquery 3.3</span><br><span class="line">// Project: https://jquery.com</span><br><span class="line">// Definitions by: Leonard Thieu &lt;https://github.com/leonard-thieu&gt;</span><br><span class="line">//                 Boris Yankov &lt;https://github.com/borisyankov&gt;</span><br><span class="line">//                 Christian Hoffmeister &lt;https://github.com/choffmeister&gt;</span><br><span class="line">//                 Steve Fenton &lt;https://github.com/Steve-Fenton&gt;</span><br><span class="line">//                 Diullei Gomes &lt;https://github.com/Diullei&gt;</span><br><span class="line">//                 Tass Iliopoulos &lt;https://github.com/tasoili&gt;</span><br><span class="line">//                 Jason Swearingen &lt;https://github.com/jasons-novaleaf&gt;</span><br><span class="line">//                 Sean Hill &lt;https://github.com/seanski&gt;</span><br><span class="line">//                 Guus Goossens &lt;https://github.com/Guuz&gt;</span><br><span class="line">//                 Kelly Summerlin &lt;https://github.com/ksummerlin&gt;</span><br><span class="line">//                 Basarat Ali Syed &lt;https://github.com/basarat&gt;</span><br><span class="line">//                 Nicholas Wolverson &lt;https://github.com/nwolverson&gt;</span><br><span class="line">//                 Derek Cicerone &lt;https://github.com/derekcicerone&gt;</span><br><span class="line">//                 Andrew Gaspar &lt;https://github.com/AndrewGaspar&gt;</span><br><span class="line">//                 Seikichi Kondo &lt;https://github.com/seikichi&gt;</span><br><span class="line">//                 Benjamin Jackman &lt;https://github.com/benjaminjackman&gt;</span><br><span class="line">//                 Poul Sorensen &lt;https://github.com/s093294&gt;</span><br><span class="line">//                 Josh Strobl &lt;https://github.com/JoshStrobl&gt;</span><br><span class="line">//                 John Reilly &lt;https://github.com/johnnyreilly&gt;</span><br><span class="line">//                 Dick van den Brink &lt;https://github.com/DickvdBrink&gt;</span><br><span class="line">//                 Thomas Schulz &lt;https://github.com/King2500&gt;</span><br><span class="line">//                 Terry Mun &lt;https://github.com/terrymun&gt;</span><br><span class="line">// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped</span><br><span class="line">// TypeScript Version: 2.3</span><br><span class="line"></span><br><span class="line">// 三斜线引入模块</span><br><span class="line"></span><br><span class="line">/// &lt;reference types=&quot;sizzle&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;</span><br><span class="line"></span><br><span class="line">export = jQuery;</span><br></pre></td></tr></table></figure>

<h2 id="四、配置tsconfig-json"><a href="#四、配置tsconfig-json" class="headerlink" title="四、配置tsconfig.json"></a>四、配置tsconfig.json</h2><h3 id="4-1-基础配置"><a href="#4-1-基础配置" class="headerlink" title="4.1 基础配置"></a>4.1 基础配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ===与文件相关的选项===</span><br><span class="line">  &quot;files&quot; : [&#x27;src/index.ts&#x27;], // 编译的文件列表</span><br><span class="line">  &quot;include&quot;: [&#x27;src&#x27;], // 指定编译文件</span><br><span class="line">  &quot;exclude&quot;: [&#x27;src/lib&#x27;], // 排除编译文件</span><br><span class="line">  </span><br><span class="line">  // ====与编译相关的选项====</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">      // &quot;incremental&quot;: true,                // 增量编译，再次编译会增量编译</span><br><span class="line">      // &quot;tsBuildInfoFile&quot;: &quot;./buildFile&quot;,   // 增量编译文件的存储位置</span><br><span class="line">      // &quot;diagnostics&quot;: true,                // 打印诊断信息</span><br><span class="line"></span><br><span class="line">      // &quot;target&quot;: &quot;es5&quot;,           // 目标语言的版本</span><br><span class="line">      // &quot;module&quot;: &quot;commonjs&quot;,      // 生成代码的模块标准</span><br><span class="line">      // &quot;outFile&quot;: &quot;./app.js&quot;,     // 将多个相互依赖的文件生成一个文件，可以用在 AMD 模块中</span><br><span class="line">        </span><br><span class="line">       // 比如你需要使用es2019方法 需要在这里导入模块 &quot;lib&quot;: [&#x27;es2019.arrary&#x27;]</span><br><span class="line">      // &quot;lib&quot;: [],                 // TS 需要引用的库，即声明文件，es5 默认 &quot;dom&quot;, &quot;es5&quot;, &quot;scripthost&quot;</span><br><span class="line"></span><br><span class="line">      // &quot;allowJs&quot;: true,           // 允许编译 JS 文件（js、jsx）</span><br><span class="line">      // &quot;checkJs&quot;: true,           // 允许在 JS 文件中报错，通常与 allowJS 一起使用</span><br><span class="line">      // &quot;outDir&quot;: &quot;./out&quot;,         // 指定输出目录</span><br><span class="line">      // &quot;rootDir&quot;: &quot;./&quot;,           // 指定输入文件目录（用于输出）</span><br><span class="line"></span><br><span class="line">      // &quot;declaration&quot;: true,         // 生成声明文件</span><br><span class="line">      // &quot;declarationDir&quot;: &quot;./d&quot;,     // 声明文件的路径</span><br><span class="line">      // &quot;emitDeclarationOnly&quot;: true, // 只生成声明文件</span><br><span class="line">      // &quot;sourceMap&quot;: true,           // 生成目标文件的 sourceMap</span><br><span class="line">      // &quot;inlineSourceMap&quot;: true,     // 生成目标文件的 inline sourceMap</span><br><span class="line">      // &quot;declarationMap&quot;: true,      // 生成声明文件的 sourceMap</span><br><span class="line">      // &quot;typeRoots&quot;: [],             // 声明文件目录，默认 node_modules/@types</span><br><span class="line">      // &quot;types&quot;: [],                 // 声明文件包</span><br><span class="line"></span><br><span class="line">      // &quot;removeComments&quot;: true,    // 删除注释</span><br><span class="line"></span><br><span class="line">      // &quot;noEmit&quot;: true,            // 不输出文件</span><br><span class="line">      // &quot;noEmitOnError&quot;: true,     // 发生错误时不输出文件</span><br><span class="line"></span><br><span class="line">      // &quot;noEmitHelpers&quot;: true,     // 不生成 helper 函数，需额外安装 ts-helpers</span><br><span class="line">      // &quot;importHelpers&quot;: true,     // 通过 tslib 引入 helper 函数，文件必须是模块</span><br><span class="line"></span><br><span class="line">      // &quot;downlevelIteration&quot;: true,    // 降级遍历器的实现（es3/5）</span><br><span class="line"></span><br><span class="line">      // &quot;strict&quot;: true,                        // 开启所有严格的类型检查</span><br><span class="line">      // &quot;alwaysStrict&quot;: false,                 // 在代码中注入 &quot;use strict&quot;;</span><br><span class="line">      // &quot;noImplicitAny&quot;: false,                // 不允许隐式的 any 类型</span><br><span class="line">      // &quot;strictNullChecks&quot;: false,             // 不允许把 null、undefined 赋值给其他类型变量</span><br><span class="line">      // &quot;strictFunctionTypes&quot;: false           // 不允许函数参数双向协变</span><br><span class="line">      // &quot;strictPropertyInitialization&quot;: false, // 类的实例属性必须初始化</span><br><span class="line">      // &quot;strictBindCallApply&quot;: false,          // 严格的 bind/call/apply 检查</span><br><span class="line">      // &quot;noImplicitThis&quot;: false,               // 不允许 this 有隐式的 any 类型</span><br><span class="line"></span><br><span class="line">      // &quot;noUnusedLocals&quot;: true,                // 检查只声明，未使用的局部变量</span><br><span class="line">      // &quot;noUnusedParameters&quot;: true,            // 检查未使用的函数参数</span><br><span class="line">      // &quot;noFallthroughCasesInSwitch&quot;: true,    // 防止 switch 语句贯穿</span><br><span class="line">      // &quot;noImplicitReturns&quot;: true,             // 每个分支都要有返回值</span><br><span class="line"></span><br><span class="line">      // &quot;esModuleInterop&quot;: true,               // 允许 export = 导出，由import from 导入</span><br><span class="line">      // &quot;allowUmdGlobalAccess&quot;: true,          // 允许在模块中访问 UMD 全局变量</span><br><span class="line">      // &quot;moduleResolution&quot;: &quot;node&quot;,            // 模块解析策略</span><br><span class="line">      // &quot;baseUrl&quot;: &quot;./&quot;,                       // 解析非相对模块的基地址</span><br><span class="line">      // &quot;paths&quot;: &#123;                             // 路径映射，相对于 baseUrl</span><br><span class="line">      //   &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;]</span><br><span class="line">      // &#125;,</span><br><span class="line">      // &quot;rootDirs&quot;: [&quot;src&quot;, &quot;out&quot;],            // 将多个目录放在一个虚拟目录下，用于运行时</span><br><span class="line"></span><br><span class="line">      // &quot;listEmittedFiles&quot;: true,        // 打印输出的文件</span><br><span class="line">      // &quot;listFiles&quot;: true,               // 打印编译的文件（包括引用的声明文件）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以把公共的抽离出来</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// tsconfig.base.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;files&quot; : [&#x27;src/index.ts&#x27;], // 编译的文件列表</span><br><span class="line">  &quot;include&quot;: [&#x27;src&#x27;], // 指定编译文件</span><br><span class="line">  &quot;exclude&quot;: [&#x27;src/lib&#x27;], // 排除编译文件</span><br><span class="line">&#125;</span><br><span class="line">&quot;extends&quot;: &#x27;./tsconfig.base&#x27;,</span><br><span class="line">&quot;exclude&quot;: [] // 覆盖之前的</span><br></pre></td></tr></table></figure>

<h3 id="4-2-工程引用配置多个项目"><a href="#4-2-工程引用配置多个项目" class="headerlink" title="4.2 工程引用配置多个项目"></a>4.2 工程引用配置多个项目</h3><blockquote>
<p>每个项目都有一份独立的<code>tsconfig.json</code>，继承一份公共的配置，最后可单独构建每个子项目工程</p>
</blockquote>
<blockquote>
<p>参考学习<code>typescript</code>项目 <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/tree/master/src">https://github.com/microsoft/TypeScript/tree/master/src</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 示例 项目入口</span><br><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">    &quot;strict&quot;: true,</span><br><span class="line">    &quot;composite&quot;: true,</span><br><span class="line">    &quot;declaration&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子工程1</span><br><span class="line">// src/client/tsconfig.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: &quot;../../tsconfig.json&quot;, //继承基础配置</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;../../dist/client&quot;, // 输出文件</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;references&quot;: [</span><br><span class="line">        &#123; &quot;path&quot;: &quot;../common&quot; &#125; // 依赖文件</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">// 子工程2</span><br><span class="line">// src/server/tsconfig.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: &quot;../../tsconfig.json&quot;,</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;../../dist/server&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;references&quot;: [</span><br><span class="line">        &#123; &quot;path&quot;: &quot;../common&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、编译工具ts-loader、ts-lint"><a href="#五、编译工具ts-loader、ts-lint" class="headerlink" title="五、编译工具ts-loader、ts-lint"></a>五、编译工具ts-loader、ts-lint</h2><p><strong>如何选择Typescript编译器</strong></p>
<blockquote>
<ul>
<li>如果没有使用过<code>babel</code>，首选<code>Typescript</code>自身编译器(可配合<code>Ts-loader</code>使用)</li>
<li>如果项目中已经使用<code>babel</code>，安装<code>@babel/preset-typescript</code>(可配合tsc做类型检查)</li>
<li>两种编译工具不要混用</li>
</ul>
</blockquote>
<p><strong>typescript-eslint与babel-eslint区别</strong></p>
<blockquote>
<ul>
<li><code>babel-eslint</code>支持<code>typescript</code>没有额外的语法检查，抛弃<code>typescript</code>,不支持类型检查</li>
<li><code>typescript-eslint</code>基础typescript的AST,基于创建基于类型信息的规则（<code>tsconfig.json</code>）</li>
</ul>
</blockquote>
<ul>
<li>两者底层机制不一样，不要一起使用</li>
<li><code>babel</code>体系建议使用<code>babel-eslint</code>，否则使用<code>typescript-eslint</code></li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>编译工具<ul>
<li><code>ts-loader</code></li>
<li><code>@babel/preset-typescript</code></li>
</ul>
</li>
<li>代码检查工具<ul>
<li><code>babel-eslint</code></li>
<li><code>typescript-eslint</code></li>
</ul>
</li>
</ul>
<h2 id="六、使用jest进行单元测试"><a href="#六、使用jest进行单元测试" class="headerlink" title="六、使用jest进行单元测试"></a>六、使用jest进行单元测试</h2><ul>
<li>单元测试工具<ul>
<li><code>ts-jest</code> – 能够在测试用例中进行类型检查</li>
<li><code>babel-jest</code> – 没有进行类型检查</li>
</ul>
</li>
</ul>
<blockquote>
<p>生成配置文件 <code>ts-jest config:init</code></p>
</blockquote>
<h1 id="第三章-项目实战"><a href="#第三章-项目实战" class="headerlink" title="第三章 项目实战"></a>第三章 项目实战</h1><h2 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、思维导图</h2><p><img src="https://poetries1.gitee.io/img-repo/20190903/1.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/2.png" alt="img"></p>
<h2 id="二、React项目实践"><a href="#二、React项目实践" class="headerlink" title="二、React项目实践"></a>二、React项目实践</h2><h3 id="2-1-手动创建react项目"><a href="#2-1-手动创建react项目" class="headerlink" title="2.1 手动创建react项目"></a>2.1 手动创建react项目</h3><blockquote>
<p>项目代码 <a target="_blank" rel="noopener" href="https://github.com/poetries/typescript-in-action/tree/master/ts-react">https://github.com/poetries/typescript-in-action/tree/master/ts-react</a></p>
</blockquote>
<p><strong>1. 安装依赖文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @types/react @types/react-dom</span><br></pre></td></tr></table></figure>

<p><strong>2. 修改tsconfig.json</strong>配置</p>
<blockquote>
<p>修改 <code>compilerOptions</code>中的<code>jsx</code>为<code>react</code></p>
</blockquote>
<h3 id="2-2-使用脚手架安装"><a href="#2-2-使用脚手架安装" class="headerlink" title="2.2 使用脚手架安装"></a>2.2 使用脚手架安装</h3><blockquote>
<p>项目代码 <a target="_blank" rel="noopener" href="https://github.com/poetries/typescript-in-action/tree/master/ts-react-app">https://github.com/poetries/typescript-in-action/tree/master/ts-react-app</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app ts-react-app --typescript</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-函数组件"><a href="#2-2-1-函数组件" class="headerlink" title="2.2.1 函数组件"></a>2.2.1 函数组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; Button &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    firstName: string;</span><br><span class="line">    lastName: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Hello = (props: Greeting) =&gt; &lt;Button&gt;Hello &#123;props.name&#125;&lt;/Button&gt;</span><br><span class="line"></span><br><span class="line">// const Hello: React.FC&lt;Greeting&gt; = (&#123;</span><br><span class="line">//     name,</span><br><span class="line">//     firstName,</span><br><span class="line">//     lastName,</span><br><span class="line">//     children</span><br><span class="line">// &#125;) =&gt; &lt;Button&gt;Hello &#123;name&#125;&lt;/Button&gt;</span><br><span class="line"></span><br><span class="line">Hello.defaultProps = &#123;</span><br><span class="line">    firstName: &#x27;&#x27;,</span><br><span class="line">    lastName: &#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Hello;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-类组件"><a href="#2-2-2-类组件" class="headerlink" title="2.2.2 类组件"></a>2.2.2 类组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Button &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    firstName?: string;</span><br><span class="line">    lastName?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface HelloState &#123;</span><br><span class="line">    count: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloClass extends Component&lt;Greeting, HelloState&gt; &#123;</span><br><span class="line">    state: HelloState = &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;</span><br><span class="line">    static defaultProps = &#123;</span><br><span class="line">        firstName: &#x27;&#x27;,</span><br><span class="line">        lastName: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;p&gt;你点击了 &#123;this.state.count&#125; 次&lt;/p&gt;</span><br><span class="line">                &lt;Button onClick=&#123;() =&gt; &#123;this.setState(&#123;count: this.state.count + 1&#125;)&#125;&#125;&gt;</span><br><span class="line">                    Hello &#123;this.props.name&#125;</span><br><span class="line">                &lt;/Button&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default HelloClass;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-高阶组件"><a href="#2-2-3-高阶组件" class="headerlink" title="2.2.3 高阶组件"></a>2.2.3 高阶组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">import HelloClass from &#x27;./HelloClass&#x27;;</span><br><span class="line"></span><br><span class="line">interface Loading &#123;</span><br><span class="line">    loading: boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function HelloHOC&lt;P&gt;(WrappedComponent: React.ComponentType&lt;P&gt;) &#123;</span><br><span class="line">    return class extends Component&lt;P &amp; Loading&gt; &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            const &#123; loading, ...props &#125; = this.props;</span><br><span class="line">            return loading ? &lt;div&gt;Loading...&lt;/div&gt; : &lt;WrappedComponent &#123; ...props as P &#125; /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default HelloHOC(HelloClass);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-Hooks组件"><a href="#2-2-4-Hooks组件" class="headerlink" title="2.2.4 Hooks组件"></a>2.2.4 Hooks组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Button &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    firstName: string;</span><br><span class="line">    lastName: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const HelloHooks = (props: Greeting) =&gt; &#123;</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    const [text, setText] = useState&lt;string | null&gt;(null);</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        if (count &gt; 5) &#123;</span><br><span class="line">            setText(&#x27;休息一下&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [count]);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;p&gt;你点击了 &#123;count&#125; 次 &#123;text&#125;&lt;/p&gt;</span><br><span class="line">            &lt;Button onClick=&#123;() =&gt; &#123;setCount(count + 1)&#125;&#125;&gt;</span><br><span class="line">                Hello &#123;props.name&#125;</span><br><span class="line">            &lt;/Button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloHooks.defaultProps = &#123;</span><br><span class="line">    firstName: &#x27;&#x27;,</span><br><span class="line">    lastName: &#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default HelloHooks;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-事件处理与数据请求"><a href="#2-2-5-事件处理与数据请求" class="headerlink" title="2.2.5 事件处理与数据请求"></a>2.2.5 事件处理与数据请求</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Form, Input, Select, Button &#125; from &#x27;antd&#x27;;</span><br><span class="line">import &#123; FormComponentProps &#125; from &#x27;antd/lib/form&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123; get &#125; from &#x27;../../utils/request&#x27;;</span><br><span class="line">import &#123; GET_EMPLOYEE_URL &#125; from &#x27;../../constants/urls&#x27;;</span><br><span class="line">import &#123; EmployeeRequest, EmployeeResponse &#125; from &#x27;../../interface/employee&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Option &#125; = Select;</span><br><span class="line"></span><br><span class="line">interface Props extends FormComponentProps &#123;</span><br><span class="line">    onDataChange(data: EmployeeResponse): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Hooks version</span><br><span class="line">// const QueryFormHooks = (props: Props) =&gt; &#123;</span><br><span class="line">//     const [name, setName] = useState(&#x27;&#x27;);</span><br><span class="line">//     const [departmentId, setDepartmentId] = useState&lt;number | undefined&gt;();</span><br><span class="line"></span><br><span class="line">//     const handleNameChange = (e: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">//         setName(e.currentTarget.value)</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     const handleDepartmentChange = (value: number) =&gt; &#123;</span><br><span class="line">//         setDepartmentId(value)</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     const handleSubmit = () =&gt; &#123;</span><br><span class="line">//         queryEmployee(&#123;name, departmentId&#125;);</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     const queryEmployee = (param: EmployeeRequest) =&gt; &#123;</span><br><span class="line">//         get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">//             props.onDataChange(res.data);</span><br><span class="line">//         &#125;);</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     useEffect(() =&gt; &#123;</span><br><span class="line">//         queryEmployee(&#123;name, departmentId&#125;);</span><br><span class="line">//     &#125;, [])</span><br><span class="line"></span><br><span class="line">//     return (</span><br><span class="line">//         &lt;&gt;</span><br><span class="line">//             &lt;Form layout=&quot;inline&quot;&gt;</span><br><span class="line">//                 &lt;Form.Item&gt;</span><br><span class="line">//                     &lt;Input</span><br><span class="line">//                         placeholder=&quot;姓名&quot;</span><br><span class="line">//                         style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">//                         allowClear</span><br><span class="line">//                         value=&#123;name&#125;</span><br><span class="line">//                         onChange=&#123;handleNameChange&#125;</span><br><span class="line">//                     /&gt;</span><br><span class="line">//                 &lt;/Form.Item&gt;</span><br><span class="line">//                 &lt;Form.Item&gt;</span><br><span class="line">//                 &lt;Select</span><br><span class="line">//                     placeholder=&quot;部门&quot;</span><br><span class="line">//                     style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">//                     allowClear</span><br><span class="line">//                     value=&#123;departmentId&#125;</span><br><span class="line">//                     onChange=&#123;handleDepartmentChange&#125;</span><br><span class="line">//                 &gt;</span><br><span class="line">//                     &lt;Option value=&#123;1&#125;&gt;技术部&lt;/Option&gt;</span><br><span class="line">//                     &lt;Option value=&#123;2&#125;&gt;产品部&lt;/Option&gt;</span><br><span class="line">//                     &lt;Option value=&#123;3&#125;&gt;市场部&lt;/Option&gt;</span><br><span class="line">//                     &lt;Option value=&#123;4&#125;&gt;运营部&lt;/Option&gt;</span><br><span class="line">//                 &lt;/Select&gt;</span><br><span class="line">//                 &lt;/Form.Item&gt;</span><br><span class="line">//                 &lt;Form.Item&gt;</span><br><span class="line">//                     &lt;Button type=&quot;primary&quot; onClick=&#123;handleSubmit&#125;&gt;查询&lt;/Button&gt;</span><br><span class="line">//                 &lt;/Form.Item&gt;</span><br><span class="line">//             &lt;/Form&gt;</span><br><span class="line">//         &lt;/&gt;</span><br><span class="line">//     )</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">class QueryForm extends Component&lt;Props, EmployeeRequest&gt; &#123;</span><br><span class="line">    state: EmployeeRequest = &#123;</span><br><span class="line">        name: &#x27;&#x27;,</span><br><span class="line">        departmentId: undefined</span><br><span class="line">    &#125;</span><br><span class="line">    handleNameChange = (e: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            name: e.currentTarget.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    handleDepartmentChange = (value: number) =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            departmentId: value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    handleSubmit = () =&gt; &#123;</span><br><span class="line">        this.queryEmployee(this.state);</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this.queryEmployee(this.state);</span><br><span class="line">    &#125;</span><br><span class="line">    queryEmployee(param: EmployeeRequest) &#123;</span><br><span class="line">        get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            this.props.onDataChange(res.data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Form layout=&quot;inline&quot;&gt;</span><br><span class="line">                &lt;Form.Item&gt;</span><br><span class="line">                    &lt;Input</span><br><span class="line">                        placeholder=&quot;姓名&quot;</span><br><span class="line">                        style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">                        allowClear</span><br><span class="line">                        value=&#123;this.state.name&#125;</span><br><span class="line">                        onChange=&#123;this.handleNameChange&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                &lt;/Form.Item&gt;</span><br><span class="line">                &lt;Form.Item&gt;</span><br><span class="line">                &lt;Select</span><br><span class="line">                    placeholder=&quot;部门&quot;</span><br><span class="line">                    style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">                    allowClear</span><br><span class="line">                    value=&#123;this.state.departmentId&#125;</span><br><span class="line">                    onChange=&#123;this.handleDepartmentChange&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;Option value=&#123;1&#125;&gt;技术部&lt;/Option&gt;</span><br><span class="line">                    &lt;Option value=&#123;2&#125;&gt;产品部&lt;/Option&gt;</span><br><span class="line">                    &lt;Option value=&#123;3&#125;&gt;市场部&lt;/Option&gt;</span><br><span class="line">                    &lt;Option value=&#123;4&#125;&gt;运营部&lt;/Option&gt;</span><br><span class="line">                &lt;/Select&gt;</span><br><span class="line">                &lt;/Form.Item&gt;</span><br><span class="line">                &lt;Form.Item&gt;</span><br><span class="line">                    &lt;Button type=&quot;primary&quot; onClick=&#123;this.handleSubmit&#125;&gt;查询&lt;/Button&gt;</span><br><span class="line">                &lt;/Form.Item&gt;</span><br><span class="line">            &lt;/Form&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const WrapQueryForm = Form.create&lt;Props&gt;(&#123;</span><br><span class="line">    name: &#x27;employee_query&#x27;</span><br><span class="line">&#125;)(QueryForm);</span><br><span class="line"></span><br><span class="line">export default WrapQueryForm;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-6-列表渲染"><a href="#2-2-6-列表渲染" class="headerlink" title="2.2.6 列表渲染"></a>2.2.6 列表渲染</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Table &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;./index.css&#x27;;</span><br><span class="line"></span><br><span class="line">import QueryForm from &#x27;./QueryForm&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123; employeeColumns &#125; from &#x27;./colums&#x27;;</span><br><span class="line">import &#123; EmployeeResponse &#125; from &#x27;../../interface/employee&#x27;;</span><br><span class="line"></span><br><span class="line">// Hooks version</span><br><span class="line">// const Employee = () =&gt; &#123;</span><br><span class="line">//     const [employee, setEmployee] = useState&lt;EmployeeResponse&gt;(undefined);</span><br><span class="line"></span><br><span class="line">//     const getTotal = () =&gt; &#123;</span><br><span class="line">//         let total: number;</span><br><span class="line">//         if (typeof employee !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">//             total = employee.length</span><br><span class="line">//         &#125; else &#123;</span><br><span class="line">//             total = 0</span><br><span class="line">//         &#125;</span><br><span class="line">//         return &lt;p&gt;共 &#123;total&#125; 名员工&lt;/p&gt;</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     return (</span><br><span class="line">//         &lt;&gt;</span><br><span class="line">//             &lt;QueryForm onDataChange=&#123;setEmployee&#125; /&gt;</span><br><span class="line">//             &#123;/* &#123;getTotal()&#125; */&#125;</span><br><span class="line">//             &lt;Table columns=&#123;employeeColumns&#125; dataSource=&#123;employee&#125; className=&quot;table&quot; /&gt;</span><br><span class="line">//         &lt;/&gt;</span><br><span class="line">//     )</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">interface State &#123;</span><br><span class="line">    employee: EmployeeResponse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Component&lt;&#123;&#125;, State&gt; &#123;</span><br><span class="line">    state: State = &#123;</span><br><span class="line">        employee: undefined</span><br><span class="line">    &#125;</span><br><span class="line">    setEmployee = (employee: EmployeeResponse) =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            employee</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    getTotal() &#123;</span><br><span class="line">        let total: number;</span><br><span class="line">        // 类型保护</span><br><span class="line">        if (typeof this.state.employee !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">            total = this.state.employee.length</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            total = 0</span><br><span class="line">        &#125;</span><br><span class="line">        return &lt;p&gt;共 &#123;total&#125; 名员工&lt;/p&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;QueryForm onDataChange=&#123;this.setEmployee&#125; /&gt;</span><br><span class="line">                &#123;/* &#123;this.getTotal()&#125; */&#125;</span><br><span class="line">                &lt;Table columns=&#123;employeeColumns&#125; dataSource=&#123;this.state.employee&#125; className=&quot;table&quot; /&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Employee;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-7-Redux与类型"><a href="#2-2-7-Redux与类型" class="headerlink" title="2.2.7 Redux与类型"></a>2.2.7 Redux与类型</h4><blockquote>
<p>项目代码 <a target="_blank" rel="noopener" href="https://github.com/poetries/typescript-in-action/tree/master/ts-redux">https://github.com/poetries/typescript-in-action/tree/master/ts-redux</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Dispatch &#125; from &#x27;redux&#x27;;</span><br><span class="line">import _ from &#x27;lodash&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123; get, post &#125; from &#x27;../../utils/request&#x27;;</span><br><span class="line">import &#123; department, level &#125; from &#x27;../../constants/options&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">    GET_EMPLOYEE_URL,</span><br><span class="line">    CREATE_EMPLOYEE_URL,</span><br><span class="line">    DELETE_EMPLOYEE_URL,</span><br><span class="line">    UPDATE_EMPLOYEE_URL</span><br><span class="line">&#125; from &#x27;../../constants/urls&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">    GET_EMPLOYEE,</span><br><span class="line">    CREATE_EMPLOYEE,</span><br><span class="line">    DELETE_EMPLOYEE,</span><br><span class="line">    UPDATE_EMPLOYEE</span><br><span class="line">&#125; from &#x27;../../constants/actions&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">    EmployeeInfo,</span><br><span class="line">    EmployeeRequest,</span><br><span class="line">    EmployeeResponse,</span><br><span class="line">    CreateRequest,</span><br><span class="line">    DeleteRequest,</span><br><span class="line">    UpdateRequest</span><br><span class="line">&#125; from &#x27;../../interface/employee&#x27;;</span><br><span class="line"></span><br><span class="line">type State = Readonly&lt;&#123;</span><br><span class="line">    employeeList: EmployeeResponse</span><br><span class="line">&#125;&gt;</span><br><span class="line"></span><br><span class="line">type Action = &#123;</span><br><span class="line">    type: string;</span><br><span class="line">    payload: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const initialState: State = &#123;</span><br><span class="line">    employeeList: undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function getEmployee(param: EmployeeRequest, callback: () =&gt; void) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: GET_EMPLOYEE,</span><br><span class="line">                payload: res.data</span><br><span class="line">            &#125;);</span><br><span class="line">            callback();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function createEmployee(param: CreateRequest, callback: () =&gt; void) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        post(CREATE_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: CREATE_EMPLOYEE,</span><br><span class="line">                payload: &#123;</span><br><span class="line">                    name: param.name,</span><br><span class="line">                    department: department[param.departmentId],</span><br><span class="line">                    departmentId: param.departmentId,</span><br><span class="line">                    hiredate: param.hiredate,</span><br><span class="line">                    level: level[param.levelId],</span><br><span class="line">                    levelId: param.levelId,</span><br><span class="line">                    ...res.data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            callback();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function deleteEmployee(param: DeleteRequest) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        post(DELETE_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: DELETE_EMPLOYEE,</span><br><span class="line">                payload: param.id</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function updateEmployee(param: UpdateRequest, callback: () =&gt; void) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        post(UPDATE_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: UPDATE_EMPLOYEE,</span><br><span class="line">                payload: param</span><br><span class="line">            &#125;);</span><br><span class="line">            callback();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function(state = initialState, action: Action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case GET_EMPLOYEE:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: action.payload</span><br><span class="line">            &#125;</span><br><span class="line">        case CREATE_EMPLOYEE:</span><br><span class="line">            let newList = [action.payload, ...(state.employeeList as EmployeeInfo[])]</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: newList</span><br><span class="line">            &#125;</span><br><span class="line">        case DELETE_EMPLOYEE:</span><br><span class="line">            let reducedList = [...(state.employeeList as EmployeeInfo[])];</span><br><span class="line">            _.remove(reducedList, (item: EmployeeInfo) =&gt; &#123;</span><br><span class="line">                return item.id === action.payload</span><br><span class="line">            &#125;);</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: reducedList</span><br><span class="line">            &#125;</span><br><span class="line">        case UPDATE_EMPLOYEE:</span><br><span class="line">            let updatedList = [...(state.employeeList as EmployeeInfo[])];</span><br><span class="line">            let item: UpdateRequest = action.payload;</span><br><span class="line">            let index = _.findIndex(updatedList, &#123;</span><br><span class="line">                id: item.id</span><br><span class="line">            &#125;);</span><br><span class="line">            updatedList[index] = &#123;</span><br><span class="line">                id: item.id,</span><br><span class="line">                key: item.id,</span><br><span class="line">                name: item.name,</span><br><span class="line">                department: department[item.departmentId],</span><br><span class="line">                departmentId: item.departmentId,</span><br><span class="line">                hiredate: item.hiredate,</span><br><span class="line">                level: level[item.levelId],</span><br><span class="line">                levelId: item.levelId</span><br><span class="line">            &#125;</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: updatedList</span><br><span class="line">            &#125;</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-服务端使用Typescript"><a href="#2-3-服务端使用Typescript" class="headerlink" title="2.3 服务端使用Typescript"></a>2.3 服务端使用Typescript</h3><blockquote>
<p>项目地址 <a target="_blank" rel="noopener" href="https://github.com/poetries/typescript-in-action/tree/master/ts-express">https://github.com/poetries/typescript-in-action/tree/master/ts-express</a></p>
</blockquote>
<h2 id="三、Vue项目实践"><a href="#三、Vue项目实践" class="headerlink" title="三、Vue项目实践"></a>三、Vue项目实践</h2><blockquote>
<p>项目代码 <a target="_blank" rel="noopener" href="https://github.com/poetries/typescript-in-action/tree/master/ts-vue">https://github.com/poetries/typescript-in-action/tree/master/ts-vue</a></p>
</blockquote>
<blockquote>
<p>TS不能识别<code>.vue</code>文件，需要声明文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// vue-shims.d.ts</span><br><span class="line"></span><br><span class="line">declare module &#x27;*.vue&#x27; &#123;</span><br><span class="line">    import Vue from &#x27;vue&#x27;</span><br><span class="line">    export default Vue</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/poetries/poetries.github.io/edit/dev/source/_posts/ts-in-action.md">原文地址</a></p>
</blockquote>
<h1 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://blog.poetries.top/ts-axios/chapter1/">TypeScript 从零实现 axios</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.poetries.top/2018/12/29/ts-intro-and-use-in-react/">Typescript基础及结合React实践(一)</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.poetries.top/2018/12/30/ts-summary/">Typescript总结篇（二）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.poetries.top/2018/12/31/ts-react-template/">Typescript+React模板搭建（三）</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/15/html+css+js+ts/5-Typescript%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93[%E5%9F%BA%E7%A1%80+%E5%B7%A5%E7%A8%8B+%E5%AE%9E%E8%B7%B5]/" data-id="cl7ibzole008iugunbj516y9p" data-title="Typescript实践总结[基础+工程+实践]" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/5-Typescript基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/03/html+css+js+ts/5-Typescript%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-08-03T13:18:43.000Z" itemprop="datePublished">2021-08-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/03/html+css+js+ts/5-Typescript%E5%9F%BA%E7%A1%80/">Typescript基础总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、typescript-安装"><a href="#一、typescript-安装" class="headerlink" title="一、typescript 安装"></a>一、typescript 安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局安装完成后，我们新建一个<code>hello.ts</code>的<code>ts</code>文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.ts内容</span><br><span class="line">let a = &quot;poet&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来我们在命令行输入<code>tsc hello.ts</code>来编译这个<code>ts</code>文件，然后会在同级目录生成一个编译好了的<code>hello.js</code>文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.js内容</span><br><span class="line">var = &quot;poet&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么我们每次都要输<code>tsc hello.ts</code>命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，使用<code>vscode</code>来开发，需要配置一下<code>vscode</code>就可以。</p>
</blockquote>
<blockquote>
<p>首先我们在命令行执行<code>tsc --init</code>来生成配置文件，然后我们在目录下看到生成了一个<code>tsconfig.json</code>文件</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/545.png" alt="img"></p>
<blockquote>
<p>这个<code>json</code>文件里有很多选项</p>
</blockquote>
<ul>
<li><code>target</code>是选择编译到什么语法</li>
<li><code>module</code>则是模块类型</li>
<li><code>outDir</code>则是输出目录，可以指定这个参数到指定目录</li>
</ul>
<blockquote>
<p>更多细节 <a target="_blank" rel="noopener" href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html</a></p>
</blockquote>
<blockquote>
<p>接下来我们需要开启监控了，在<code>vscode</code>任务栏中</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/546.png" alt="img"></p>
<p><strong>Typescript在线编辑器</strong></p>
<blockquote>
<p>建议使用在线编辑器练习 <a target="_blank" rel="noopener" href="http://www.typescriptlang.org/play/index.html">http://www.typescriptlang.org/play/index.html</a></p>
</blockquote>
<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><blockquote>
<p><code>js</code>是弱类型语言，强弱类语言有什么区别呢？<code>typescript</code>最大的优点就是类型检查，可以帮你检查你定义的类型和赋值的类型。</p>
</blockquote>
<h3 id="2-1-布尔类型boolean"><a href="#2-1-布尔类型boolean" class="headerlink" title="2.1 布尔类型boolean"></a>2.1 布尔类型boolean</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 在js中，定义isFlag为true，为布尔类型boolean</span><br><span class="line">let isFlag = true;</span><br><span class="line">// 但是我们也可以重新给它赋值为字符串</span><br><span class="line">isFlag = &quot;hello swr&quot;;</span><br><span class="line"></span><br><span class="line">// 在ts中，定义isFlag为true，为布尔类型boolean</span><br><span class="line">// 在变量名后加冒号和类型，如  :boolean</span><br><span class="line">let isFlag:boolean = true</span><br><span class="line">// 重新赋值到字符串类型会报错</span><br><span class="line">isFlag = &quot;hello swr&quot; </span><br><span class="line"></span><br><span class="line">// 在java中，一般是这样定义，要写变量名也要写类型名</span><br><span class="line">// int a = 10; </span><br><span class="line">// string name = &quot;poetries&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-数字类型number"><a href="#2-2-数字类型number" class="headerlink" title="2.2 数字类型number"></a>2.2 数字类型number</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let age:number = 28;</span><br><span class="line">age = 29;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-字符串类型string"><a href="#2-3-字符串类型string" class="headerlink" title="2.3 字符串类型string"></a>2.3 字符串类型string</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name:string = &quot;poetries&quot;</span><br><span class="line">name = &quot;iamswr&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上<code>boolean</code>、<code>number</code>、<code>string</code>类型有个共性，就是可以通过<code>typeof</code>来获取到是什么类型，是基本数据类型</p>
</blockquote>
<p>那么复杂的数据类型是怎么处理的呢？</p>
<h3 id="2-4-数组-Array"><a href="#2-4-数组-Array" class="headerlink" title="2.4 数组 Array"></a>2.4 数组 Array</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 数组</span><br><span class="line">// 这是一个字符串数组，只能往里面放字符串，写别的类型会报错</span><br><span class="line">let persion:string[] = [&#x27;poetries&#x27;, &#x27;jing&#x27;]</span><br><span class="line">// 另一个写法 </span><br><span class="line">let persions:Array&lt;string&gt; = [&#x27;poetries&#x27;, &#x27;jing&#x27;]</span><br><span class="line"></span><br><span class="line">// 如果数组里放对象呢</span><br><span class="line">let persionObject:Array&lt;object&gt; = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]</span><br><span class="line">let persionObjects:object[] = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]</span><br><span class="line"></span><br><span class="line">// 在数组中放string、number、boolean、object</span><br><span class="line">let arr:Array&lt;number|object|string|boolean&gt; = [22, &#x27;test&#x27;, true, &#123;name:&#x27;poetries&#x27;&#125;]</span><br><span class="line"></span><br><span class="line">// 数组中放什么都可以</span><br><span class="line">let arrAny:Array&lt;any&gt; = [&#x27;test&#x27;,12,false]</span><br></pre></td></tr></table></figure>

<h3 id="2-5-元组类型tuple"><a href="#2-5-元组类型tuple" class="headerlink" title="2.5 元组类型tuple"></a>2.5 元组类型tuple</h3><ul>
<li>什么是元组类型？其实元组是数组的一种。</li>
<li>有点类似解构赋值，但是又不完全是解构赋值，比如元组类型必须一一对应上</li>
<li>元组类型是一个不可变的数组，长度、类型是不可变的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 元组类型tuple</span><br><span class="line">// 什么是元组类型？其实元组是数组的一种</span><br><span class="line">let per :[string,number,object] = [&#x27;poetries&#x27;,22,&#123;love: &#x27;coding&#x27;&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="2-6-枚举类型enum"><a href="#2-6-枚举类型enum" class="headerlink" title="2.6 枚举类型enum"></a>2.6 枚举类型enum</h3><blockquote>
<p>什么是枚举？枚举有点类似一一列举，一个一个数出来。一般用于值是某几个固定的值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 枚举类型enum</span><br><span class="line"></span><br><span class="line">enum sex &#123;</span><br><span class="line">    BOY=&#x27;男孩&#x27;,</span><br><span class="line">    GIRL=&#x27;女孩&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sex)</span><br><span class="line">// 转化为es5语法</span><br><span class="line">// 我们顺便看看实现的原理</span><br><span class="line"></span><br><span class="line">var sex;</span><br><span class="line">(function (sex) &#123;</span><br><span class="line">// 首先这里是一个自执行函数</span><br><span class="line">// 并且把sex定义为对象，传参进给自执行函数</span><br><span class="line">// 然后给sex对象添加属性并且赋值</span><br><span class="line">    sex[&quot;BOY&quot;] = &quot;\u7537\u5B69&quot;;</span><br><span class="line">    sex[&quot;GIRL&quot;] = &quot;\u5973\u5B69&quot;;</span><br><span class="line">&#125;)(sex || (sex = &#123;&#125;));</span><br><span class="line">console.log(sex);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>比如我们实际项目中，特别是商城类，订单会存在很多状态流转，那么非常适合用枚举</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum orderStatus &#123;</span><br><span class="line">    WAIT_FOR_PAY = &quot;待支付&quot;,</span><br><span class="line">    UNDELIVERED = &quot;完成支付，待发货&quot;,</span><br><span class="line">    DELIVERED = &quot;已发货&quot;,</span><br><span class="line">    COMPLETED = &quot;已确认收货&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这里，我们会有一个疑虑，为什么我们不这样写呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let orderStatus2 = &#123;</span><br><span class="line">    WAIT_FOR_PAY : &quot;待支付&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们直接写对象的键值对方式，是可以在外部修改这个值的，而我们通过<code>enum</code>则不能修改定义好的值了</p>
</blockquote>
<h3 id="2-7-任意类型-any"><a href="#2-7-任意类型-any" class="headerlink" title="2.7 任意类型 any"></a>2.7 任意类型 any</h3><blockquote>
<p><code>any</code>有好处也有坏处，特别是前端，很多时候写类型的时候，几乎分不清楚类型，任意去写，写起来很爽，但是对于后续的重构、迭代等是非常不友好的，会暴露出很多问题，某种程度来说，<code>any</code>类型就是放弃了类型检查了</p>
</blockquote>
<p>比如我们有这样一个场景，就是需要获取某一个dom节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">btn.style.color = &quot;blue&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时我们发现在<code>ts</code>中会报错</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/547.png" alt="img"></p>
<ul>
<li>因为我们取这个<code>dom</code>节点，有可能取到，也有可能没取到，当没取到的时候，相当于是<code>null</code>，是没有<code>style</code>这个属性的。</li>
<li>那么我们可以给它添加一个类型为<code>any</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 添加一个any类型，此时就不会报错了，但是也相当于放弃了类型检查了</span><br><span class="line">let btn:any = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">btn.style.color = &quot;blue&quot;;</span><br><span class="line">// 可以赋值任何类型的值</span><br><span class="line">// 跟以前我们var let声明的一模一样的</span><br><span class="line">let person:any = &quot;poetries&quot;</span><br><span class="line">person = 22</span><br></pre></td></tr></table></figure>

<h3 id="2-8-null-undefined类型"><a href="#2-8-null-undefined类型" class="headerlink" title="2.8 null undefined类型"></a>2.8 null undefined类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// (string | number | null | undefined) 相当于这几种类型</span><br><span class="line">// 是 string 或 number 或 null 或 undefined</span><br><span class="line"></span><br><span class="line">let str:(string | number | null | undefined)</span><br><span class="line"></span><br><span class="line">str = &#x27;poetries&#x27;</span><br><span class="line">str = 28</span><br><span class="line">str = null </span><br><span class="line">str = undefined</span><br></pre></td></tr></table></figure>

<h3 id="2-9-void类型"><a href="#2-9-void类型" class="headerlink" title="2.9 void类型"></a>2.9 void类型</h3><blockquote>
<p><code>void</code>表示没有任何类型，一般是定义函数没有返回值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// void 不能再函数里写return</span><br><span class="line">// 怎么理解叫没有返回值呢？此时我们给函数return一个值</span><br><span class="line">function say(name:string):void&#123;</span><br><span class="line">    console.log(&#x27;hello:&#x27;, name)</span><br><span class="line">    // return &quot;ok&quot; 会报错</span><br><span class="line">    return undefined;</span><br><span class="line">    return //不会报错</span><br><span class="line">&#125;</span><br><span class="line">say(&#x27;poetries&#x27;)</span><br><span class="line"></span><br><span class="line">// 返回一个字符串类型</span><br><span class="line">function say1(name:string):string &#123;</span><br><span class="line">    return &#x27;ok&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-10-never类型"><a href="#2-10-never类型" class="headerlink" title="2.10 never类型"></a>2.10 never类型</h3><blockquote>
<p>这个用得很少，一般是用于抛出异常</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function error(message:string):never &#123;</span><br><span class="line">    throw new Error(message)</span><br><span class="line">&#125;</span><br><span class="line">error(&#x27;errorMsg&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="2-11-我们要搞明白any、never、void"><a href="#2-11-我们要搞明白any、never、void" class="headerlink" title="2.11 我们要搞明白any、never、void"></a>2.11 我们要搞明白any、never、void</h3><ul>
<li><code>any</code>是任意的值</li>
<li><code>void</code>是不能有任何值</li>
<li><code>never</code>永远不会有返回值</li>
</ul>
<blockquote>
<p><code>any</code>比较好理解，就是任何值都可以</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str:any = &quot;hello poetries&quot;</span><br><span class="line">str = 28</span><br><span class="line">str = true</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>void</code>不能有任何值(返回值)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function say():void &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>never</code>则不好理解，什么叫永远不会有返回值？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 除了上面举例的抛出异常以外，我们看一下这个例子</span><br><span class="line">// 这个loop函数，一旦开始执行，就永远不会结束</span><br><span class="line">// 可以看出在while中，是死循环，永远都不会有返回值，包括undefined</span><br><span class="line"></span><br><span class="line">function loop():never &#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        console.log(&quot;陷入死循环啦&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop()</span><br><span class="line"></span><br><span class="line">// 包括比如JSON.parse也是使用这种 never | any</span><br><span class="line">function parse(str:string):(never | any)&#123;</span><br><span class="line">    return JSON.parse(str)</span><br><span class="line">&#125;</span><br><span class="line">// 首先在正常情况下，我们传一个JSON格式的字符串，是可以正常得到一个JSON对象的</span><br><span class="line">let json = parse(&#x27;&#123;&quot;name&quot;:&quot;poetries&quot;&#125;&#x27;)</span><br><span class="line">// 但是有时候，传进去的不一定是JSON格式的字符串，那么就会抛出异常</span><br><span class="line">// 此时就需要never了</span><br><span class="line">let json = parse(&quot;iamswr&quot;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也就是说，当一个函数执行的时候，被抛出异常打断了，导致没有返回值或者该函数是一个死循环，永远没有返回值，这样叫做永远不会有返回值。</p>
</blockquote>
<p>实际开发中，是<code>never</code>和联合类型来一起用，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function say():(never | string) &#123;</span><br><span class="line">  return &quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><h3 id="3-1-函数定义"><a href="#3-1-函数定义" class="headerlink" title="3.1 函数定义"></a>3.1 函数定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(name:string):void &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-函数参数处理"><a href="#3-2-函数参数处理" class="headerlink" title="3.2 函数参数处理"></a>3.2 函数参数处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数是这样定义的</span><br><span class="line">// 形参和实参一一对应，完全一样</span><br><span class="line">function sayHello(name:string,age:number):void &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;, name, age)</span><br><span class="line">&#125;</span><br><span class="line">sayHello(&#x27;poetries&#x27;,22)</span><br><span class="line"></span><br><span class="line">// 形参和实参要完全一样，如想不一样，则需要配置可选参数，可选参数放在后面</span><br><span class="line">// 可选参数，用 ？ 处理，只能放在后面</span><br><span class="line">function sayHelloToYou(name:string,age?:number):void &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;, name, age)</span><br><span class="line">&#125;</span><br><span class="line">sayHelloToYou(&#x27;poetries&#x27;)</span><br><span class="line"></span><br><span class="line">// 那么如何设置默认参数呢？</span><br><span class="line"></span><br><span class="line">function ajax(url:string,method:string = &#x27;GET&#x27;) &#123;</span><br><span class="line">    console.log(url, method)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 那么如何设置剩余参数呢？可以利用扩展运算符</span><br><span class="line"></span><br><span class="line">function sum(...args:Array&lt;number&gt;):number &#123;</span><br><span class="line">    return eval(args.join(&quot;+&quot;))</span><br><span class="line">&#125;</span><br><span class="line">let total:number = sum(1,2,3,4,5)</span><br><span class="line">console.log(total)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 那么如何实现函数重载呢？函数重载是java中非常有名的，在java中函数的重载，是指两个或者两个以上的同名函数，参数的个数和类型不一样</span><br><span class="line"></span><br><span class="line">// 比如我们现在有两个同名函数</span><br><span class="line">// function eating(name:string) &#123;</span><br><span class="line">    </span><br><span class="line">// &#125;</span><br><span class="line">// function eating(name:string,age:number) &#123;</span><br><span class="line">    </span><br><span class="line">// &#125;</span><br><span class="line">// 那么我想达到一个效果</span><br><span class="line">// 当我传参数name时，执行name:string这个函数</span><br><span class="line">// 当我传参数name和age时，执行name:string,age:number这个函数</span><br><span class="line">// 此时该怎么办？</span><br><span class="line"></span><br><span class="line">// 接下来看一下typescript中的函数重载</span><br><span class="line"></span><br><span class="line">// 首先声明两个函数名一样的函数</span><br><span class="line">function eating(name: string):void;</span><br><span class="line">function eating(name: number):void;</span><br><span class="line"></span><br><span class="line">function eating(name:any): void &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eating(&quot;hello poetries&quot;)</span><br><span class="line">eating(22)</span><br><span class="line"></span><br><span class="line">// 在typescript中主要体现是同一个同名函数提供多个函数类型定义，函数实际上就只有一个，就是拥有函数体那个，如果想根据传入值类型的不一样执行不同逻辑，则需要在这个函数里面进行一个类型判断。</span><br><span class="line"></span><br><span class="line">// 那么这个函数重载有什么作用呢？其实在ts中，函数重载只是用来限制参数的个数和类型，用来检查类型的，而且重载不能拆开几个函数，这一点和java的处理是不一样的，需要注意。</span><br></pre></td></tr></table></figure>

<h2 id="四、类"><a href="#四、类" class="headerlink" title="四、类"></a>四、类</h2><h3 id="4-1-定义一个类"><a href="#4-1-定义一个类" class="headerlink" title="4.1 定义一个类"></a>4.1 定义一个类</h3><blockquote>
<p>如何定义一个类？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// ts 写法</span><br><span class="line">// 跟es6非常像 没有太大区别</span><br><span class="line">class Persion &#123;</span><br><span class="line">    // 这里声明的变量 是实例上的属性</span><br><span class="line">    name: string;</span><br><span class="line">    age:number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        // this.name和this.age 必须先在前面声明好类型</span><br><span class="line">        // name: string</span><br><span class="line">        // age: number</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 原型方法</span><br><span class="line">    say():string &#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Persion(&#x27;poetries&#x27;, 22)</span><br><span class="line">// 那么转为es5呢？</span><br><span class="line"></span><br><span class="line">var Persion = /** @class */ (function () &#123;</span><br><span class="line">    function Persion(name, age) &#123;</span><br><span class="line">        // this.name和this.age 必须先在前面声明好类型</span><br><span class="line">        // name: string</span><br><span class="line">        // age: number</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 原型方法</span><br><span class="line">    Persion.prototype.say = function () &#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;;</span><br><span class="line">    &#125;;</span><br><span class="line">    return Persion;</span><br><span class="line">&#125;());</span><br><span class="line">var p = new Persion(&#x27;poetries&#x27;, 22);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-类的继承"><a href="#4-2-类的继承" class="headerlink" title="4.2 类的继承"></a>4.2 类的继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 和es6也是差不多</span><br><span class="line">class Parent &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    constructor(name:string, age: number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    say():string&#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    childName: string;</span><br><span class="line">    constructor(name: string,age:number,childName:string) &#123;</span><br><span class="line">        super(name,age)</span><br><span class="line">        this.childName = childName</span><br><span class="line">    &#125;</span><br><span class="line">    childSay():string &#123;</span><br><span class="line">        return this.childName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let child = new Child(&#x27;poetries&#x27;, 22, &#x27;静观流叶&#x27;)</span><br><span class="line">console.log(child)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-类的修饰符"><a href="#4-3-类的修饰符" class="headerlink" title="4.3 类的修饰符"></a>4.3 类的修饰符</h3><ul>
<li><code>public</code>公开的，可以供自己、子类以及其它类访问</li>
<li><code>protected</code>受保护的，可以供自己、子类访问，但是其他就访问不了</li>
<li><code>private</code>私有的，只有自己访问，而子类、其他都访问不了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Parents &#123;</span><br><span class="line">    public name:string;</span><br><span class="line">    protected age:number;</span><br><span class="line">    private money:number;</span><br><span class="line"></span><br><span class="line">   // 简写</span><br><span class="line">   // constructor(public name:string,protected age:number,private money:number)</span><br><span class="line"></span><br><span class="line">   constructor(name: string, age:number,money:number) &#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">       this.age = age;</span><br><span class="line">       this.money = money;</span><br><span class="line">   &#125;</span><br><span class="line">   getName():string &#123;</span><br><span class="line">       return this.name</span><br><span class="line">   &#125;</span><br><span class="line">   getAge():number&#123;</span><br><span class="line">       return this.age</span><br><span class="line">   &#125;</span><br><span class="line">   getMoney():number&#123;</span><br><span class="line">       return this.money</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">let pare = new Parents(&#x27;poetries&#x27;, 22, 3000)</span><br><span class="line">console.log(pare.name)</span><br><span class="line">// console.log(pare.age)  报错</span><br><span class="line">// console.log(pare.money) 报错</span><br></pre></td></tr></table></figure>

<h3 id="4-4-静态属性、静态方法"><a href="#4-4-静态属性、静态方法" class="headerlink" title="4.4 静态属性、静态方法"></a>4.4 静态属性、静态方法</h3><p>跟<code>es6</code>差不多</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person2 &#123;</span><br><span class="line">    // 类的静态属性</span><br><span class="line">    static name1 = &#x27;poetries&#x27;</span><br><span class="line"></span><br><span class="line">    // 类的静态方法</span><br><span class="line">    static say() &#123;</span><br><span class="line">        console.log(&#x27;hello poetries&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let per2 = new Person2()</span><br><span class="line">Person2.say() // hello poetries</span><br><span class="line">// per2.say() 报错</span><br></pre></td></tr></table></figure>

<h3 id="4-5-抽象类"><a href="#4-5-抽象类" class="headerlink" title="4.5 抽象类"></a>4.5 抽象类</h3><ul>
<li>抽象类和方法，有点类似抽取共性出来，但是又不是具体化，比如说，世界上的动物都需要吃东西，那么会把吃东西这个行为，抽象出来</li>
<li>如果子类继承的是一个抽象类，子类必须实现父类里的抽象方法，不然的话不能实例化，会报错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/ 关键字 abstract抽象</span><br><span class="line">// 定义抽象类</span><br><span class="line"></span><br><span class="line">abstract class Animal &#123;</span><br><span class="line">    // 实际上是使用了public修饰符</span><br><span class="line">    // 如果添加private修饰符会报错</span><br><span class="line">    abstract eat():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要注意的是这个Animal是不能实例化的</span><br><span class="line">// let animal = new Animal() // 报错</span><br><span class="line"></span><br><span class="line">// // 抽象类的抽象方法，意思就是，需要在继承这个抽象类的子类中</span><br><span class="line">// 实现这个抽象方法，不然会报错</span><br><span class="line">// 报错，因为在子类中没有实现eat抽象方法</span><br><span class="line">// class Person4 extends Animal&#123;</span><br><span class="line">//     test()&#123;</span><br><span class="line">//         console.log(&quot;吃米饭&quot;)</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// Dog类继承Animal类后并且实现了抽象方法eat，所以不会报错</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&quot;吃骨头&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、接口"><a href="#五、接口" class="headerlink" title="五、接口"></a>五、接口</h2><blockquote>
<p>这里的接口，主要是一种规范，规范某些类必须遵守规范，和抽象类有点类似，但是不局限于类，还有属性、函数等</p>
</blockquote>
<h3 id="5-1-接口规范对象"><a href="#5-1-接口规范对象" class="headerlink" title="5.1 接口规范对象"></a>5.1 接口规范对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//假设我们需要获取用户信息</span><br><span class="line">// 我们通过这样的方式 规范必须传name和age的值</span><br><span class="line">function getUserInfo(user:&#123;name:string,age:number&#125;) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo(&#123;name: &#x27;poetries&#x27;, age: 22&#125;)</span><br><span class="line"></span><br><span class="line">// 这样看挺完美的， 那么问题就出现了，如果我另外还有一个方法，也是需要这个规范呢？</span><br><span class="line"></span><br><span class="line">function getUserInfo1(user:&#123;name:string,age:number&#125;)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo(user:&#123;name:string,age:number&#125;)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo1(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line">getInfo(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line"></span><br><span class="line">// 可以看出，函数getUserInfo和getInfo都遵循同一个规范，那么我们有办法对这个规范复用吗？</span><br><span class="line"></span><br><span class="line">// 首先把需要复用的规范，写到接口 关键字interface</span><br><span class="line">interface infoInterface &#123;</span><br><span class="line">    name: string,</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">// 然后把这个接口 替换到我们需要复用的地方</span><br><span class="line">function getUserInfo2(user:infoInterface) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo2(user:infoInterface) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInfo2(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line">getInfo2(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line"></span><br><span class="line">// 那么有些参数可传可不传，该怎么处理呢？</span><br><span class="line"></span><br><span class="line">interface infoInterface2&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    city?:string;</span><br><span class="line">&#125;</span><br><span class="line">function getUserInfo3(user:infoInterface2)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125; $&#123;user.city&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo3(user:infoInterface)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo3(&#123;name:&quot;poetries&quot;,age:22,city:&quot;深圳&quot;&#125;)</span><br><span class="line">getInfo3(&#123;name:&quot;iamswr&quot;,age:22&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-接口规范函数"><a href="#5-2-接口规范函数" class="headerlink" title="5.2 接口规范函数"></a>5.2 接口规范函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 对一个函数的参数和返回值进行规范</span><br><span class="line">interface mytotal &#123;</span><br><span class="line">    // 左侧是函数的参数，右侧是函数的返回类型</span><br><span class="line">    (a:number,b:number):number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let totalSum:mytotal = function(a:number,b:number):number &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(totalSum(10, 20))</span><br></pre></td></tr></table></figure>

<h3 id="5-3-接口规范数组"><a href="#5-3-接口规范数组" class="headerlink" title="5.3 接口规范数组"></a>5.3 接口规范数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface userInterface &#123;</span><br><span class="line">    // index为数组索引 类型是number</span><br><span class="line">    // 右边是数组里为字符串的数组成员</span><br><span class="line">    [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line">let arrTest: userInterface = [&#x27;poetries&#x27;, &#x27;静观流叶&#x27;]</span><br><span class="line"></span><br><span class="line">console.log(arrTest)</span><br></pre></td></tr></table></figure>

<h3 id="5-4-接口规范类"><a href="#5-4-接口规范类" class="headerlink" title="5.4 接口规范类"></a>5.4 接口规范类</h3><blockquote>
<p>这个比较重要，因为写<code>react</code>的时候会经常使用到类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 首先实现一个接口</span><br><span class="line">interface Animal2 &#123;</span><br><span class="line">    // 这个类必须有name</span><br><span class="line">    name:string;</span><br><span class="line"></span><br><span class="line">    // 这个类必须有eat方法</span><br><span class="line">    eat(any:string):void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关键字implements实现</span><br><span class="line">// 因为接口是抽象的，需要通过子类是实现它</span><br><span class="line"></span><br><span class="line">class Person6 implements Animal2 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string):void &#123;</span><br><span class="line">        console.log(`吃`+any)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果想遵循多个接口</span><br><span class="line"></span><br><span class="line">interface Animal3 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    eat(any: string):void;</span><br><span class="line">&#125;</span><br><span class="line">// 新增一个接口</span><br><span class="line">interface Animal4 &#123;</span><br><span class="line">    sleep():void;</span><br><span class="line">&#125;</span><br><span class="line">// 可以在implements后面通过逗号添加和java一样</span><br><span class="line">class Person7 implements Animal3,Animal4 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string) &#123;</span><br><span class="line">        console.log(`吃`+any)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep() &#123;</span><br><span class="line">        console.log(&#x27;睡觉&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-接口继承接口"><a href="#5-5-接口继承接口" class="headerlink" title="5.5 接口继承接口"></a>5.5 接口继承接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface Animal5&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    eat(any:string):void;</span><br><span class="line">&#125;</span><br><span class="line">// 像类一样 通过extends继承</span><br><span class="line">interface Animal6 extends Animal5 &#123;</span><br><span class="line">    sleep():void;</span><br><span class="line">&#125;</span><br><span class="line">// 因为Animal6类继承了Animal5</span><br><span class="line">// 所以这里遵循Animal6就相当于把Animal5也继承了</span><br><span class="line"></span><br><span class="line">class Person8 implements Animal2 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name:string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string):void&#123;</span><br><span class="line">        console.log(`吃$&#123;any&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep()&#123;</span><br><span class="line">        console.log(&#x27;睡觉&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a>六、泛型</h2><h3 id="6-1-函数的泛型"><a href="#6-1-函数的泛型" class="headerlink" title="6.1 函数的泛型"></a>6.1 函数的泛型</h3><blockquote>
<p>泛型可以支持不特定的数据类型，什么叫不特定呢？比如我们有一个方法，里面接收参数，但是参数类型我们是不知道，但是这个类型在方法里面很多地方会用到，参数和返回值要保持一致性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 假设我们有一个需求，我们不知道函数接收什么类型的参数，也不知道返回值的类型</span><br><span class="line">// 而我们又需要传进去的参数类型和返回值的类型保持一致，那么我们就需要用到泛型</span><br><span class="line"></span><br><span class="line">// &lt;T&gt;的意思是泛型，即generic type</span><br><span class="line">// 可以看出value的类型也为T，返回值的类型也为T</span><br><span class="line">function deal&lt;T&gt;(value:T):T&#123;</span><br><span class="line">    return value</span><br><span class="line">&#125;</span><br><span class="line">// 下面的&lt;string&gt;、&lt;number&gt;实际上用的时候再传给上面的&lt;T&gt;</span><br><span class="line">console.log(deal&lt;string&gt;(&quot;poetries&quot;))</span><br><span class="line">console.log(deal&lt;number&gt;(22))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的</p>
</blockquote>
<h3 id="6-2-类的泛型"><a href="#6-2-类的泛型" class="headerlink" title="6.2 类的泛型"></a>6.2 类的泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyMath&lt;T&gt; &#123;</span><br><span class="line">    // 定义一个私有属性</span><br><span class="line"></span><br><span class="line">    private arr: T[] = []</span><br><span class="line"></span><br><span class="line">    // 规定传参类型</span><br><span class="line">    add(value: T) &#123;</span><br><span class="line">        this.arr.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这里规定了类型为number</span><br><span class="line">// 相当于把T替换为number</span><br><span class="line"></span><br><span class="line">let mymath = new MyMath&lt;number&gt;()</span><br><span class="line">mymath.add(1)</span><br><span class="line">mymath.add(2)</span><br><span class="line">mymath.add(3)</span><br></pre></td></tr></table></figure>

<p><strong>有了接口为什么还需要抽象类？</strong></p>
<blockquote>
<p>接口里面只能放定义，抽象类里面可以放普通类、普通类的方法、定义抽象的东西。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/03/html+css+js+ts/5-Typescript%E5%9F%BA%E7%A1%80/" data-id="cl7ibzold008dugun9a7b2nt2" data-title="Typescript基础总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/5-Ts-interface与type区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/25/html+css+js+ts/5-Ts-interface%E4%B8%8Etype%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2021-07-25T08:20:43.000Z" itemprop="datePublished">2021-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/25/html+css+js+ts/5-Ts-interface%E4%B8%8Etype%E5%8C%BA%E5%88%AB/">TS-interface与type区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h2><h3 id="都可以描述一个对象或者函数"><a href="#都可以描述一个对象或者函数" class="headerlink" title="都可以描述一个对象或者函数"></a>都可以描述一个对象或者函数</h3><p><strong>interface</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SetUser &#123;</span><br><span class="line">  (name: string, age: number): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type SetUser = (name: string, age: number)=&gt; void;</span><br></pre></td></tr></table></figure>

<h3 id="都允许拓展（extends）"><a href="#都允许拓展（extends）" class="headerlink" title="都允许拓展（extends）"></a>都允许拓展（extends）</h3><blockquote>
<p><code>interface</code> 和 <code>type</code> 都可以拓展，并且两者并不是相互独立的，也就是说 <code>interface</code> 可以 <code>extends type</code>, <code>type</code> 也可以 <code>extends interface</code> 。 虽然效果差不多，但是两者语法不同</p>
</blockquote>
<p><strong>interface extends interface</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type extends type</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; age: number  &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>interface extends type</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type extends interface</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><h3 id="type-可以而-interface-不行"><a href="#type-可以而-interface-不行" class="headerlink" title="type 可以而 interface 不行"></a>type 可以而 interface 不行</h3><blockquote>
<p>type 可以声明基本类型别名，联合类型，元组等类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型别名</span><br><span class="line">type Name = string</span><br><span class="line"></span><br><span class="line">// 联合类型</span><br><span class="line">interface Dog &#123;</span><br><span class="line">    wong();</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Pet = Dog | Cat</span><br><span class="line"></span><br><span class="line">// 具体定义数组每个位置的类型</span><br><span class="line">type PetList = [Dog, Pet]</span><br></pre></td></tr></table></figure>

<p><strong>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 当你想获取一个变量的类型时，使用 typeof</span><br><span class="line">let div = document.createElement(&#x27;div&#x27;);</span><br><span class="line">type B = typeof div</span><br></pre></td></tr></table></figure>

<p><strong>其他骚操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type StringOrNumber = string | number;  </span><br><span class="line">type Text = string | &#123; text: string &#125;;  </span><br><span class="line">type NameLookup = Dictionary&lt;string, Person&gt;;  </span><br><span class="line">type Callback&lt;T&gt; = (data: T) =&gt; void;  </span><br><span class="line">type Pair&lt;T&gt; = [T, T];  </span><br><span class="line">type Coordinates = Pair&lt;number&gt;;  </span><br><span class="line">type Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="interface-可以而-type-不行"><a href="#interface-可以而-type-不行" class="headerlink" title="interface 可以而 type 不行"></a>interface 可以而 type 不行</h3><blockquote>
<p><code>interface</code> 能够声明合并</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface User &#123;</span><br><span class="line">  sex: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">User 接口为 &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">  sex: string </span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不清楚什么时候用<code>interface/type</code>，能用 <code>interface</code> 实现，就用 <code>interface</code> , 如果不能就用 <code>type</code></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/25/html+css+js+ts/5-Ts-interface%E4%B8%8Etype%E5%8C%BA%E5%88%AB/" data-id="cl7ibzold008augungr8rbb37" data-title="TS-interface与type区别" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-bug/echarts图标自适应方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/15/bug/echarts%E5%9B%BE%E6%A0%87%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-07-15T04:21:38.000Z" itemprop="datePublished">2021-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/15/bug/echarts%E5%9B%BE%E6%A0%87%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%B3%95/">echarts图标自适应方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在使用echarts是，当放大缩放屏幕时，会出现echarts图形因未自适应而导致溢出div的情况</p>
<p>面对此问题，可以使用resize监听来实现效果，核心代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="variable constant_">XXX</span>.<span class="title function_">resize</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>实例：</p>
<p>标签写法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:xs</span>=<span class="string">&quot;24&quot;</span> <span class="attr">:sm</span>=<span class="string">&quot;24&quot;</span> <span class="attr">:lg</span>=<span class="string">&quot;24&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;chart-wrapper&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;testBottom&quot;</span> <span class="attr">class</span>=<span class="string">&quot;chart-wrapper&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; height: 600px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>生命周期中调用生成echarts图表的方法，该方法具体如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试用</span></span><br><span class="line"><span class="title function_">getTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> chartDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;testBottom&#x27;</span>);	<span class="comment">//找到目标对应节点</span></span><br><span class="line">    <span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(chartDom);		<span class="comment">//处理一下</span></span><br><span class="line">    <span class="keyword">var</span> option = &#123;</span><br><span class="line">        <span class="attr">xAxis</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">            <span class="attr">boundaryGap</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">data</span>: [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">yAxis</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">series</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">data</span>: [<span class="number">820</span>, <span class="number">932</span>, <span class="number">901</span>, <span class="number">934</span>, <span class="number">1290</span>, <span class="number">1330</span>, <span class="number">1320</span>],</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span>,</span><br><span class="line">                <span class="attr">areaStyle</span>: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    option &amp;&amp; myChart.<span class="title function_">setOption</span>(option)		</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;		<span class="comment">//对该对象进行处理，设置resize</span></span><br><span class="line">        myChart.<span class="title function_">resize</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这样，效果就实现了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/15/bug/echarts%E5%9B%BE%E6%A0%87%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%B3%95/" data-id="cl7ibm46r0005igunb77l6gks" data-title="echarts图标自适应方法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-bug/echart使用技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/23/bug/echart%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2021-06-23T11:34:07.000Z" itemprop="datePublished">2021-06-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/23/bug/echart%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">echart使用小结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>十一个组件选项主要用来进行交互</p>
</blockquote>
<h2 id="一、Timeline选项"><a href="#一、Timeline选项" class="headerlink" title="一、Timeline选项"></a>一、Timeline选项</h2><ul>
<li>时间轴，每个图表最多仅有一个时间轴控件</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/45.png" alt="img"></p>
<h2 id="二、Title选项"><a href="#二、Title选项" class="headerlink" title="二、Title选项"></a>二、Title选项</h2><ul>
<li>每个图表最多仅有一个标题控件，每个标题控件可设主副标题</li>
</ul>
<blockquote>
<p>可以对标题文字的大小样式进行设置</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/46.png" alt="img"></p>
<h2 id="三、toolbox"><a href="#三、toolbox" class="headerlink" title="三、toolbox"></a>三、toolbox</h2><ul>
<li>工具箱，每个图表最多仅有一个工具箱。工具箱里面可以实现图表类型的切换，保存图片，刷新，查看数据等功能。可以对其像素进行设置</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/47.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    mark : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            mark : &#x27;辅助线开关&#x27;,</span><br><span class="line"></span><br><span class="line">            markUndo : &#x27;删除辅助线&#x27;,</span><br><span class="line"></span><br><span class="line">            markClear : &#x27;清空辅助线&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        lineStyle : &#123;</span><br><span class="line"></span><br><span class="line">            width : 2,</span><br><span class="line"></span><br><span class="line">            color : &#x27;#1e90ff&#x27;,</span><br><span class="line"></span><br><span class="line">            type : &#x27;dashed&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    dataZoom : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            dataZoom : &#x27;区域缩放&#x27;,</span><br><span class="line"></span><br><span class="line">            dataZoomReset : &#x27;区域缩放后退&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    dataView : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;数据视图&#x27;,</span><br><span class="line"></span><br><span class="line">        readOnly: false,</span><br><span class="line"></span><br><span class="line">        lang: [&#x27;数据视图&#x27;, &#x27;关闭&#x27;, &#x27;刷新&#x27;]</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    magicType: &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            line : &#x27;折线图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            bar : &#x27;柱形图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            stack : &#x27;堆积&#x27;,</span><br><span class="line"></span><br><span class="line">            tiled : &#x27;平铺&#x27;,</span><br><span class="line"></span><br><span class="line">            force: &#x27;力导向布局图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            chord: &#x27;和弦图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            pie: &#x27;饼图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            funnel: &#x27;漏斗图切换&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        option: &#123;</span><br><span class="line"></span><br><span class="line">            // line: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // bar: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // stack: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // tiled: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // force: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // chord: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // pie: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // funnel: &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        type : []</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    restore : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;还原&#x27;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    saveAsImage : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;保存为图片&#x27;,</span><br><span class="line"></span><br><span class="line">        type : &#x27;png&#x27;,</span><br><span class="line"></span><br><span class="line">        lang : [&#x27;点击保存&#x27;]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、tooltip"><a href="#四、tooltip" class="headerlink" title="四、tooltip"></a>四、tooltip</h2><ul>
<li>提示框，鼠标悬浮交互时的信息提示</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/48.png" alt="img"></p>
<h2 id="五、legend"><a href="#五、legend" class="headerlink" title="五、legend"></a>五、legend</h2><ul>
<li>图例，每个图表最多仅有一个图例，混搭图表共享</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/49.png" alt="img"></p>
<h2 id="六、dataRange"><a href="#六、dataRange" class="headerlink" title="六、dataRange"></a>六、dataRange</h2><ul>
<li>值域选择，每个图表最多仅有一个值域控件</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/50.png" alt="img"></p>
<h2 id="七、dataZoom"><a href="#七、dataZoom" class="headerlink" title="七、dataZoom"></a>七、dataZoom</h2><ul>
<li><a target="_blank" rel="noopener" href="http://echarts.baidu.com/echarts2/doc/example/dataZoom.html">数据区域缩放</a>。与toolbox.feature.dataZoom同步，仅对直角坐标系图表有效</li>
</ul>
<h2 id="roamController"><a href="#roamController" class="headerlink" title="roamController"></a>roamController</h2><ul>
<li><a target="_blank" rel="noopener" href="http://echarts.baidu.com/echarts2/doc/example/map1.html">缩放漫游组件</a>，仅对地图有效</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/51.png" alt="img"></p>
<h2 id="八、grid"><a href="#八、grid" class="headerlink" title="八、grid"></a>八、grid</h2><blockquote>
<p>直角坐标系内绘图网格</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/52.png" alt="img"></p>
<h2 id="九、xAxis"><a href="#九、xAxis" class="headerlink" title="九、xAxis"></a>九、xAxis</h2><blockquote>
<p>直角坐标系中横轴数组，数组中每一项代表一条横轴坐标轴，仅有一条时可省略数组。最多同时存在2条横轴，单条横轴时可指定安放于grid的底部（默认）或顶部，2条同时存在时位置互斥，默认第一条安放于底部，第二条安放于顶部</p>
</blockquote>
<h2 id="十、yAxis"><a href="#十、yAxis" class="headerlink" title="十、yAxis"></a>十、yAxis</h2><blockquote>
<p>直角坐标系中纵轴数组，数组中每一项代表一条纵轴坐标轴，仅有一条时可省略数组。最多同时存在2条纵轴，单条纵轴时可指定安放于grid的左侧（默认）或右侧，2条同时存在时位置互斥，默认第一条安放于左侧，第二条安放于右侧</p>
</blockquote>
<ul>
<li>坐标轴有三种类型，类目型、数值型和时间型，纵轴通常为数值型，但条形图时则纵轴为类目型</li>
</ul>
<h2 id="十一、series（通用）"><a href="#十一、series（通用）" class="headerlink" title="十一、series（通用）"></a>十一、series（通用）</h2><blockquote>
<p>驱动图表生成的数据内容数组，数组中每一项为一个系列的选项及数据，其中个别选项仅在部分图表类型中有效，请注意适用类型</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/23/bug/echart%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" data-id="cl7icghhl013tugun4dcl3bqw" data-title="echart使用小结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/echart/" rel="tag">echart</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器/浅谈PWA(Progressive Web App)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/12/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%85%E8%B0%88PWA(Progressive%20Web%20App)/" class="article-date">
  <time class="dt-published" datetime="2021-06-12T08:27:05.000Z" itemprop="datePublished">2021-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/12/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%85%E8%B0%88PWA(Progressive%20Web%20App)/">浅谈PWA(Progressive Web App)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、初识PWA"><a href="#一、初识PWA" class="headerlink" title="一、初识PWA"></a>一、初识PWA</h1><blockquote>
<ul>
<li><code>PWA</code>，即<code>Progressive Web App</code>, 是提升 <code>Web App</code> 的体验的一种新方法，能给用户原生应用的体验。</li>
<li>一个 <code>PWA</code> 应用首先是一个网页, 可以通过 <code>Web</code> 技术编写出一个网页应用. 随后添加上 <code>App Manifest</code> 和 <code>Service Worker</code> 来实现<code>PWA</code> 的安装和离线等功能</li>
</ul>
</blockquote>
<h2 id="1-1-PWA中的一些技术"><a href="#1-1-PWA中的一些技术" class="headerlink" title="1.1 PWA中的一些技术"></a>1.1 PWA中的一些技术</h2><blockquote>
<p><code>PWA</code>本身其实是一个概念集合，它不是指某一项技术，而是通过一系列的<code>Web</code>技术与<code>Web</code>标准来优化<code>Web App</code>的安全、性能和体验。其中涉及到的一些技术概念包括了</p>
</blockquote>
<ul>
<li><code>Web App Manifest</code></li>
<li><code>Service Worker</code></li>
<li><code>Cache API</code> 缓存</li>
<li><code>Push、Notification</code> 推送与通知</li>
<li><code>Background Sync</code>后台同步</li>
<li>响应式设计</li>
</ul>
<h2 id="1-2-解决了哪些问题"><a href="#1-2-解决了哪些问题" class="headerlink" title="1.2 解决了哪些问题"></a>1.2 解决了哪些问题</h2><ul>
<li>可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏</li>
<li>实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能</li>
<li>实现了消息推送</li>
</ul>
<h2 id="1-3-PWA存在的问题"><a href="#1-3-PWA存在的问题" class="headerlink" title="1.3 PWA存在的问题"></a>1.3 PWA存在的问题</h2><ul>
<li>支持率不高:现在<code>ios</code>手机端不支持<code>pwa</code>，<code>IE</code>也暂时不支持<br><code>Chrome</code>在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低</li>
<li>各大厂商还未明确支持<code>pwa</code></li>
<li>依赖的<code>GCM</code>服务在国内无法使用</li>
<li>微信小程序的竞争</li>
</ul>
<blockquote>
<p>尽管有上述的一些缺点，PWA技术仍然有很多可以使用的点。</p>
</blockquote>
<ul>
<li><code>service worker</code>技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。</li>
<li><code>service worker</code>实现消息推送，使用浏览器推送功能，吸引用户<br>渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验</li>
</ul>
<h1 id="二、PWA的实现"><a href="#二、PWA的实现" class="headerlink" title="二、PWA的实现"></a>二、PWA的实现</h1><h2 id="2-1-Manifest实现添加至主屏幕"><a href="#2-1-Manifest实现添加至主屏幕" class="headerlink" title="2.1 Manifest实现添加至主屏幕"></a>2.1 Manifest实现添加至主屏幕</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.html--&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Minimal PWA&lt;/title&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot; /&gt;</span><br><span class="line">  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;main.css&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;icon&quot; href=&quot;/e.png&quot; type=&quot;image/png&quot; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">// manifest.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Minimal PWA&quot;, // 必填 显示的插件名称</span><br><span class="line">  &quot;short_name&quot;: &quot;PWA Demo&quot;, // 可选  在APP launcher和新的tab页显示，如果没有设置，则使用name</span><br><span class="line">  &quot;description&quot;: &quot;The app that helps you understand PWA&quot;, //用于描述应用</span><br><span class="line">  &quot;display&quot;: &quot;standalone&quot;, // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的</span><br><span class="line">  &quot;start_url&quot;: &quot;/&quot;, // 应用启动时的url</span><br><span class="line">  &quot;theme_color&quot;: &quot;#313131&quot;, // 桌面图标的背景色</span><br><span class="line">  &quot;background_color&quot;: &quot;#313131&quot;, // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。</span><br><span class="line">  &quot;icons&quot;: [ // 桌面图标，是一个数组</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/lowres.webp&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;48x48&quot;,  // 以空格分隔的图片尺寸</span><br><span class="line">    &quot;type&quot;: &quot;image/webp&quot;  // 帮助userAgent快速排除不支持的类型</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/lowres&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;48x48&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/hd_hi.ico&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/hd_hi.svg&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;72x72&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>Manifest</code>参考文档：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Manifest">https://developer.mozilla.org/zh-CN/docs/Web/Manifest</a></li>
<li>如果用的是安卓手机，可以下载chrome浏览器自己操作看看</li>
</ul>
</blockquote>
<h2 id="2-2-service-worker实现离线缓存"><a href="#2-2-service-worker实现离线缓存" class="headerlink" title="2.2 service worker实现离线缓存"></a>2.2 service worker实现离线缓存</h2><h3 id="2-2-1-什么是service-worker"><a href="#2-2-1-什么是service-worker" class="headerlink" title="2.2.1 什么是service worker"></a>2.2.1 什么是service worker</h3><blockquote>
<p><code>Service Worker</code> 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/401.png" alt="img"></p>
<blockquote>
<p><code>Service Workers</code> 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站</p>
</blockquote>
<h3 id="2-2-2-最主要的特点"><a href="#2-2-2-最主要的特点" class="headerlink" title="2.2.2 最主要的特点"></a>2.2.2 最主要的特点</h3><ul>
<li>在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 <code>HTTP</code> 请求。</li>
<li>网站必须使用 <code>HTTPS</code>。除了使用本地开发环境调试时(如域名使用 <code>localhost</code>)</li>
<li>运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求</li>
<li>单独的作用域范围，单独的运行环境和执行线程</li>
<li>不能操作页面 <code>DOM</code>。但可以通过事件机制来处理</li>
<li>事件驱动型服务线程</li>
</ul>
<blockquote>
<p>为什么要求网站必须是<code>HTTPS</code>的，大概是因为<code>service worker</code>权限太大能拦截所有页面的请求，如果<code>http</code>的网站安装<code>service worker</code>很容易被攻击</p>
</blockquote>
<h3 id="2-2-3-生命周期"><a href="#2-2-3-生命周期" class="headerlink" title="2.2.3 生命周期"></a>2.2.3 生命周期</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/402.png" alt="img"></p>
<blockquote>
<p>当用户首次导航至 URL 时，服务器会返回响应的网页。</p>
</blockquote>
<ul>
<li>第1步:当你调用 <code>register()</code> 函数时， <code>Service Worker</code>开始下载。</li>
<li>第2步:在注册过程中，浏览器会下载、解析并执行 <code>Service Worker ()</code>。如果在此步骤中出现任何错误，<code>register()</code>返回的 <code>promise</code> 都会执行 <code>reject</code>操作，并且 <code>Service Worker</code> 会被废弃。</li>
<li>第3步:一旦 <code>Service Worker</code> 成功执行了，<code>install</code> 事件就会激活</li>
<li>第4步:安装完成，<code>Service Worker</code> 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，<code>Service Worker</code>便已准备就绪，随时可以使用了！</li>
</ul>
<blockquote>
<p><code>chrome://serviceworker-internals</code> 来了解当前浏览器中所有已安装<code>Service Worker</code>的详细情况</p>
</blockquote>
<h3 id="2-2-4-实现离线缓存"><a href="#2-2-4-实现离线缓存" class="headerlink" title="2.2.4 实现离线缓存"></a>2.2.4 实现离线缓存</h3><p><strong>HTTP缓存</strong></p>
<ul>
<li><code>Web</code> 服务器可以使用 <code>Expires</code> 首部来通知 <code>Web</code>客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。使用 <code>HTTP</code> 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期</li>
</ul>
<p><strong>service worker缓存</strong></p>
<ul>
<li><code>Service Workers</code>的强大在于它们拦截 HTTP 请求的能力<br>进入任何传入的<code>HTTP</code> 请求，并决定想要如何响应。在你的 <code>Service Worker</code> 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.html--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Hello Caching World!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- Image --&gt;</span><br><span class="line">    &lt;img src=&quot;/images/hello.png&quot; /&gt;                 </span><br><span class="line">    &lt;!-- JavaScript --&gt;</span><br><span class="line">    &lt;script async src=&quot;/js/script.js&quot;&gt;&lt;/script&gt;     </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      // 注册 service worker</span><br><span class="line">      if (&#x27;serviceWorker&#x27; in navigator) &#123;           </span><br><span class="line">        navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;, &#123;scope: &#x27;/&#x27;&#125;).then(function (registration) &#123;</span><br><span class="line">          // 注册成功</span><br><span class="line">          console.log(&#x27;ServiceWorker registration successful with scope: &#x27;, registration.scope);</span><br><span class="line">        &#125;).catch(function (err) &#123;                   </span><br><span class="line">          // 注册失败 :(</span><br><span class="line">          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>注：<code>Service Worker</code>的注册路径决定了其 <code>scope</code>默认作用页面的范围。</li>
<li>如果 <code>service-worker.js</code>是在 <code>/sw/</code> 页面路径下，这使得该 <code>Service Worker</code> 默认只会收到 页面<code>/sw/</code> 路径下的 fetch 事件。</li>
<li>如果存放在网站的根路径下，则将会收到该网站的所有 <code>fetch</code>事件。</li>
<li>如果希望改变它的作用域，可在第二个参数设置 <code>scope</code> 范围。示例中将其改为了根目录，即对整个站点生效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// service-worker.js</span><br><span class="line"></span><br><span class="line">var cacheName = &#x27;helloWorld&#x27;;     // 缓存的名称  </span><br><span class="line">// install 事件，它发生在浏览器安装并注册 Service Worker 时        </span><br><span class="line">self.addEventListener(&#x27;install&#x27;, event =&gt; &#123; </span><br><span class="line">/* event.waitUtil 用于在安装成功之前执行一些预装逻辑</span><br><span class="line"> 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率</span><br><span class="line"> 安装成功后 ServiceWorker 状态会从 installing 变为 installed */</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(cacheName)                  </span><br><span class="line">    .then(cache =&gt; cache.addAll([    // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。        </span><br><span class="line">      &#x27;/js/script.js&#x27;,</span><br><span class="line">      &#x27;/images/hello.png&#x27;</span><br><span class="line">    ]))</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line">为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。</span><br><span class="line">如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。</span><br><span class="line">*/</span><br><span class="line">self.addEventListener(&#x27;fetch&#x27;, function (event) &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)                  </span><br><span class="line">    .then(function (response) &#123;</span><br><span class="line">      if (response) &#123;                            </span><br><span class="line">        return response;                         </span><br><span class="line">      &#125;</span><br><span class="line">      var requestToCache = event.request.clone();  //          </span><br><span class="line">      return fetch(requestToCache).then(                   </span><br><span class="line">        function (response) &#123;</span><br><span class="line">          if (!response || response.status !== 200) &#123;      </span><br><span class="line">            return response;</span><br><span class="line">          &#125;</span><br><span class="line">          var responseToCache = response.clone();          </span><br><span class="line">          caches.open(cacheName)                           </span><br><span class="line">            .then(function (cache) &#123;</span><br><span class="line">              cache.put(requestToCache, responseToCache);  </span><br><span class="line">            &#125;);</span><br><span class="line">          return response;             </span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为什么用<code>request.clone()</code>和<code>response.clone()</code><br>需要这么做是因为<code>request</code>和<code>response</code>是一个流，它只能消耗一次。因为我们已经通过缓存消耗了一次，然后发起 <code>HTTP</code> 请求还要再消耗一次，所以我们需要在此时克隆请求<br>Clone the request—a request is a stream and can only be consumed once</p>
</blockquote>
<h3 id="2-2-5-调试相关"><a href="#2-2-5-调试相关" class="headerlink" title="2.2.5 调试相关"></a>2.2.5 调试相关</h3><blockquote>
<p>chrome浏览器打开<code>https://googlechrome.github.io/samples/service-worker/basic/index.html</code>，这是一个实现了<code>service worker</code>离线缓存功能的网站，打开调试工具</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/403.png" alt="img"></p>
<ul>
<li>勾选可以模拟网站离线情况，勾选后<code>network</code>会有一个黄色警告图标，该网站已经离线。此时刷新页面，页面仍然能够正常显示</li>
<li>当前<code>service worker</code>的<code>scope</code>。它能够拦截<code>https://googlechrome.github.i</code>…，同样也能够拦截<code>https://googlechrome.github.i.</code>..<em>&#x2F;</em>.html下的请求</li>
</ul>
<blockquote>
<p>调试面板具体代表的什么参看 <code>https://x5.tencent.com/tbs/guide/serviceworker.html</code>的第三部分</p>
</blockquote>
<h2 id="2-3-serice-worker实现消息推送"><a href="#2-3-serice-worker实现消息推送" class="headerlink" title="2.3 serice worker实现消息推送"></a>2.3 serice worker实现消息推送</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/404.png" alt="img"></p>
<ul>
<li>步骤一、提示用户并获得他们的订阅详细信息</li>
<li>步骤二、将这些详细信息保存在服务器上</li>
<li>步骤三、在需要时发送任何消息</li>
</ul>
<blockquote>
<p>不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 <code>Google Cloud Messaging</code> 作为推送服务为例，第一步是注册 <code>applicationServerKey</code>(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（<code>endpoint</code>），订阅对象的属性(<code>PushSubscription.endpoint</code>) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通</p>
</blockquote>
<p><strong>步骤一和步骤二</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.html--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Progressive Times&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;                                      </span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var endpoint;</span><br><span class="line">      var key;</span><br><span class="line">      var authSecret;</span><br><span class="line">      var vapidPublicKey = &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;;</span><br><span class="line">      // 方法很复杂，但是可以不用具体看，知识用来转化vapidPublicKey用</span><br><span class="line">      function urlBase64ToUint8Array(base64String) &#123;                                  </span><br><span class="line">        const padding = &#x27;=&#x27;.repeat((4 - base64String.length % 4) % 4);</span><br><span class="line">        const base64 = (base64String + padding)</span><br><span class="line">          .replace(/\-/g, &#x27;+&#x27;)</span><br><span class="line">          .replace(/_/g, &#x27;/&#x27;);</span><br><span class="line">        const rawData = window.atob(base64);</span><br><span class="line">        const outputArray = new Uint8Array(rawData.length);</span><br><span class="line">        for (let i = 0; i &lt; rawData.length; ++i) &#123;</span><br><span class="line">          outputArray[i] = rawData.charCodeAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return outputArray;</span><br><span class="line">      &#125;</span><br><span class="line">      if (&#x27;serviceWorker&#x27; in navigator) &#123;</span><br><span class="line">        navigator.serviceWorker.register(&#x27;sw.js&#x27;).then(function (registration) &#123;</span><br><span class="line">          return registration.pushManager.getSubscription()                            </span><br><span class="line">            .then(function (subscription) &#123;</span><br><span class="line">              if (subscription) &#123;                                                      </span><br><span class="line">                return;</span><br><span class="line">              &#125;</span><br><span class="line">              return registration.pushManager.subscribe(&#123;                              </span><br><span class="line">                  userVisibleOnly: true,</span><br><span class="line">                  applicationServerKey: urlBase64ToUint8Array(vapidPublicKey)</span><br><span class="line">                &#125;)</span><br><span class="line">                .then(function (subscription) &#123;</span><br><span class="line">                  var rawKey = subscription.getKey ? subscription.getKey(&#x27;p256dh&#x27;) : &#x27;&#x27;;</span><br><span class="line">                  key = rawKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey))) : &#x27;&#x27;;</span><br><span class="line">                  var rawAuthSecret = subscription.getKey ? subscription.getKey(&#x27;auth&#x27;) : &#x27;&#x27;;</span><br><span class="line">                  authSecret = rawAuthSecret ?</span><br><span class="line">                    btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret))) : &#x27;&#x27;;</span><br><span class="line">                  endpoint = subscription.endpoint;</span><br><span class="line">                  return fetch(&#x27;./register&#x27;, &#123;                                         </span><br><span class="line">                    method: &#x27;post&#x27;,</span><br><span class="line">                    headers: new Headers(&#123;</span><br><span class="line">                      &#x27;content-type&#x27;: &#x27;application/json&#x27;</span><br><span class="line">                    &#125;),</span><br><span class="line">                    body: JSON.stringify(&#123;</span><br><span class="line">                      endpoint: subscription.endpoint,</span><br><span class="line">                      key: key,</span><br><span class="line">                      authSecret: authSecret,</span><br><span class="line">                    &#125;),</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;).catch(function (err) &#123;</span><br><span class="line">          // 注册失败 :(</span><br><span class="line">          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>步骤三 服务器发送消息给service worker</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line"></span><br><span class="line">const webpush = require(&#x27;web-push&#x27;);                 </span><br><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">var bodyParser = require(&#x27;body-parser&#x27;);</span><br><span class="line">const app = express();</span><br><span class="line">webpush.setVapidDetails(                             </span><br><span class="line">  &#x27;mailto:contact@deanhume.com&#x27;,</span><br><span class="line">  &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;,</span><br><span class="line">  &#x27;p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0&#x27;</span><br><span class="line">);</span><br><span class="line">app.post(&#x27;/register&#x27;, function (req, res) &#123;           </span><br><span class="line">  var endpoint = req.body.endpoint;</span><br><span class="line">  saveRegistrationDetails(endpoint, key, authSecret); </span><br><span class="line">  const pushSubscription = &#123;                          </span><br><span class="line">    endpoint: req.body.endpoint,</span><br><span class="line">    keys: &#123;</span><br><span class="line">      auth: req.body.authSecret,</span><br><span class="line">      p256dh: req.body.key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  var body = &#x27;Thank you for registering&#x27;;</span><br><span class="line">  var iconUrl = &#x27;https://example.com/images/homescreen.png&#x27;;</span><br><span class="line">  // 发送 Web 推送消息</span><br><span class="line">  webpush.sendNotification(pushSubscription,          </span><br><span class="line">      JSON.stringify(&#123;</span><br><span class="line">        msg: body,</span><br><span class="line">        url: &#x27;http://localhost:3111/&#x27;,</span><br><span class="line">        icon: iconUrl</span><br><span class="line">      &#125;))</span><br><span class="line">    .then(result =&gt; res.sendStatus(201))</span><br><span class="line">    .catch(err =&gt; &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(3111, function () &#123;</span><br><span class="line">  console.log(&#x27;Web push app listening on port 3111!&#x27;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>service worker</code>监听push事件，将通知详情推送给用户</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// service-worker.js</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;push&#x27;, function (event) &#123;</span><br><span class="line"> // 检查服务端是否发来了任何有效载荷数据</span><br><span class="line">  var payload = event.data ? JSON.parse(event.data.text()) : &#x27;no payload&#x27;;</span><br><span class="line">  var title = &#x27;Progressive Times&#x27;;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    // 使用提供的信息来显示 Web 推送通知</span><br><span class="line">    self.registration.showNotification(title, &#123;                           </span><br><span class="line">      body: payload.msg,</span><br><span class="line">      url: payload.url,</span><br><span class="line">      icon: payload.icon</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://lzw.me/a/pwa-service-worker.html#3.3">网站渐进式增强体验(PWA)改造：Service Worker 应用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/SangKa/PWA-Book-CN">PWA实战：面向下一代的Progressive Web APP</a></li>
<li><a target="_blank" rel="noopener" href="https://x5.tencent.com/tbs/guide/serviceworker.html">Service Worker最佳实践</a></li>
<li><a target="_blank" rel="noopener" href="https://fed.renren.com/2017/10/04/service-worker/">使用 Service Worker 做一个 PWA 离线网页应用</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28461857">理解Service Worker</a></li>
<li><a target="_blank" rel="noopener" href="http://obkoro1.com/web_accumulate/accumulate/JS/webWorker%E4%B8%8A%E6%89%8B.html">前端er来学习一下 WebWorker</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bf3f656e51d45338e084044?utm_source=gold_browser_extension">Service Worker学习与实践（二）——PWA简介</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bf3f6b2e51d45360069e527?utm_source=gold_browser_extension">Service Worker学习与实践（三）——消息推送</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/nicejade/nice-front-end-tutorial/blob/master/tutorial/pwa-tutorial.md">pwa-tutoria</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/12/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%85%E8%B0%88PWA(Progressive%20Web%20App)/" data-id="cl7icg7bf00y2ugundppuh6kq" data-title="浅谈PWA(Progressive Web App)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器/浏览器组成与架构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90%E4%B8%8E%E6%9E%B6%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-05-27T07:31:26.000Z" itemprop="datePublished">2021-05-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90%E4%B8%8E%E6%9E%B6%E6%9E%84/">浏览器组成与架构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>​        浏览器由shell（用户界面、网络、UI后端、JavaScript解释器、XML解析器、数据存储）和内核（浏览器引擎、渲染引擎）组成，内核是浏览器的核心。不同的浏览器有不同的内核，ie 浏览器是 Trident，Firefox 浏览器是 Geoko（Mozilla自主研发的渲染引擎），Safari 和 Chrome 使用的是 webkit （后来 Chrome 推出了 Blink）。</p>
<h2 id="用户界面（User-Interface）"><a href="#用户界面（User-Interface）" class="headerlink" title="用户界面（User Interface）"></a>用户界面（User Interface）</h2><pre><code>    用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。

    用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。
</code></pre>
<h2 id="网络（Networking）"><a href="#网络（Networking）" class="headerlink" title="网络（Networking）"></a>网络（Networking）</h2><pre><code>    网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。
</code></pre>
<h2 id="UI后端（Display-Backend）"><a href="#UI后端（Display-Backend）" class="headerlink" title="UI后端（Display Backend）"></a>UI后端（Display Backend）</h2><pre><code>    UI后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。
</code></pre>
<h2 id="JavaScript解释器（JavaScript-Interpreter）"><a href="#JavaScript解释器（JavaScript-Interpreter）" class="headerlink" title="JavaScript解释器（JavaScript Interpreter）"></a>JavaScript解释器（JavaScript Interpreter）</h2><pre><code>    JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。
</code></pre>
<h2 id="XML解析器（XML-Parser）"><a href="#XML解析器（XML-Parser）" class="headerlink" title="XML解析器（XML Parser）"></a>XML解析器（XML Parser）</h2><pre><code>    XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。
</code></pre>
<h2 id="数据存储（Data-Persistence）"><a href="#数据存储（Data-Persistence）" class="headerlink" title="数据存储（Data Persistence）"></a>数据存储（Data Persistence）</h2><pre><code>    数据存储将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。
</code></pre>
<h2 id="浏览器引擎（Browser-Engine）"><a href="#浏览器引擎（Browser-Engine）" class="headerlink" title="浏览器引擎（Browser Engine）"></a>浏览器引擎（Browser Engine）</h2><pre><code>    浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。浏览器引擎还允许查询/修改渲染引擎设置。
</code></pre>
<h2 id="渲染引擎（Rendering-Engine-或-layout-engineer）"><a href="#渲染引擎（Rendering-Engine-或-layout-engineer）" class="headerlink" title="渲染引擎（Rendering Engine 或 layout engineer）"></a>渲染引擎（Rendering Engine 或 layout engineer）</h2><pre><code>    渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。渲染引擎内部包含HTML解析器。
</code></pre>
<h1 id="软件构造"><a href="#软件构造" class="headerlink" title="软件构造"></a>软件构造</h1><p>​        不同的浏览器软件架构也不一样，好的软件都是支持多进程和多线程，进程与进程相互独立，不同的进程之间通过IPC（Inter Process Communication）进行通信。</p>
<pre><code>    以 Chrome 浏览器为例，它的架构模式由浏览器进程（Browser Process）、渲染进程（Renderer Process）、插件进程（Plugin Process）、GPU进程（GPU Process）、网络进程（NetWork Process）和其他进程组成，每个进程都有自己核心的职责，它们相互配合完成浏览器的整体功能，每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个渲染引擎实例。每个标签页都是一个独立的进程，当标签页的数量足够多时（40个页面以上），会与之前的标签页共用同一个进程。
</code></pre>
<h2 id="浏览器进程（Browser-Process）"><a href="#浏览器进程（Browser-Process）" class="headerlink" title="浏览器进程（Browser Process）"></a>浏览器进程（Browser Process）</h2><pre><code>    主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。控制应用程序的 chrome 部分，包括地址栏、书签、后退和前进等按钮，还处理Web浏览器的隐形、底层操作，例如网络请求和文件访问。 
</code></pre>
<h2 id="渲染进程（Renderer-Process）"><a href="#渲染进程（Renderer-Process）" class="headerlink" title="渲染进程（Renderer Process）"></a>渲染进程（Renderer Process）</h2><pre><code>    核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，渲染引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。
</code></pre>
<h2 id="GPU-进程（GPU-Process）"><a href="#GPU-进程（GPU-Process）" class="headerlink" title="GPU 进程（GPU Process）"></a>GPU 进程（GPU Process）</h2><pre><code>    GPU 进程的使用初衷是为了实现 3D CSS 的效果，随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制。
</code></pre>
<h2 id="网络进程（NetWork-Process）"><a href="#网络进程（NetWork-Process）" class="headerlink" title="网络进程（NetWork Process）"></a>网络进程（NetWork Process）</h2><pre><code>    主要负责页面的网络资源加载。
</code></pre>
<h2 id="插件进程（Plugin-Process）"><a href="#插件进程（Plugin-Process）" class="headerlink" title="插件进程（Plugin Process）"></a>插件进程（Plugin Process）</h2><pre><code>    主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
</code></pre>
<h2 id="utility进程（Utility-Process）"><a href="#utility进程（Utility-Process）" class="headerlink" title="utility进程（Utility Process）"></a>utility进程（Utility Process）</h2><pre><code>    有时候浏览器主进程需要做一些“危险”的事情，比如图片解码、文件解压缩。如果这些“危险”的操作发生了失败，会导致整个主进程发生异常崩溃，这是我们不愿意看到的。因此Chromium设计出了一个utility进程的机制。主进程临时需要做一些不方便的任务的情况下，可以启动一个utility进程来代替主进程执行，主进程与utility进程之间通过IPC消息来通信。
</code></pre>
<h2 id="其他进程"><a href="#其他进程" class="headerlink" title="其他进程"></a>其他进程</h2><pre><code>    UI进程、存储进程、备进程、Audio进程、Video进程、Profile进程等等。
</code></pre>
<p>面向服务架构<br>        面向服务架构（Services Oriented Architecture，简称 SOA），后端技术开发中比较火热的微服务架构就是 SOA 的一种变体，Chrome 官方团队将原来的各种模块重构成独立的服务（Service），访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，每个服务（Service）都可以在独立的进程中运行，并且可以轻松拆分为不同的进程或聚合为一个进程。当Chrome在功能强大的硬件上运行时，它可能会将每个服务拆分为不同的进程以提供更高的稳定性，但是如果是在资源受限的设备上，Chrome 会将服务整合到一个进程中以节省内存。</p>
<pre><code>    在最新的 Chrome 浏览器中，可以在设置中打开更多工具，找到任务管理器并打开。



     可以看到有部分的 Chrome Service 与进程同时在运行，Chrome 仍在努力的完善面向服务架构。
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90%E4%B8%8E%E6%9E%B6%E6%9E%84/" data-id="cl7icg7bq00yaugun0rdjaxjs" data-title="浏览器组成与架构" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-html+css+js+ts/await 在 forEach 中不生效解决方案" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/24/html+css+js+ts/await%20%E5%9C%A8%20forEach%20%E4%B8%AD%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="article-date">
  <time class="dt-published" datetime="2021-05-24T06:46:21.000Z" itemprop="datePublished">2021-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>►<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">问题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/24/html+css+js+ts/await%20%E5%9C%A8%20forEach%20%E4%B8%AD%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">await 在 forEach 中不生效解决方案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	arr.forEach(async item =&gt; &#123;</span><br><span class="line">		const res = await fetch(item)</span><br><span class="line">		console.log(res)</span><br><span class="line">	&#125;)</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fetch(x) &#123;</span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		setTimeout(() =&gt; &#123;</span><br><span class="line">			resolve(x)</span><br><span class="line">		&#125;, 500 * x)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>期望的打印顺序是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>结果打印顺序居然是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">end</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong></p>
<blockquote>
<p>那就是 <code>forEach</code> 只支持同步代码。<code>forEach</code> 并不会去处理异步的情况</p>
</blockquote>
<h2 id="二、解决办法"><a href="#二、解决办法" class="headerlink" title="二、解决办法"></a>二、解决办法</h2><h3 id="2-1-第一种是使用-Promise-all-的方式"><a href="#2-1-第一种是使用-Promise-all-的方式" class="headerlink" title="2.1 第一种是使用 Promise.all 的方式"></a>2.1 第一种是使用 Promise.all 的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	await Promise.all(</span><br><span class="line">		arr.map(async item =&gt; &#123;</span><br><span class="line">			const res = await fetch(item)</span><br><span class="line">			console.log(res)</span><br><span class="line">		&#125;)</span><br><span class="line">	)</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样可以生效的原因是 <code>async</code> 函数肯定会返回一个 <code>Promise</code> 对象，调用 <code>map</code> 以后返回值就是一个存放了 <code>Promise</code> 的数组了，这样我们把数组传入 <code>Promise.all</code> 中就可以解决问题了。但是这种方式其实并不能达成我们要的效果，如果你希望内部的 <code>fetch</code> 是顺序完成的，可以选择第二种方式</p>
</blockquote>
<h3 id="2-2-另一种方法是使用-for…of"><a href="#2-2-另一种方法是使用-for…of" class="headerlink" title="2.2 另一种方法是使用 for…of"></a>2.2 另一种方法是使用 for…of</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	for (const item of arr) &#123;</span><br><span class="line">		const res = await fetch(item)</span><br><span class="line">		console.log(res)</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式相比 <code>Promise.all</code> 要简洁的多，并且也可以实现开头我想要的输出顺序。</li>
<li>但是这时候你是否又多了一个疑问？为啥 <code>for...of</code> 内部就能让 <code>await</code> 生效呢。</li>
<li>因为 <code>for...of</code> 内部处理的机制和 f<code>orEach</code> 不同，<code>forEach</code> 是直接调用回调函数，<code>for...of</code> 是通过迭代器的方式去遍历。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	const iterator = arr[Symbol.iterator]()</span><br><span class="line">	let res = iterator.next()</span><br><span class="line">	while (!res.done) &#123;</span><br><span class="line">		const value = res.value</span><br><span class="line">		const res1 = await fetch(value)</span><br><span class="line">		console.log(res1)</span><br><span class="line">		res = iterator.next()</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码等价于 <code>for...of</code>，可以看成 <code>for...of</code> 是以上代码的语法糖</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/24/html+css+js+ts/await%20%E5%9C%A8%20forEach%20%E4%B8%AD%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" data-id="cl7ibzole008gugun5m0dat9p" data-title="await 在 forEach 中不生效解决方案" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/async-await/" rel="tag">async&#x2F;await</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器/浏览器渲染原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/19/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-19T06:18:26.000Z" itemprop="datePublished">2021-05-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/19/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/">浏览器渲染原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、浏览器如何渲染网页"><a href="#一、浏览器如何渲染网页" class="headerlink" title="一、浏览器如何渲染网页"></a>一、浏览器如何渲染网页</h2><p><strong>概述：浏览器渲染一共有五步</strong></p>
<ol>
<li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li>
<li>处理 <code>CSS</code>构建 <code>CSSOM</code> 树。</li>
<li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li>
</ol>
<blockquote>
<p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染</p>
</blockquote>
<p>具体如下图过程如下图所示</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/19.png" alt="img"></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/20.png" alt="img"></p>
<p><strong>渲染</strong></p>
<ul>
<li>网页生成的时候，至少会渲染一次</li>
<li>在用户访问的过程中，还会不断重新渲染</li>
</ul>
<blockquote>
<p>重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)</p>
</blockquote>
<ul>
<li>在构建 <code>CSSOM</code> 树时，会阻塞渲染，直至 <code>CSSOM</code>树构建完成。并且构建 <code>CSSOM</code> 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 <code>CSS</code> 选择器，执行速度越慢</li>
<li>当 <code>HTML</code> 解析到 <code>script</code> 标签时，会暂停构建 <code>DOM</code>，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 <code>JS</code> 文件。并且<code>CSS</code>也会影响 <code>JS</code> 的执行，只有当解析完样式表才会执行 <code>JS</code>，所以也可以认为这种情况下，<code>CSS</code> 也会暂停构建 <code>DOM</code></li>
</ul>
<h2 id="二、浏览器渲染五个阶段"><a href="#二、浏览器渲染五个阶段" class="headerlink" title="二、浏览器渲染五个阶段"></a>二、浏览器渲染五个阶段</h2><h3 id="2-1-第一步：解析HTML标签，构建DOM树"><a href="#2-1-第一步：解析HTML标签，构建DOM树" class="headerlink" title="2.1 第一步：解析HTML标签，构建DOM树"></a>2.1 第一步：解析HTML标签，构建DOM树</h3><blockquote>
<p>在这个阶段，引擎开始解析<code>html</code>，解析出来的结果会成为一棵<code>dom</code>树<br><code>dom</code>的目的至少有<code>2</code>个</p>
</blockquote>
<ul>
<li>作为下个阶段渲染树状图的输入</li>
<li>成为网页和脚本的交互界面。(最常用的就是<code>getElementById</code>等等)</li>
</ul>
<p><strong>当解析器到达script标签的时候，发生下面四件事情</strong></p>
<ol>
<li><code>html</code>解析器停止解析,</li>
<li>如果是外部脚本，就从外部网络获取脚本代码</li>
<li>将控制权交给<code>js</code>引擎，执行<code>js</code>代码</li>
<li>恢复<code>html</code>解析器的控制权</li>
</ol>
<blockquote>
<p>由此可以得到第一个结论1</p>
</blockquote>
<ul>
<li>由于&#96;&#96;标签是阻塞解析的，将脚本放在网页尾部会加速代码渲染。</li>
<li><code>defer</code>和<code>async</code>属性也能有助于加载外部脚本。</li>
<li><code>defer</code>使得脚本会在<code>dom</code>完整构建之后执行；</li>
<li><code>async</code>标签使得脚本只有在完全<code>available</code>才执行，并且是以非阻塞的方式进行的</li>
</ul>
<h3 id="2-2-第二步：解析CSS标签，构建CSSOM树"><a href="#2-2-第二步：解析CSS标签，构建CSSOM树" class="headerlink" title="2.2 第二步：解析CSS标签，构建CSSOM树"></a>2.2 第二步：解析CSS标签，构建CSSOM树</h3><ul>
<li>我们已经看到<code>html</code>解析器碰到脚本后会做的事情，接下来我们看下<code>html</code>解析器碰到样式表会发生的情况</li>
<li><code>js</code>会阻塞解析，因为它会修改文档(<code>document</code>)。<code>css</code>不会修改文档的结构，如果这样的话，似乎看起来<code>css</code>样式不会阻塞浏览器<code>html</code>解析。但是事实上 <code>css</code>样式表是阻塞的。阻塞是指当<code>cssom</code>树建立好之后才会进行下一步的解析渲染</li>
</ul>
<p><strong>通过以下手段可以减轻cssom带来的影响</strong></p>
<ul>
<li>将<code>script</code>脚本放在页面底部</li>
<li>尽可能快的加载<code>css</code>样式表</li>
<li>将样式表按照<code>media type</code>和<code>media query</code>区分，这样有助于我们将<code>css</code>资源标记成非阻塞渲染的资源。</li>
<li>非阻塞的资源还是会被浏览器下载，只是优先级较低</li>
</ul>
<h3 id="2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）"><a href="#2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）" class="headerlink" title="2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）"></a>2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/21.png" alt="img"></p>
<h3 id="2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"><a href="#2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构" class="headerlink" title="2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"></a>2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构</h3><blockquote>
<p>布局(<code>layout</code>)：定位坐标和大小，是否换行，各种<code>position</code>, <code>overflow</code>, <code>z-index</code>属性</p>
</blockquote>
<h3 id="2-5-调用-GPU-绘制，合成图层，显示在屏幕上"><a href="#2-5-调用-GPU-绘制，合成图层，显示在屏幕上" class="headerlink" title="2.5 调用 GPU 绘制，合成图层，显示在屏幕上"></a>2.5 调用 GPU 绘制，合成图层，显示在屏幕上</h3><blockquote>
<p>将渲染树的各个节点绘制到屏幕上，这一步被称为绘制<code>painting</code></p>
</blockquote>
<h2 id="三、渲染优化相关"><a href="#三、渲染优化相关" class="headerlink" title="三、渲染优化相关"></a>三、渲染优化相关</h2><h3 id="3-1-Load-和-DOMContentLoaded-区别"><a href="#3-1-Load-和-DOMContentLoaded-区别" class="headerlink" title="3.1 Load 和 DOMContentLoaded 区别"></a>3.1 Load 和 DOMContentLoaded 区别</h3><ul>
<li><code>Load</code> 事件触发代表页面中的 <code>DOM</code>，<code>CSS</code>，<code>JS</code>，图片已经全部加载完毕。</li>
<li><code>DOMContentLoaded</code> 事件触发代表初始的 <code>HTML</code> 被完全加载和解析，不需要等待 <code>CSS</code>，<code>JS</code>，图片加载</li>
</ul>
<h3 id="3-2-图层"><a href="#3-2-图层" class="headerlink" title="3.2 图层"></a>3.2 图层</h3><blockquote>
<p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</p>
</blockquote>
<p><strong>通过以下几个常用属性可以生成新图层</strong></p>
<ul>
<li><code>3D</code> 变换：<code>translate3d</code>、<code>translateZ</code></li>
<li><code>will-change</code></li>
<li><code>video</code>、<code>iframe</code> 标签</li>
<li>通过动画实现的 <code>opacity</code> 动画转换</li>
<li><code>position: fixed</code></li>
</ul>
<h3 id="3-3-重绘（Repaint）和回流（Reflow）"><a href="#3-3-重绘（Repaint）和回流（Reflow）" class="headerlink" title="3.3 重绘（Repaint）和回流（Reflow）"></a>3.3 重绘（Repaint）和回流（Reflow）</h3><blockquote>
<p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大</p>
</blockquote>
<ul>
<li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li>
<li>回流是布局或者几何属性需要改变就称为回流。</li>
</ul>
<blockquote>
<p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p>
</blockquote>
<p><strong>以下几个动作可能会导致性能问题</strong></p>
<ul>
<li>改变 <code>window</code> 大小</li>
<li>改变字体</li>
<li>添加或删除样式</li>
<li>文字改变</li>
<li>定位或者浮动</li>
<li>盒模型</li>
</ul>
<p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p>
<ul>
<li>当 <code>Event loop</code> 执行完<code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16ms</code> 才会更新一次。</li>
<li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code>才会触发一次，并且自带节流功能。</li>
<li>判断是否触发了 <code>media query</code></li>
<li>更新动画并且发送事件</li>
<li>判断是否有全屏操作事件</li>
<li>执行 <code>requestAnimationFrame</code> 回调</li>
<li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li>
<li>更新界面</li>
<li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li>
</ul>
<p><strong>常见的引起重绘的属性</strong></p>
<ul>
<li><code>color</code></li>
<li><code>border-style</code></li>
<li><code>visibility</code></li>
<li><code>background</code></li>
<li><code>text-decoration</code></li>
<li><code>background-image</code></li>
<li><code>background-position</code></li>
<li><code>background-repeat</code></li>
<li><code>outline-color</code></li>
<li><code>outline</code></li>
<li><code>outline-style</code></li>
<li><code>border-radius</code></li>
<li><code>outline-width</code></li>
<li><code>box-shadow</code></li>
<li><code>background-size</code></li>
</ul>
<h3 id="3-4-常见引起回流属性和方法"><a href="#3-4-常见引起回流属性和方法" class="headerlink" title="3.4 常见引起回流属性和方法"></a>3.4 常见引起回流属性和方法</h3><blockquote>
<p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，下面列一些栗子</p>
</blockquote>
<ul>
<li>添加或者删除可见的<code>DOM</code>元素；</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度</li>
<li>内容变化，比如用户在<code>input</code>框中输入文字</li>
<li>浏览器窗口尺寸改变——<code>resize</code>事件发生时</li>
<li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性</li>
<li>设置 <code>style</code> 属性的值</li>
</ul>
<p><strong>回流影响的范围</strong></p>
<blockquote>
<p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种</p>
</blockquote>
<ul>
<li>全局范围：从根节点<code>html</code>开始对整个渲染树进行重新布局。</li>
<li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li>
</ul>
<p><strong>全局范围回流</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h4&gt;hello&lt;/h4&gt;</span><br><span class="line">    &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt;BDing&lt;/p&gt;</span><br><span class="line">    &lt;h5&gt;male&lt;/h5&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li&gt;coding&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;loving&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当<code>p</code>节点上发生<code>reflow</code>时，<code>hello</code>和<code>body</code>也会重新渲染，甚至<code>h5</code>和<code>ol</code>都会收到影响</p>
</blockquote>
<p><strong>局部范围回流</strong></p>
<blockquote>
<p>用局部布局来解释这种现象：把一个<code>dom</code>的宽高之类的几何信息定死，然后在<code>dom</code>内部触发重排，就只会重新渲染该<code>dom</code>内部的元素，而不会影响到外界</p>
</blockquote>
<h3 id="3-5-减少重绘和回流"><a href="#3-5-减少重绘和回流" class="headerlink" title="3.5 减少重绘和回流"></a>3.5 减少重绘和回流</h3><blockquote>
<p>使用 <code>translate</code> 替代 <code>top</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .test &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 10px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        // 引起回流</span><br><span class="line">        document.querySelector(&#x27;.test&#x27;).style.top = &#x27;100px&#x27;</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li>把 <code>DOM</code> 离线后修改，比如：先把 <code>DOM</code> 给 <code>display:none</code> (有一次 <code>Reflow)</code>，然后你修改<code>100</code>次，然后再把它显示出来</li>
<li>不要把 <code>DOM</code> 结点的属性值放在一个循环里当成循环里的变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    // 获取 offsetTop 会导致回流，因为需要去获取正确的值</span><br><span class="line">    console.log(document.querySelector(&#x27;.test&#x27;).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li>
<li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li>
<li><code>CSS</code>选择符从右往左匹配查找，避免 <code>DOM</code>深度过深</li>
<li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code>标签，浏览器会自动将该节点变为图层。</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/22.png" alt="img"></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/23.png" alt="img"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://blog.poetries.top/2018/01/12/fed-performance-optimization/#%E5%85%AD%E3%80%81%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81">重绘与回流</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/19/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/" data-id="cl7icg7br00ycugunaog74qdn" data-title="浏览器渲染原理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/liunx/">liunx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">问题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/">框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/">算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">架构模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%A1%86%E6%9E%B6/">框架</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mock/" rel="tag">Mock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/async-await/" rel="tag">async&#x2F;await</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echart/" rel="tag">echart</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/" rel="tag">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/" rel="tag">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glup/" rel="tag">glup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/" rel="tag">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vs-code/" rel="tag">vs code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue3/" rel="tag">vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/" rel="tag">xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" rel="tag">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mock/" style="font-size: 10px;">Mock</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/React/" style="font-size: 19.17px;">React</a> <a href="/tags/Redux/" style="font-size: 11.67px;">Redux</a> <a href="/tags/async-await/" style="font-size: 10px;">async/await</a> <a href="/tags/css/" style="font-size: 11.67px;">css</a> <a href="/tags/echart/" style="font-size: 10px;">echart</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/git/" style="font-size: 16.67px;">git</a> <a href="/tags/glup/" style="font-size: 10.83px;">glup</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/http/" style="font-size: 17.5px;">http</a> <a href="/tags/javascript/" style="font-size: 18.33px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10.83px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 13.33px;">nodejs</a> <a href="/tags/python/" style="font-size: 10.83px;">python</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/typescript/" style="font-size: 12.5px;">typescript</a> <a href="/tags/vs-code/" style="font-size: 11.67px;">vs code</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/vue3/" style="font-size: 10px;">vue3</a> <a href="/tags/webpack/" style="font-size: 19.17px;">webpack</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 14.17px;">优化</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10.83px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15.83px;">小程序</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 13.33px;">浏览器</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" style="font-size: 10.83px;">移动端</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10.83px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/25/Js%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">变量类型</a>
          </li>
        
          <li>
            <a href="/2022/08/25/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/01/18/React/React-%E6%8F%90%E9%AB%98%E7%BB%84%E4%BB%B6%E6%95%88%E7%8E%87%20%20%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84render/">React-提高组件效率  避免不必要的render</a>
          </li>
        
          <li>
            <a href="/2022/01/12/%E5%B7%A5%E5%85%B7/git-stach/">git-stach</a>
          </li>
        
          <li>
            <a href="/2021/10/16/Vue/vue3%E4%BC%98%E5%8C%96/">vue3优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>