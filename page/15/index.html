<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/15/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Vue/vue-keep-alive缓存组件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/25/Vue/vue-keep-alive%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2018-06-25T06:23:37.000Z" itemprop="datePublished">2018-06-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/25/Vue/vue-keep-alive%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6/">vue-keep-alive缓存组件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、Keep-alive-是什么"><a href="#一、Keep-alive-是什么" class="headerlink" title="一、Keep-alive 是什么"></a>一、Keep-alive 是什么</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keep-alive`是`vue`中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染`DOM</span><br></pre></td></tr></table></figure>

<p><code>keep-alive</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p>
<p><code>keep-alive</code>可以设置以下<code>props</code>属性：</p>
<ul>
<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存</li>
<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存</li>
<li><code>max</code> - 数字。最多可以缓存多少组件实例</li>
</ul>
<p>关于<code>keep-alive</code>的基本用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is=<span class="string">&quot;view&quot;</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>includes</code>和<code>exclude</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">&quot;a,b&quot;</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">&quot;view&quot;</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 正则表达式 (使用 <span class="string">`v-bind`</span>) --&gt;</span><br><span class="line">&lt;keep-alive :include=<span class="string">&quot;/a|b/&quot;</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">&quot;view&quot;</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数组 (使用 <span class="string">`v-bind`</span>) --&gt;</span><br><span class="line">&lt;keep-alive :include=<span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">&quot;view&quot;</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p>匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)，匿名组件不能被匹配</p>
<p>设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（<code>activated</code>与<code>deactivated</code>）：</p>
<ul>
<li>首次进入组件时：<code>beforeRouteEnter</code> &gt; <code>beforeCreate</code> &gt; <code>created</code>&gt; <code>mounted</code> &gt; <code>activated</code> &gt; … … &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></li>
<li>再次进入组件时：<code>beforeRouteEnter</code> &gt;<code>activated</code> &gt; … … &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></li>
</ul>
<h2 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h2><p>使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用<code>keepalive</code></p>
<p>举个栗子:</p>
<p>当我们从<code>首页</code>–&gt;<code>列表页</code>–&gt;<code>商详页</code>–&gt;<code>再返回</code>，这时候列表页应该是需要<code>keep-alive</code></p>
<p>从<code>首页</code>–&gt;<code>列表页</code>–&gt;<code>商详页</code>–&gt;<code>返回到列表页(需要缓存)</code>–&gt;<code>返回到首页(需要缓存)</code>–&gt;<code>再次进入列表页(不需要缓存)</code>，这时候可以按需来控制页面的<code>keep-alive</code></p>
<p>在路由中设置<code>keepAlive</code>属性判断是否需要缓存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;itemList&#x27;</span>, <span class="comment">// 列表页</span></span><br><span class="line">  component (resolve) &#123;</span><br><span class="line">    require([<span class="string">&#x27;@/pages/item/list&#x27;</span>], resolve)</span><br><span class="line"> &#125;,</span><br><span class="line"> meta: &#123;</span><br><span class="line">  keepAlive: <span class="literal">true</span>,</span><br><span class="line">  title: <span class="string">&#x27;列表页&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span> class=<span class="string">&#x27;wrapper&#x27;</span>&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">        &lt;!-- 需要缓存的视图组件 --&gt; </span><br><span class="line">        &lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line">     &lt;/keep-alive&gt;</span><br><span class="line">      &lt;!-- 不需要缓存的视图组件 --&gt;</span><br><span class="line">     &lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;!$route.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h2><p><code>keep-alive</code>是<code>vue</code>中内置的一个组件</p>
<p>源码位置：src&#x2F;core&#x2F;components&#x2F;keep-alive.js</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">  abstract: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    include: [String, RegExp, Array],</span><br><span class="line">    exclude: [String, RegExp, Array],</span><br><span class="line">    max: [String, Number]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    this.cache = Object.create(null)</span><br><span class="line">    this.keys = []</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destroyed () &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key in this.cache) &#123;</span><br><span class="line">      pruneCacheEntry(this.cache, key, this.keys)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.$watch(<span class="string">&#x27;include&#x27;</span>, val =&gt; &#123;</span><br><span class="line">      pruneCache(this, name =&gt; matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    this.$watch(<span class="string">&#x27;exclude&#x27;</span>, val =&gt; &#123;</span><br><span class="line">      pruneCache(this, name =&gt; !matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">/* 获取默认插槽中的第一个组件节点 */</span></span><br><span class="line">    <span class="keyword">const</span> slot = this.$slots.<span class="keyword">default</span></span><br><span class="line">    <span class="keyword">const</span> vnode = getFirstComponentChild(slot)</span><br><span class="line">    <span class="comment">/* 获取该组件节点的componentOptions */</span></span><br><span class="line">    <span class="keyword">const</span> componentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">      <span class="comment">/* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */</span></span><br><span class="line">      <span class="keyword">const</span> name = getComponentName(componentOptions)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; include, exclude &#125; = this</span><br><span class="line">      <span class="comment">/* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">        <span class="comment">// excluded</span></span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; cache, keys &#125; = this</span><br><span class="line">      <span class="comment">/* 获取组件的key值 */</span></span><br><span class="line">      <span class="keyword">const</span> key = vnode.key == null</span><br><span class="line">        <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">        <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">        ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::$&#123;componentOptions.tag&#125;`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        : vnode.key</span><br><span class="line">     <span class="comment">/*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */</span></span><br><span class="line">      <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance</span><br><span class="line">        <span class="comment">// make current key freshest</span></span><br><span class="line">        remove(keys, key)</span><br><span class="line">        keys.push(key)</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">/* 如果没有命中缓存，则将其设置进缓存 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        cache[key] = vnode</span><br><span class="line">        keys.push(key)</span><br><span class="line">        <span class="comment">// prune oldest entry</span></span><br><span class="line">        <span class="comment">/* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */</span></span><br><span class="line">        <span class="keyword">if</span> (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;</span><br><span class="line">          pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, this._vnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该组件没有<code>template</code>，而是用了<code>render</code>，在组件渲染的时候会自动执行<code>render</code>函数</p>
<p><code>this.cache</code>是一个对象，用来存储需要缓存的组件，它将以如下形式存储：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.cache = &#123;</span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span>:<span class="string">&#x27;组件1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;key2&#x27;</span>:<span class="string">&#x27;组件2&#x27;</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件销毁的时候执行<code>pruneCacheEntry</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function pruneCacheEntry (</span><br><span class="line">  cache: VNodeCache,</span><br><span class="line">  key: <span class="type">string</span>,</span><br><span class="line">  keys: Array&lt;<span class="type">string</span>&gt;,</span><br><span class="line">  current?: VNode</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> cached = cache[key]</span><br><span class="line">  <span class="comment">/* 判断当前没有处于被渲染状态的组件，将其销毁*/</span></span><br><span class="line">  <span class="keyword">if</span> (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123;</span><br><span class="line">    cached.componentInstance.$destroy()</span><br><span class="line">  &#125;</span><br><span class="line">  cache[key] = null</span><br><span class="line">  remove(keys, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>mounted</code>钩子函数中观测 <code>include</code> 和 <code>exclude</code> 的变化，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">    this.$watch(<span class="string">&#x27;include&#x27;</span>, val =&gt; &#123;</span><br><span class="line">        pruneCache(this, name =&gt; matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    this.$watch(<span class="string">&#x27;exclude&#x27;</span>, val =&gt; &#123;</span><br><span class="line">        pruneCache(this, name =&gt; !matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>include</code> 或<code>exclude</code> 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行<code>pruneCache</code>函数，函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function pruneCache (keepAliveInstance, filter) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; cache, keys, _vnode &#125; = keepAliveInstance</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key in cache) &#123;</span><br><span class="line">    <span class="keyword">const</span> cachedNode = cache[key]</span><br><span class="line">    <span class="keyword">if</span> (cachedNode) &#123;</span><br><span class="line">      <span class="keyword">const</span> name = getComponentName(cachedNode.componentOptions)</span><br><span class="line">      <span class="keyword">if</span> (name &amp;&amp; !filter(name)) &#123;</span><br><span class="line">        pruneCacheEntry(cache, key, keys, _vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数内对<code>this.cache</code>对象进行遍历，取出每一项的<code>name</code>值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用<code>pruneCacheEntry</code>函数将其从<code>this.cache</code>对象剔除即可</p>
<p>关于<code>keep-alive</code>的最强大缓存功能是在<code>render</code>函数中实现</p>
<p>首先获取组件的<code>key</code>值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = vnode.key == null? </span><br><span class="line">componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::$&#123;componentOptions.tag&#125;`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">: vnode.key</span><br></pre></td></tr></table></figure>

<p>拿到<code>key</code>值后去<code>this.cache</code>对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */</span></span><br><span class="line"><span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">    vnode.componentInstance = cache[key].componentInstance</span><br><span class="line">    <span class="comment">/* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */</span></span><br><span class="line">    remove(keys, key)</span><br><span class="line">    keys.push(key)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>直接从缓存中拿 <code>vnode</code> 的组件实例，此时重新调整该组件<code>key</code>的顺序，将其从原来的地方删掉并重新放在<code>this.keys</code>中最后一个</p>
<p><code>this.cache</code>对象中没有该<code>key</code>值的情况，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果没有命中缓存，则将其设置进缓存 */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cache[key] = vnode</span><br><span class="line">    keys.push(key)</span><br><span class="line">    <span class="comment">/* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */</span></span><br><span class="line">    <span class="keyword">if</span> (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;</span><br><span class="line">        pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, this._vnode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表明该组件还没有被缓存过，则以该组件的<code>key</code>为键，组件<code>vnode</code>为值，将其存入<code>this.cache</code>中，并且把<code>key</code>存入<code>this.keys</code>中</p>
<p>此时再判断<code>this.keys</code>中缓存组件的数量是否超过了设置的最大缓存数量值<code>this.max</code>，如果超过了，则把第一个缓存组件删掉</p>
<h2 id="四、思考题：缓存后如何获取数据"><a href="#四、思考题：缓存后如何获取数据" class="headerlink" title="四、思考题：缓存后如何获取数据"></a>四、思考题：缓存后如何获取数据</h2><p>解决方案可以有以下两种：</p>
<ul>
<li>beforeRouteEnter</li>
<li>actived</li>
</ul>
<h3 id="beforeRouteEnter"><a href="#beforeRouteEnter" class="headerlink" title="beforeRouteEnter"></a>beforeRouteEnter</h3><p>每次组件渲染的时候，都会执行<code>beforeRouteEnter</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter(to, from, next)&#123;</span><br><span class="line">    next(vm=&gt;&#123;</span><br><span class="line">        console.log(vm)</span><br><span class="line">        <span class="comment">// 每次进入路由执行</span></span><br><span class="line">        vm.getData()  <span class="comment">// 获取数据</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="actived"><a href="#actived" class="headerlink" title="actived"></a>actived</h3><p>在<code>keep-alive</code>缓存的组件被激活的时候，都会执行<code>actived</code>钩子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">activated()&#123;</span><br><span class="line">   this.getData() <span class="comment">// 获取数据</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>注意：服务器端渲染期间<code>avtived</code>不被调用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/25/Vue/vue-keep-alive%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6/" data-id="cl7icg7cu0106ugunaoo7eqxq" data-title="vue-keep-alive缓存组件" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue/vue-data属性是一个函数而不是一个对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/23/Vue/vue-data%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="dt-published" datetime="2018-06-23T02:48:32.000Z" itemprop="datePublished">2018-06-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/23/Vue/vue-data%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/">vue-data属性是一个函数而不是一个对象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、实例和组件定义data的区别"><a href="#一、实例和组件定义data的区别" class="headerlink" title="一、实例和组件定义data的区别"></a>一、实例和组件定义data的区别</h2><p><code>vue</code>实例的时候定义<code>data</code>属性既可以是一个对象，也可以是一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="comment">// 对象格式</span></span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">foo</span>:<span class="string">&quot;foo&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 函数格式</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">             <span class="attr">foo</span>:<span class="string">&quot;foo&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>组件中定义<code>data</code>属性，只能是一个函数</p>
<p>如果为组件<code>data</code>直接定义为一个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;component1&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`&lt;div&gt;组件&lt;/div&gt;`</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">foo</span>:<span class="string">&quot;foo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>则会得到警告信息</p>
<p><img src="https://static.vue-js.com/8e6fc0c0-3acc-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>警告说明：返回的<code>data</code>应该是一个函数在每一个组件实例中</p>
<h2 id="二、组件data定义函数与对象的区别"><a href="#二、组件data定义函数与对象的区别" class="headerlink" title="二、组件data定义函数与对象的区别"></a>二、组件data定义函数与对象的区别</h2><p>上面讲到组件<code>data</code>必须是一个函数，不知道大家有没有思考过这是为什么呢？</p>
<p>在我们定义好一个组件的时候，<code>vue</code>最终都会通过<code>Vue.extend()</code>构成组件实例</p>
<p>这里我们模仿组件构造函数，定义<code>data</code>属性，采用对象的形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>)&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">data</span> = &#123;</span><br><span class="line">	count : <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个组件实例</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const componentA = new Component()</span><br><span class="line">const componentB = new Component()</span><br></pre></td></tr></table></figure>

<p>修改<code>componentA</code>组件<code>data</code>属性的值，<code>componentB</code>中的值也发生了改变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br><span class="line">componentA.<span class="property">data</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>产生这样的原因这是两者共用了同一个内存地址，<code>componentA</code>修改的内容，同样对<code>componentB</code>产生了影响</p>
<p>如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">data</span> = <span class="variable language_">this</span>.<span class="title function_">data</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">data</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">   		count : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>componentA</code>组件<code>data</code>属性的值，<code>componentB</code>中的值不受影响</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br><span class="line">componentA.<span class="property">data</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p><code>vue</code>组件可能会有很多个实例，采用函数返回一个全新<code>data</code>形式，使每个实例对象的数据不会受到其他实例对象数据的污染</p>
<h2 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h2><p>首先可以看看<code>vue</code>初始化<code>data</code>的代码，<code>data</code>的定义可以是函数也可以是对象</p>
<p>源码位置：<code>/vue-dev/src/core/instance/state.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>data</code>既能是<code>object</code>也能是<code>function</code>，那为什么还会出现上文警告呢？</p>
<p>别急，继续看下文</p>
<p>组件在创建的时候，会进行选项的合并</p>
<p>源码位置：<code>/vue-dev/src/core/util/options.js</code></p>
<p>自定义组件会进入<code>mergeOptions</code>进行选项合并</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponent</span>) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      <span class="title function_">initInternalComponent</span>(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">        <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>定义<code>data</code>会进行数据校验</p>
<p>源码位置：<code>/vue-dev/src/core/instance/init.js</code></p>
<p>这时候<code>vm</code>实例为<code>undefined</code>，进入<code>if</code>判断，若<code>data</code>类型不是<code>function</code>，则出现警告提示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">strats.<span class="property">data</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  parentVal: any,</span></span><br><span class="line"><span class="params">  childVal: any,</span></span><br><span class="line"><span class="params">  vm?: Component</span></span><br><span class="line"><span class="params"></span>): ?<span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (childVal &amp;&amp; <span class="keyword">typeof</span> childVal !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;The &quot;data&quot; option should be a function &#x27;</span> +</span><br><span class="line">            <span class="string">&quot;that returns a per-instance value in component &quot;</span> +</span><br><span class="line">            <span class="string">&quot;definitions.&quot;</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> parentVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mergeDataOrFn</span>(parentVal, childVal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mergeDataOrFn</span>(parentVal, childVal, vm);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h3><ul>
<li>根实例对象<code>data</code>可以是对象也可以是函数（根实例是单例），不会产生数据污染情况</li>
<li>组件实例对象<code>data</code>必须为函数，目的是为了防止多个组件实例对象之间共用一个<code>data</code>，产生数据污染。采用函数的形式，<code>initData</code>时会将其作为工厂函数都会返回全新<code>data</code>对象</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/23/Vue/vue-data%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/" data-id="cl7icg7be00xzugundzy39hqj" data-title="vue-data属性是一个函数而不是一个对象" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue/vue-class与style绑定" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/20/Vue/vue-class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/" class="article-date">
  <time class="dt-published" datetime="2018-06-20T03:31:43.000Z" itemprop="datePublished">2018-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/20/Vue/vue-class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/">vue-class与style绑定</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、绑定HTML-class"><a href="#一、绑定HTML-class" class="headerlink" title="一、绑定HTML class"></a>一、绑定HTML class</h2><blockquote>
<p>有三种方法 1、直接绑定 2、数据属性绑定 3、计算属性绑定</p>
</blockquote>
<h3 id="1-1-对象语法"><a href="#1-1-对象语法" class="headerlink" title="1.1 对象语法"></a>1.1 对象语法</h3><blockquote>
<p>如果数据属性 发生改变，<code>class</code> 列表将相应地更新</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-bind:class=&quot;&#123;active:isActive&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:&quot;对象语法&quot;,</span><br><span class="line">        isActive:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>v-bind:class</code> 指令也可以与普通的 <code>class</code> 属性共存</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.active&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class = &quot;box&quot; v-bind:class=&quot;&#123;active:isActive&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            msg:&quot;对象语法&quot;,</span><br><span class="line">            isActive:true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>可以直接绑定数据里的一个对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.active1&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    border: 1px solid #ccc ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-bind:class=&quot;classObj&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        classObj:&#123;</span><br><span class="line">            active:true,</span><br><span class="line">            aaa:false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>可以在这里绑定返回对象的计算属性。这是一个常用且强大的模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.aaa&#123;</span><br><span class="line">    background: green;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-bind:class=&quot;Obj&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            msg:&quot;对象语法&quot;,</span><br><span class="line">            isActive:true</span><br><span class="line">        &#125;,</span><br><span class="line">        computed:&#123;</span><br><span class="line">            Obj:function()&#123;</span><br><span class="line">                return&#123;</span><br><span class="line">                    aaa:this.isActive</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-数组语法"><a href="#1-2-数组语法" class="headerlink" title="1.2 数组语法"></a>1.2 数组语法</h3><blockquote>
<p>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 <code>class</code> 列表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .active&#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .active1&#123;</span><br><span class="line">        color: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">    .aaa&#123;</span><br><span class="line">       border: 5px solid #ccc;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class = &quot;box&quot; v-bind:class=&quot;[isActive,isActive1,isActive2]&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            msg:&quot;对象语法&quot;,</span><br><span class="line">            isActive:&quot;active&quot;,</span><br><span class="line">            isActive1:&quot;active1&quot;,</span><br><span class="line">            isActive2:&quot;aaa&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>可以用三元表达式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .active&#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .active1&#123;</span><br><span class="line">        color: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">    .aaa&#123;</span><br><span class="line">       border: 5px solid #ccc;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class = &quot;box&quot; v-bind:class=&quot;[isActive,isActive1,isActive5 ? isActive2 : &#x27;&#x27;]&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            msg:&quot;对象语法&quot;,</span><br><span class="line">            isActive5:false,</span><br><span class="line">            isActive:&quot;active&quot;,</span><br><span class="line">            isActive1:&quot;active1&quot;,</span><br><span class="line">            isActive2:&quot;aaa&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .active&#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .active1&#123;</span><br><span class="line">        color: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">    .aaa&#123;</span><br><span class="line">       border: 5px solid #ccc;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class = &quot;box&quot; v-bind:class=&quot;[isActive,&#123;active1:isActive5&#125;,isActive5 ? isActive2 : &#x27;&#x27;]&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            msg:&quot;对象语法&quot;,</span><br><span class="line">            isActive5:true,</span><br><span class="line">            isActive:&quot;active&quot;,</span><br><span class="line">            isActive1:&quot;active1&quot;,</span><br><span class="line">            isActive2:&quot;aaa&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-在组件上"><a href="#1-3-在组件上" class="headerlink" title="1.3 在组件上"></a>1.3 在组件上</h3><blockquote>
<p>在一个自定义组件上用到 class 属性的时候，这些类将被添加到根元素上面，这个元素上已经存在的类不会被覆盖</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .active1&#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .aaa&#123;</span><br><span class="line">        border: 5px solid #ccc;</span><br><span class="line">    &#125;</span><br><span class="line">    .bbb&#123;</span><br><span class="line">        height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;tanchu v-bind:class=&quot;classObj&quot;&gt;&lt;/tanchu&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    Vue.component(&#x27;tanchu&#x27;, &#123;</span><br><span class="line">        template: `&lt;div class=&quot;bbb&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;button&quot; value=&quot;弹出&quot;/&gt;</span><br><span class="line">            &lt;/div&gt;`</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            classObj:&#123;</span><br><span class="line">                active1:true,</span><br><span class="line">                aaa:true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="二、绑定内联样式"><a href="#二、绑定内联样式" class="headerlink" title="二、绑定内联样式"></a>二、绑定内联样式</h2><h3 id="2-1-对象语法"><a href="#2-1-对象语法" class="headerlink" title="2.1 对象语法"></a>2.1 对象语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-bind:style=&quot;&#123;background:a,border:b,width:c&#125;&quot;&gt;内联样式&lt;/div&gt;</span><br><span class="line">    &lt;div v-bind:style=&quot;classObj&quot;&gt;内联样式&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            a:&quot;red&quot;,</span><br><span class="line">            b:&quot;5px solid #ccc&quot;,</span><br><span class="line">            c:&quot;100px&quot;</span><br><span class="line">            classObj:&#123;</span><br><span class="line">                background:&quot;red&quot;,</span><br><span class="line">                border:&quot;5px solid #ccc&quot;,</span><br><span class="line">                width:&quot;100px&quot;,</span><br><span class="line">                marginTop:&quot;10px&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-数组语法"><a href="#2-2-数组语法" class="headerlink" title="2.2 数组语法"></a>2.2 数组语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 数组语法 --&gt;</span><br><span class="line">    &lt;div v-bind:style=&quot;[classObj,classObj1]&quot;&gt;内联样式&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            classObj:&#123;</span><br><span class="line">                background:&quot;red&quot;,</span><br><span class="line">                border:&quot;5px solid #ccc&quot;,</span><br><span class="line">                width:&quot;100px&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            classObj1:&#123;</span><br><span class="line">                height:&quot;100px&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-自动添加前缀"><a href="#2-3-自动添加前缀" class="headerlink" title="2.3 自动添加前缀"></a>2.3 自动添加前缀</h3><blockquote>
<p>当 <code>v-bind:style</code> 使用需要特定前缀的 CSS 属性时，如 <code>transform</code>，<code>Vue.js</code> 会自动侦测并添加相应的前缀</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/20/Vue/vue-class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/" data-id="cl7icg78200uaugunhu5nhamu" data-title="vue-class与style绑定" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue/SPA首屏加载优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/15/Vue/SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2018-06-15T07:19:34.000Z" itemprop="datePublished">2018-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/15/Vue/SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/">SPA首屏加载优化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="面试官：SPA首屏加载速度慢的怎么解决？"><a href="#面试官：SPA首屏加载速度慢的怎么解决？" class="headerlink" title="面试官：SPA首屏加载速度慢的怎么解决？"></a>面试官：SPA首屏加载速度慢的怎么解决？</h1><p><img src="https://static.vue-js.com/24617c00-3acc-11eb-ab90-d9ae814b240d.png" alt="image.png"></p>
<h2 id="一、什么是首屏加载"><a href="#一、什么是首屏加载" class="headerlink" title="一、什么是首屏加载"></a>一、什么是首屏加载</h2><p>首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容</p>
<p>首屏加载可以说是用户体验中<strong>最重要</strong>的环节</p>
<h3 id="关于计算首屏时间"><a href="#关于计算首屏时间" class="headerlink" title="关于计算首屏时间"></a>关于计算首屏时间</h3><p>利用<code>performance.timing</code>提供的数据：</p>
<p><img src="https://static.vue-js.com/2e2491a0-3acc-11eb-85f6-6fac77c0c9b3.png" alt="image.png"></p>
<p>通过<code>DOMContentLoad</code>或者<code>performance</code>来计算出首屏时间</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案一：</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first contentful painting&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方案二：</span></span><br><span class="line">performance.<span class="title function_">getEntriesByName</span>(<span class="string">&quot;first-contentful-paint&quot;</span>)[<span class="number">0</span>].<span class="property">startTime</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0]</span></span><br><span class="line"><span class="comment">// 会返回一个 PerformancePaintTiming的实例，结构如下：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;first-contentful-paint&quot;</span>,</span><br><span class="line">  <span class="attr">entryType</span>: <span class="string">&quot;paint&quot;</span>,</span><br><span class="line">  <span class="attr">startTime</span>: <span class="number">507.80000002123415</span>,</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="二、加载慢的原因"><a href="#二、加载慢的原因" class="headerlink" title="二、加载慢的原因"></a>二、加载慢的原因</h2><p>在页面渲染的过程，导致加载速度慢的因素可能如下：</p>
<ul>
<li>网络延时问题</li>
<li>资源文件体积是否过大</li>
<li>资源是否重复发送请求去加载了</li>
<li>加载脚本的时候，渲染内容堵塞了</li>
</ul>
<h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><p>常见的几种SPA首屏优化方式</p>
<ul>
<li>减小入口文件积</li>
<li>静态资源本地缓存</li>
<li>UI框架按需加载</li>
<li>图片资源的压缩</li>
<li>组件重复打包</li>
<li>开启GZip压缩</li>
<li>使用SSR</li>
</ul>
<h3 id="减小入口文件体积"><a href="#减小入口文件体积" class="headerlink" title="减小入口文件体积"></a>减小入口文件体积</h3><p>常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加</p>
<p><img src="https://static.vue-js.com/486cee90-3acc-11eb-ab90-d9ae814b240d.png" alt="image.png"></p>
<p>在<code>vue-router</code>配置路由的时候，采用动态加载路由的形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>:[ </span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;Blogs&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ShowBlogs&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./components/ShowBlogs.vue&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件</p>
<h3 id="静态资源本地缓存"><a href="#静态资源本地缓存" class="headerlink" title="静态资源本地缓存"></a>静态资源本地缓存</h3><p>后端返回资源问题：</p>
<ul>
<li>采用<code>HTTP</code>缓存，设置<code>Cache-Control</code>，<code>Last-Modified</code>，<code>Etag</code>等响应头</li>
<li>采用<code>Service Worker</code>离线缓存</li>
</ul>
<p>前端合理利用<code>localStorage</code></p>
<h3 id="UI框架按需加载"><a href="#UI框架按需加载" class="headerlink" title="UI框架按需加载"></a>UI框架按需加载</h3><p>在日常使用<code>UI</code>框架，例如<code>element-UI</code>、或者<code>antd</code>，我们经常性直接引用整个<code>UI</code>库</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>)</span><br></pre></td></tr></table></figure>



<p>但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Input</span>, <span class="title class_">Pagination</span>, <span class="title class_">Table</span>, <span class="title class_">TableColumn</span>, <span class="title class_">MessageBox</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Button</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Input</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Pagination</span>)</span><br></pre></td></tr></table></figure>



<h3 id="组件重复打包"><a href="#组件重复打包" class="headerlink" title="组件重复打包"></a>组件重复打包</h3><p>假设<code>A.js</code>文件是一个常用的库，现在有多个路由使用了<code>A.js</code>文件，这就造成了重复下载</p>
<p>解决方案：在<code>webpack</code>的<code>config</code>文件中，修改<code>CommonsChunkPlugin</code>的配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">minChunks</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure>



<p><code>minChunks</code>为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件</p>
<h3 id="图片资源的压缩"><a href="#图片资源的压缩" class="headerlink" title="图片资源的压缩"></a>图片资源的压缩</h3><p>图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素</p>
<p>对于所有的图片资源，我们可以进行适当的压缩</p>
<p>对页面上使用到的<code>icon</code>，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻<code>http</code>请求压力。</p>
<h3 id="开启GZip压缩"><a href="#开启GZip压缩" class="headerlink" title="开启GZip压缩"></a>开启GZip压缩</h3><p>拆完包之后，我们再用<code>gzip</code>做一下压缩 安装<code>compression-webpack-plugin</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnmp i compression-webpack-plugin -D</span><br></pre></td></tr></table></figure>



<p>在<code>vue.congig.js</code>中引入并修改<code>webpack</code>配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CompressionPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;compression-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">configureWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 为生产环境修改配置...</span></span><br><span class="line">            config.<span class="property">mode</span> = <span class="string">&#x27;production&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">CompressionPlugin</span>(&#123;</span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/\.js$|\.html$|\.css/</span>, <span class="comment">//匹配文件名</span></span><br><span class="line">                    <span class="attr">threshold</span>: <span class="number">10240</span>, <span class="comment">//对超过10k的数据进行压缩</span></span><br><span class="line">                    <span class="attr">deleteOriginalAssets</span>: <span class="literal">false</span> <span class="comment">//是否删除原文件</span></span><br><span class="line">                &#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>在服务器我们也要做相应的配置 如果发送请求的浏览器支持<code>gzip</code>，就发送给它<code>gzip</code>格式的文件 我的服务器是用<code>express</code>框架搭建的 只要安装一下<code>compression</code>就能使用</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const compression = require(&#x27;compression&#x27;)</span><br><span class="line">app.use(compression())  // 在其他中间件使用之前调用</span><br></pre></td></tr></table></figure>

<h3 id="使用SSR"><a href="#使用SSR" class="headerlink" title="使用SSR"></a>使用SSR</h3><p>SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器</p>
<p>从头搭建一个服务端渲染是很复杂的，<code>vue</code>应用建议使用<code>Nuxt.js</code>实现服务端渲染</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化</p>
<p>下图是更为全面的首屏优化的方案</p>
<p><img src="https://static.vue-js.com/4fafe900-3acc-11eb-85f6-6fac77c0c9b3.png" alt="image.png"></p>
<p>大家可以根据自己项目的情况选择各种方式进行首屏渲染的优化</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/15/Vue/SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/" data-id="cl7icg72a00pdugunalfqgiy8" data-title="SPA首屏加载优化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue/Object.defineProperty详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/11/Vue/Object.defineProperty%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2018-06-11T01:48:42.000Z" itemprop="datePublished">2018-06-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/11/Vue/Object.defineProperty%E8%AF%A6%E8%A7%A3/">Object.defineProperty详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><strong>兼容性</strong></p>
<blockquote>
<p>在<code>ie8</code>下只能在<code>DOM</code>对象上使用，尝试在原生的对象使用 <code>Object.defineProperty()</code>会报错。</p>
</blockquote>
<p>定义对象可以使用构造函数或字面量的形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object;  //obj = &#123;&#125;</span><br><span class="line">obj.name = &quot;张三&quot;;  //添加描述</span><br><span class="line">obj.say = function()&#123;&#125;;  //添加行为</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了以上添加属性的方式，还可以使用<code>Object.defineProperty</code>定义新属性或修改原有的属性</p>
</blockquote>
<h2 id="二、Object-defineProperty"><a href="#二、Object-defineProperty" class="headerlink" title="二、Object.defineProperty()"></a>二、Object.defineProperty()</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li><code>obj</code>：必需。目标对象</li>
<li><code>prop</code>：必需。需定义或修改的属性的名字</li>
<li><code>descriptor</code>：必需。目标属性所拥有的特性</li>
</ul>
<blockquote>
<p>返回值：传入函数的对象。即第一个参数<code>obj</code></p>
</blockquote>
<ul>
<li>针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被<code>for..in</code>或<code>Object.keys()</code>遍历。</li>
</ul>
<p><strong>给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述</strong></p>
<h3 id="2-2-数据描述"><a href="#2-2-数据描述" class="headerlink" title="2.2 数据描述"></a>2.2 数据描述</h3><blockquote>
<p>当修改或定义对象的某个属性的时候，给这个属性添加一些特性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    test:&quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line">//对象已有的属性添加特性描述</span><br><span class="line">Object.defineProperty(obj,&quot;test&quot;,&#123;</span><br><span class="line">    configurable:true | false,</span><br><span class="line">    enumerable:true | false,</span><br><span class="line">    value:任意类型的值,</span><br><span class="line">    writable:true | false</span><br><span class="line">&#125;);</span><br><span class="line">//对象新添加的属性的特性描述</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    configurable:true | false,</span><br><span class="line">    enumerable:true | false,</span><br><span class="line">    value:任意类型的值,</span><br><span class="line">    writable:true | false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据描述中的属性都是可选的，来看一下设置每一个属性的作用</p>
</blockquote>
<h4 id="2-2-1-value"><a href="#2-2-1-value" class="headerlink" title="2.2.1 value"></a>2.2.1 value</h4><blockquote>
<p>属性对应的值,可以使任意类型的值，默认为<code>undefined</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">//第一种情况：不设置value属性</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">console.log( obj.newKey );  //undefined</span><br><span class="line">------------------------------</span><br><span class="line">//第二种情况：设置value属性</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    value:&quot;hello&quot;</span><br><span class="line">&#125;);</span><br><span class="line">console.log( obj.newKey );  //hello</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-writable"><a href="#2-2-2-writable" class="headerlink" title="2.2.2 writable"></a>2.2.2 writable</h4><blockquote>
<p>属性的值是否可以被重写。设置为<code>true</code>可以被重写；设置为<code>false</code>，不能被重写。默认为<code>false</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">//第一种情况：writable设置为false，不能重写。</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    value:&quot;hello&quot;,</span><br><span class="line">    writable:false</span><br><span class="line">&#125;);</span><br><span class="line">//更改newKey的值</span><br><span class="line">obj.newKey = &quot;change value&quot;;</span><br><span class="line">console.log( obj.newKey );  //hello</span><br><span class="line"></span><br><span class="line">//第二种情况：writable设置为true，可以重写</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    value:&quot;hello&quot;,</span><br><span class="line">    writable:true</span><br><span class="line">&#125;);</span><br><span class="line">//更改newKey的值</span><br><span class="line">obj.newKey = &quot;change value&quot;;</span><br><span class="line">console.log( obj.newKey );  //change value</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-enumerable"><a href="#2-2-3-enumerable" class="headerlink" title="2.2.3 enumerable"></a>2.2.3 enumerable</h4><blockquote>
<p>此属性是否可以被枚举（使用<code>for...in</code>或<code>Object.keys()</code>）。设置为<code>true</code>可以被枚举；设置为<code>false</code>，不能被枚举。默认为<code>false</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">//第一种情况：enumerable设置为false，不能被枚举。</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    value:&quot;hello&quot;,</span><br><span class="line">    writable:false,</span><br><span class="line">    enumerable:false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//枚举对象的属性</span><br><span class="line">for( var attr in obj )&#123;</span><br><span class="line">    console.log( attr );  </span><br><span class="line">&#125;</span><br><span class="line">//第二种情况：enumerable设置为true，可以被枚举。</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    value:&quot;hello&quot;,</span><br><span class="line">    writable:false,</span><br><span class="line">    enumerable:true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//枚举对象的属性</span><br><span class="line">for( var attr in obj )&#123;</span><br><span class="line">    console.log( attr );  //newKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-configurable"><a href="#2-2-4-configurable" class="headerlink" title="2.2.4 configurable"></a>2.2.4 configurable</h4><blockquote>
<p>是否可以删除目标属性或是否可以再次修改属性的特性（<code>writable</code>, <code>configurable</code>, <code>enumerable</code>）。设置为<code>true</code>可以被删除或可以重新设置特性；设置为<code>false</code>，不能被可以被删除或不可以重新设置特性。默认为<code>false</code></p>
</blockquote>
<p><strong>这个属性起到两个作用</strong></p>
<ul>
<li>目标属性是否可以使用<code>delete</code>删除</li>
<li>目标属性是否可以再次设置特性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//-----------------测试目标属性是否能被删除------------------------</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">//第一种情况：configurable设置为false，不能被删除。</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    value:&quot;hello&quot;,</span><br><span class="line">    writable:false,</span><br><span class="line">    enumerable:false,</span><br><span class="line">    configurable:false</span><br><span class="line">&#125;);</span><br><span class="line">//删除属性</span><br><span class="line">delete obj.newKey;</span><br><span class="line">console.log( obj.newKey ); //hello</span><br><span class="line"></span><br><span class="line">//第二种情况：configurable设置为true，可以被删除。</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    value:&quot;hello&quot;,</span><br><span class="line">    writable:false,</span><br><span class="line">    enumerable:false,</span><br><span class="line">    configurable:true</span><br><span class="line">&#125;);</span><br><span class="line">//删除属性</span><br><span class="line">delete obj.newKey;</span><br><span class="line">console.log( obj.newKey ); //undefined</span><br><span class="line">//-----------------测试是否可以再次修改特性------------------------</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">//第一种情况：configurable设置为false，不能再次修改特性。</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    value:&quot;hello&quot;,</span><br><span class="line">    writable:false,</span><br><span class="line">    enumerable:false,</span><br><span class="line">    configurable:false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//重新修改特性</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    value:&quot;hello&quot;,</span><br><span class="line">    writable:true,</span><br><span class="line">    enumerable:true,</span><br><span class="line">    configurable:true</span><br><span class="line">&#125;);</span><br><span class="line">console.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey</span><br><span class="line"></span><br><span class="line">//第二种情况：configurable设置为true，可以再次修改特性。</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    value:&quot;hello&quot;,</span><br><span class="line">    writable:false,</span><br><span class="line">    enumerable:false,</span><br><span class="line">    configurable:true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//重新修改特性</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    value:&quot;hello&quot;,</span><br><span class="line">    writable:true,</span><br><span class="line">    enumerable:true,</span><br><span class="line">    configurable:true</span><br><span class="line">&#125;);</span><br><span class="line">console.log( obj.newKey ); //hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了可以给新定义的属性设置特性，也可以给已有的属性设置特性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//定义对象的时候添加的属性，是可删除、可重写、可枚举的。</span><br><span class="line">var obj = &#123;</span><br><span class="line">    test:&quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//改写值</span><br><span class="line">obj.test = &#x27;change value&#x27;;</span><br><span class="line"></span><br><span class="line">console.log( obj.test ); //&#x27;change value&#x27;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj,&quot;test&quot;,&#123;</span><br><span class="line">    writable:false</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//再次改写值</span><br><span class="line">obj.test = &#x27;change value again&#x27;;</span><br><span class="line"></span><br><span class="line">console.log( obj.test ); //依然是：&#x27;change value&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：一旦使用<code>Object.defineProperty</code>给对象添加属性，那么如果不设置属性的特性，那么<code>configurable</code>、<code>enumerable</code>、<code>writable</code>这些值都为默认的<code>false</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">//定义的新属性后，这个属性的特性中configurable，enumerable，writable都为默认的值false</span><br><span class="line">//这就导致了neykey这个是不能重写、不能枚举、不能再次设置特性</span><br><span class="line">//</span><br><span class="line">Object.defineProperty(obj,&#x27;newKey&#x27;,&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//设置值</span><br><span class="line">obj.newKey = &#x27;hello&#x27;;</span><br><span class="line">console.log(obj.newKey);  //undefined</span><br><span class="line"></span><br><span class="line">//枚举</span><br><span class="line">for( var attr in obj )&#123;</span><br><span class="line">    console.log(attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置的特性总结</strong></p>
<ul>
<li><code>value</code>: 设置属性的值</li>
<li><code>writable</code>: 值是否可以重写。<code>true</code> | <code>false</code></li>
<li><code>enumerable</code>: 目标属性是否可以被枚举。<code>true</code> | <code>false</code></li>
<li><code>configurable</code>: 目标属性是否可以被删除或是否可以再次修改特性 <code>true</code> | <code>false</code></li>
</ul>
<h3 id="2-3-存取器描述"><a href="#2-3-存取器描述" class="headerlink" title="2.3 存取器描述"></a>2.3 存取器描述</h3><h4 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h4><blockquote>
<p>当使用存取器描述属性的特性的时候，允许设置以下特性属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    get:function ()&#123;&#125; | undefined,</span><br><span class="line">    set:function (value)&#123;&#125; | undefined</span><br><span class="line">    configurable: true | false</span><br><span class="line">    enumerable: true | false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：当使用了<code>getter</code>或<code>setter</code>方法，不允许使用<code>writable</code>和<code>value</code>这两个属性</p>
</blockquote>
<h4 id="2-3-2-getter-x2F-setter"><a href="#2-3-2-getter-x2F-setter" class="headerlink" title="2.3.2 getter&#x2F;setter"></a>2.3.2 getter&#x2F;setter</h4><blockquote>
<p>当设置或获取对象的某个属性的值的时候，可以提供<code>getter/setter</code>方法。</p>
</blockquote>
<ul>
<li><code>getter</code> 是一种获得属性值的方法</li>
<li><code>setter</code>是一种设置属性值的方法</li>
</ul>
<blockquote>
<p>在特性中使用<code>get/set</code>属性来定义对应的方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var initValue = &#x27;hello&#x27;;</span><br><span class="line">Object.defineProperty(obj,&quot;newKey&quot;,&#123;</span><br><span class="line">    get:function ()&#123;</span><br><span class="line">        //当获取值的时候触发的函数</span><br><span class="line">        return initValue;    </span><br><span class="line">    &#125;,</span><br><span class="line">    set:function (value)&#123;</span><br><span class="line">        //当设置值的时候触发的函数,设置的新值通过参数value拿到</span><br><span class="line">        initValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//获取值</span><br><span class="line">console.log( obj.newKey );  //hello</span><br><span class="line"></span><br><span class="line">//设置值</span><br><span class="line">obj.newKey = &#x27;change value&#x27;;</span><br><span class="line"></span><br><span class="line">console.log( obj.newKey ); //change value</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则<code>get</code>和<code>set</code>的默认值为<code>undefined</code></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/11/Vue/Object.defineProperty%E8%AF%A6%E8%A7%A3/" data-id="cl7icg72g00pfugunbif24caw" data-title="Object.defineProperty详解" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue/MVC、MVP、MVVM之间的关系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/08/Vue/MVC%E3%80%81MVP%E3%80%81MVVM%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2018-06-08T13:59:35.000Z" itemprop="datePublished">2018-06-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">架构模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/08/Vue/MVC%E3%80%81MVP%E3%80%81MVVM%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/">MVC、MVP、MVVM之间的关系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、MVC"><a href="#一、MVC" class="headerlink" title="一、MVC"></a>一、MVC</h2><hr>
<h3 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h3><hr>
<ul>
<li>MVC是一种模式，它将应用分为3个部分：数据（模型）、表现层（视图）、用户交互层（控制器）</li>
<li>一个事件的处理大概是这样<ul>
<li>用户和应用产生交互</li>
<li>控制器的事件处理器被触发</li>
<li>控制器从模型中请求数据，并将其交给视图</li>
<li>视图将数据呈现给用户</li>
</ul>
</li>
</ul>
<h3 id="模型（数据保存）"><a href="#模型（数据保存）" class="headerlink" title="模型（数据保存）"></a>模型（数据保存）</h3><hr>
<ul>
<li>模型用来存放用户的所有数据对象。比如有一个user模型，用来存放用户列表、他们的属性以及所有和模型有关的逻辑</li>
<li>模型不必知晓视图和控制器的细节，模型只需包含数据以及直接和这些数据相关的逻辑</li>
</ul>
<h3 id="视图（用户界面）"><a href="#视图（用户界面）" class="headerlink" title="视图（用户界面）"></a>视图（用户界面）</h3><hr>
<ul>
<li>视图是呈现给用户的，用户与之产生交互。在JavaScript应用中，视图大都是由HTML、css、JavaScript模板组成的</li>
</ul>
<h3 id="控制器（业务逻辑）"><a href="#控制器（业务逻辑）" class="headerlink" title="控制器（业务逻辑）"></a>控制器（业务逻辑）</h3><hr>
<ul>
<li>控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行进行处理，并相应的更新视图。</li>
<li>当页面加载时，控制器会给视图添加事件监听，比如监听表单提交或按钮点击。然后当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了</li>
</ul>
<h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><hr>
<ul>
<li><code>Controller</code> 监听 <code>Model</code> 变化，<code>Model</code> 一变，<code>Controller</code> 就会去更新<code>View</code>。</li>
<li><code>Controller</code> 监听用户交互，用户点了提交或修改按钮，Controller 就要去更新 Model</li>
<li><code>View</code> 传送指令到 <code>Controller</code></li>
<li><code>Controller</code> 完成业务逻辑后，要求 <code>Model</code> 改变状态</li>
<li><code>Model</code> 将新的数据发送到 <code>View</code>，用户得到反馈</li>
</ul>
<p>各部分之间的通信方式</p>
<h2 id="互动模式"><a href="#互动模式" class="headerlink" title="互动模式"></a>互动模式</h2><hr>
<ul>
<li><p>接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller</p>
</li>
<li><p>另一种是直接通过controller接受指令</p>
</li>
</ul>
<h2 id="二、MVP"><a href="#二、MVP" class="headerlink" title="二、MVP"></a>二、MVP</h2><hr>
<ul>
<li><p><code>MVP</code> 模式将 <code>Controller 改名为</code>Presenter&#96;，同时改变了通信方向</p>
</li>
<li><p>各部分之间的通信，都是双向的。</p>
</li>
<li><p><code>View</code> 与<code>Model</code> 不发生联系，都通过 <code>Presenter</code> 传递。</p>
</li>
<li><p><code>View</code> 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里</p>
</li>
</ul>
<h2 id="三、MVVM"><a href="#三、MVVM" class="headerlink" title="三、MVVM"></a>三、MVVM</h2><hr>
<ul>
<li><code>MVVM</code> 模式将 <code>Presenter</code> 改名为 <code>ViewModel</code>，基本上与 <code>MVP</code> 模式完全一致</li>
<li>唯一的区别是，它采用双向绑定（data-binding）：<code>View</code>的变动，自动反映在 <code>ViewModel</code>，反之亦然</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/08/Vue/MVC%E3%80%81MVP%E3%80%81MVVM%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" data-id="cl7icg72800pcugundr2falod" data-title="MVC、MVP、MVVM之间的关系" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue/diff算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/05/31/Vue/diff%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2018-05-31T06:28:16.000Z" itemprop="datePublished">2018-05-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/05/31/Vue/diff%E7%AE%97%E6%B3%95/">vue-diff算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法</p>
<p>其有两个特点：</p>
<ul>
<li>比较只会在同层级进行, 不会跨层级比较</li>
<li>在diff比较的过程中，循环从两边向中间比较</li>
</ul>
<p><code>diff</code> 算法在很多场景下都有应用，在 <code>vue</code> 中，作用于虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较</p>
<h2 id="二、比较方式"><a href="#二、比较方式" class="headerlink" title="二、比较方式"></a>二、比较方式</h2><p><code>diff</code>整体策略为：深度优先，同层比较</p>
<ol>
<li>比较只会在同层级进行, 不会跨层级比较</li>
</ol>
<p><img src="https://static001.infoq.cn/resource/image/91/54/91e9c9519a11caa0c5bf70714383f054.png" alt="img"></p>
<ol>
<li>比较的过程中，循环从两边向中间收拢</li>
</ol>
<p><img src="https://static001.infoq.cn/resource/image/2d/ec/2dcd6ad5cf82c65b9cfc43a27ba1e4ec.png" alt="img"></p>
<p>下面举个<code>vue</code>通过<code>diff</code>算法更新的例子：</p>
<p>新旧<code>VNode</code>节点如下图所示：</p>
<p><img src="https://static001.infoq.cn/resource/image/80/6d/80dc339f73b186479e6d1fc18bfbf66d.png" alt="img"></p>
<p>第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为<code>diff</code>后的第一个真实节点，同时旧节点<code>endIndex</code>移动到C，新节点的 <code>startIndex</code> 移动到了 C</p>
<p><img src="https://static001.infoq.cn/resource/image/76/54/76032c78c8ef74047efd42c070e48854.png" alt="img"></p>
<p>第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，<code>diff</code> 后创建了 C 的真实节点插入到第一次创建的 B 节点后面。同时旧节点的 <code>endIndex</code> 移动到了 B，新节点的 <code>startIndex</code> 移动到了 E</p>
<p><img src="https://static001.infoq.cn/resource/image/1c/d7/1c76e7489660188d35f0a38ea8c8ecd7.png" alt="img"></p>
<p>第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 <code>startIndex</code> 移动到了 A。旧节点的 <code>startIndex</code> 和 <code>endIndex</code> 都保持不动</p>
<p><img src="https://static001.infoq.cn/resource/image/4b/08/4b622c0d61673ec5474465d82305d308.png" alt="img"></p>
<p>第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 <code>diff</code> 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 <code>startIndex</code> 移动到了 B，新节点的<code>startIndex</code> 移动到了 B</p>
<p><img src="https://static001.infoq.cn/resource/image/59/b4/5982417c3e0b2fa9ae940354a0e67ab4.png" alt="img"></p>
<p>第五次循环中，情形同第四次循环一样，因此 <code>diff</code> 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 <code>startIndex</code>移动到了 C，新节点的 startIndex 移动到了 F</p>
<p><img src="https://static001.infoq.cn/resource/image/16/86/16cf0ef90f6e19d26c0ddffeca067e86.png" alt="img"></p>
<p>新节点的 <code>startIndex</code> 已经大于 <code>endIndex</code> 了，需要创建 <code>newStartIdx</code> 和 <code>newEndIdx</code> 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面</p>
<p><img src="https://static001.infoq.cn/resource/image/dc/ad/dc215b45682cf6c9cc4700a5425673ad.png" alt="img"></p>
<h2 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h2><p>当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，订阅者就会调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图</p>
<p>源码位置：src&#x2F;core&#x2F;vdom&#x2F;patch.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode)) &#123; <span class="comment">// 没有新节点，直接执行destory钩子函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode)) <span class="title function_">invokeDestroyHook</span>(oldVnode)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) &#123;</span><br><span class="line">        isInitialPatch = <span class="literal">true</span></span><br><span class="line">        <span class="title function_">createElm</span>(vnode, insertedVnodeQueue) <span class="comment">// 没有旧节点，直接用新节点生成dom元素</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isRealElement = <span class="title function_">isDef</span>(oldVnode.<span class="property">nodeType</span>)</span><br><span class="line">        <span class="keyword">if</span> (!isRealElement &amp;&amp; <span class="title function_">sameVnode</span>(oldVnode, vnode)) &#123;</span><br><span class="line">            <span class="comment">// 判断旧节点和新节点自身一样，一致执行patchVnode</span></span><br><span class="line">            <span class="title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则直接销毁及旧节点，根据新节点生成dom元素</span></span><br><span class="line">            <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVnode.<span class="property">nodeType</span> === <span class="number">1</span> &amp;&amp; oldVnode.<span class="title function_">hasAttribute</span>(<span class="variable constant_">SSR_ATTR</span>)) &#123;</span><br><span class="line">                    oldVnode.<span class="title function_">removeAttribute</span>(<span class="variable constant_">SSR_ATTR</span>)</span><br><span class="line">                    hydrating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isTrue</span>(hydrating)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">hydrate</span>(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">                        <span class="title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVnode</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                oldVnode = <span class="title function_">emptyNodeAt</span>(oldVnode)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vnode.<span class="property">elm</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>patch</code>函数前两个参数位为<code>oldVnode</code> 和 <code>Vnode</code> ，分别代表新的节点和之前的旧节点，主要做了四个判断：</p>
<ul>
<li>没有新节点，直接触发旧节点的<code>destory</code>钩子</li>
<li>没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 <code>createElm</code></li>
<li>旧节点和新节点自身一样，通过 <code>sameVnode</code> 判断节点是否一样，一样时，直接调用 <code>patchVnode</code>去处理这两个节点</li>
<li>旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点</li>
</ul>
<p>下面主要讲的是<code>patchVnode</code>部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span> (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    <span class="comment">// 如果新旧节点一致，什么都不做</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化</span></span><br><span class="line">    <span class="keyword">const</span> elm = vnode.<span class="property">elm</span> = oldVnode.<span class="property">elm</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步占位符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTrue</span>(oldVnode.<span class="property">isAsyncPlaceholder</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">asyncFactory</span>.<span class="property">resolved</span>)) &#123;</span><br><span class="line">        <span class="title function_">hydrate</span>(oldVnode.<span class="property">elm</span>, vnode, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode.<span class="property">isAsyncPlaceholder</span> = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新旧都是静态节点，并且具有相同的key</span></span><br><span class="line">    <span class="comment">// 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上</span></span><br><span class="line">    <span class="comment">// 也不用再有其他操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTrue</span>(vnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">      <span class="title function_">isTrue</span>(oldVnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">      vnode.<span class="property">key</span> === oldVnode.<span class="property">key</span> &amp;&amp;</span><br><span class="line">      (<span class="title function_">isTrue</span>(vnode.<span class="property">isCloned</span>) || <span class="title function_">isTrue</span>(vnode.<span class="property">isOnce</span>))</span><br><span class="line">    ) &#123;</span><br><span class="line">      vnode.<span class="property">componentInstance</span> = oldVnode.<span class="property">componentInstance</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.<span class="property">data</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">prepatch</span>)) &#123;</span><br><span class="line">      <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span></span><br><span class="line">    <span class="keyword">const</span> ch = vnode.<span class="property">children</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isPatchable</span>(vnode)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.<span class="property">update</span>.<span class="property">length</span>; ++i) cbs.<span class="property">update</span>[i](oldVnode, vnode)</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">update</span>)) <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果vnode不是文本节点或者注释节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode.<span class="property">text</span>)) &#123;</span><br><span class="line">      <span class="comment">// 并且都有子节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh) &amp;&amp; <span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">        <span class="comment">// 并且子节点不完全一致，则调用updateChildren</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) <span class="title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果只有新的vnode有子节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="comment">// elm已经引用了老的dom节点，在老的dom节点上添加子节点</span></span><br><span class="line">        <span class="title function_">addVnodes</span>(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.<span class="property">length</span> - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh)) &#123;</span><br><span class="line">        <span class="title function_">removeVnodes</span>(elm, oldCh, <span class="number">0</span>, oldCh.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果老节点是文本节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) &#123;</span><br><span class="line">        nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果新vnode和老vnode是文本节点或注释节点</span></span><br><span class="line">      <span class="comment">// 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.<span class="property">text</span> !== vnode.<span class="property">text</span>) &#123;</span><br><span class="line">      nodeOps.<span class="title function_">setTextContent</span>(elm, vnode.<span class="property">text</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">postpatch</span>)) <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>patchVnode</code>主要做了几个判断：</p>
<ul>
<li>新节点是否是文本节点，如果是，则直接更新<code>dom</code>的文本内容为新节点的文本内容</li>
<li>新节点和旧节点如果都有子节点，则处理比较更新子节点</li>
<li>只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新<code>DOM</code>，并且添加进父节点</li>
<li>只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把<code>DOM</code> 删除</li>
</ul>
<p>子节点不完全一致，则调用<code>updateChildren</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span> (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span> <span class="comment">// 旧头索引</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span> <span class="comment">// 新头索引</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span> <span class="comment">// 旧尾索引</span></span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span> <span class="comment">// 新尾索引</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>] <span class="comment">// oldVnode的第一个child</span></span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="comment">// oldVnode的最后一个child</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>] <span class="comment">// newVnode的第一个child</span></span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="comment">// newVnode的最后一个child</span></span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">    <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">    <span class="comment">// during leaving transitions</span></span><br><span class="line">    <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束</span></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="comment">// 如果oldVnode的第一个child不存在</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) &#123;</span><br><span class="line">        <span class="comment">// oldStart索引右移</span></span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果oldVnode的最后一个child不存在</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) &#123;</span><br><span class="line">        <span class="comment">// oldEnd索引左移</span></span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldStartVnode和newStartVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        <span class="comment">// patch oldStartVnode和newStartVnode， 索引左移，继续循环</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldEndVnode和newEndVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        <span class="comment">// patch oldEndVnode和newEndVnode，索引右移，继续循环</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldStartVnode和newEndVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">        <span class="comment">// patch oldStartVnode和newEndVnode</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">// 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后</span></span><br><span class="line">        canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="property">elm</span>, nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>))</span><br><span class="line">        <span class="comment">// oldStart索引右移，newEnd索引左移</span></span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果oldEndVnode和newStartVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">        <span class="comment">// patch oldEndVnode和newStartVnode</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">// 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前</span></span><br><span class="line">        canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">        <span class="comment">// oldEnd索引左移，newStart索引右移</span></span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果都不匹配</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx)) oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode</span></span><br><span class="line">        idxInOld = <span class="title function_">isDef</span>(newStartVnode.<span class="property">key</span>)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">          : <span class="title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未找到，说明newStartVnode是一个新的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">          <span class="comment">// 创建一个新Vnode</span></span><br><span class="line">          <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !vnodeToMove) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">              <span class="string">&#x27;It seems there are duplicate keys that is causing an update error. &#x27;</span> +</span><br><span class="line">              <span class="string">&#x27;Make sure each v-for item has a unique key.&#x27;</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 比较两个具有相同的key的新节点是否是同一个节点</span></span><br><span class="line">          <span class="comment">//不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            <span class="comment">// patch vnodeToMove和newStartVnode</span></span><br><span class="line">            <span class="title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">            <span class="comment">// 清除</span></span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">            <span class="comment">// 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm</span></span><br><span class="line">            <span class="comment">// 移动到oldStartVnode.elm之前</span></span><br><span class="line">            canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果key相同，但是节点不相同，则创建一个新的节点</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">            <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右移</span></span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>while</code>循环主要处理了以下五种情景：</p>
<ul>
<li>当新老 <code>VNode</code> 节点的 <code>start</code> 相同时，直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的开始索引都加 1</li>
<li>当新老 <code>VNode</code> 节点的 <code>end</code>相同时，同样直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的结束索引都减 1</li>
<li>当老 <code>VNode</code> 节点的 <code>start</code> 和新 <code>VNode</code> 节点的 <code>end</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldEndVnode</code> 的后面，同时老 <code>VNode</code> 节点开始索引加 1，新 <code>VNode</code> 节点的结束索引减 1</li>
<li>当老 <code>VNode</code> 节点的 <code>end</code> 和新 <code>VNode</code> 节点的 <code>start</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldStartVnode</code> 的前面，同时老 <code>VNode</code> 节点结束索引减 1，新 <code>VNode</code>节点的开始索引加 1</li>
<li>如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：<ul>
<li>从旧的 <code>VNode</code> 为 <code>key</code> 值，对应 <code>index</code> 序列为 <code>value</code> 值的哈希表中找到与 <code>newStartVnode</code> 一致 <code>key</code> 的旧的 <code>VNode</code> 节点，再进行<code>patchVnode</code>，同时将这个真实 <code>dom</code>移动到 <code>oldStartVnode</code>对应的真实 <code>dom</code> 的前面</li>
<li>调用 <code>createElm</code> 创建一个新的 <code>dom</code> 节点放到当前 <code>newStartIdx</code> 的位置</li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</p>
</li>
<li><p>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</p>
<p>patchVnode做了以下操作：</p>
<ul>
<li>找到对应的真实<code>dom</code>，称为<code>el</code></li>
<li>如果都有都有文本节点且不相等，将<code>el</code>文本节点设置为<code>Vnode</code>的文本节点</li>
<li>如果<code>oldVnode</code>有子节点而<code>VNode</code>没有，则删除<code>el</code>子节点</li>
<li>如果<code>oldVnode</code>没有子节点而<code>VNode</code>有，则将<code>VNode</code>的子节点真实化后添加到<code>el</code></li>
<li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点</li>
</ul>
<p>updateChildren主要做了以下操作：</p>
<ul>
<li>设置新旧<code>VNode</code>的头尾指针</li>
<li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用<code>patchVnode</code>进行<code>patch</code>重复流程、调用<code>createElem</code>创建一个新节点，从哈希表寻找 <code>key</code>一致的<code>VNode</code> 节点再分情况操作</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/05/31/Vue/diff%E7%AE%97%E6%B3%95/" data-id="cl7icg72s00pnugunf8335dx0" data-title="vue-diff算法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue/vue-axios封装" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/05/27/Vue/vue-axios%E5%B0%81%E8%A3%85/" class="article-date">
  <time class="dt-published" datetime="2018-05-27T13:46:19.000Z" itemprop="datePublished">2018-05-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/05/27/Vue/vue-axios%E5%B0%81%E8%A3%85/">axios封装</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、axios-简介"><a href="#一、axios-简介" class="headerlink" title="一、axios 简介"></a>一、axios 简介</h2><blockquote>
<p><code>axios</code> 是一个基于<code>Promise</code>用于浏览器和 <code>nodejs</code> 的 <code>HTTP</code> 客户端，它本身具有以下特征：</p>
</blockquote>
<ul>
<li>从浏览器中创建 <code>XMLHttpRequest</code></li>
<li>从 <code>node.js</code> 发出 <code>http</code> 请求</li>
<li>支持<code>Promise API</code></li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换<code>JSON</code>数据</li>
<li>客户端支持防止<code>CSRF/XSRF</code></li>
</ul>
<h2 id="二、axios基础"><a href="#二、axios基础" class="headerlink" title="二、axios基础"></a>二、axios基础</h2><ul>
<li><code>axios.request（config）</code></li>
<li><code>axios.get（url [，config]）</code></li>
<li><code>axios.delete（url [，config]）</code></li>
<li><code>axios.head（url [，config]）</code></li>
<li><code>axios.options（url [，config]）</code></li>
<li><code>axios.post（url [，data [，config]]</code>）</li>
<li><code>axios.put（url [，data [，config]]）</code></li>
<li><code>axios.patch（url [，data [，config]]）</code></li>
</ul>
<h2 id="三、执行-GET-请求"><a href="#三、执行-GET-请求" class="headerlink" title="三、执行 GET 请求"></a>三、执行 GET 请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 向具有指定ID的用户发出请求</span><br><span class="line">axios.get(&#x27;/user?ID=12345&#x27;)</span><br><span class="line">.then(function (res) &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">// 也可以通过 params 对象传递参数</span><br><span class="line">axios.get(&#x27;/user&#x27;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">        ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="四、执行-POST-请求"><a href="#四、执行-POST-请求" class="headerlink" title="四、执行 POST 请求"></a>四、执行 POST 请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&#x27;/user&#x27;, &#123;</span><br><span class="line">    userId:&quot;123&quot;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    headers:&#123;</span><br><span class="line">        token:&quot;abc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (res) &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="五、通过配置方式发送请求"><a href="#五、通过配置方式发送请求" class="headerlink" title="五、通过配置方式发送请求"></a>五、通过配置方式发送请求</h2><blockquote>
<p><code>get</code>请求是发送参数，在<code>params</code>中定义。而<code>POST</code>请求是发送<code>request body</code>,需要在<code>data</code>中定义</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// get 在params中定义</span><br><span class="line">axios(&#123;</span><br><span class="line">    url:&quot;pakage.json&quot;,</span><br><span class="line">    method:&quot;get&quot;,</span><br><span class="line">    params:&#123;</span><br><span class="line">        userId:&quot;123&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    headers:&#123;</span><br><span class="line">        token:&quot;http-test&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    console.log(res.data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// post 在data中定义</span><br><span class="line">axios(&#123;</span><br><span class="line">    url:&quot;pakage.json&quot;,</span><br><span class="line">    method:&quot;post&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        userId:&quot;123&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    headers:&#123;</span><br><span class="line">        token:&quot;http-test&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    console.log(res.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="六、执行多个并发请求"><a href="#六、执行多个并发请求" class="headerlink" title="六、执行多个并发请求"></a>六、执行多个并发请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getUserAcount()&#123;</span><br><span class="line">    // 返回一个promise对象</span><br><span class="line">    return axios.get(&quot;/user/1234&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function getUserPermissions()&#123;</span><br><span class="line">    // 返回一个promise对象</span><br><span class="line">    return axios.get(&quot;/user/1234/getUserPermissions&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//一次性返回两个接口</span><br><span class="line">axios.all([getUserAccount(),getUserPerssions()]).then(axios.spread((acct, perms) =&gt; &#123;</span><br><span class="line">    // spread展开两个返回的结果</span><br><span class="line">    //两个请求现已完成</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h2 id="七、全局拦截"><a href="#七、全局拦截" class="headerlink" title="七、全局拦截"></a>七、全局拦截</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;app&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:&quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 初始化生命周期的一个函数</span><br><span class="line">    mounted:function()&#123;</span><br><span class="line">     //拦截请求之前</span><br><span class="line">       axios.interceptors.request.use(config=&gt;&#123;</span><br><span class="line">           //这里做一些拦截操作,拦截用户的请求 请求之前做一些loading处理</span><br><span class="line">           return config;</span><br><span class="line">       &#125;)</span><br><span class="line">       //拦截响应之后处理</span><br><span class="line">       axios.interceptors.response.use(response=&gt;&#123;</span><br><span class="line">           //这里做一些拦截操作,响应以后做什么，在返回数据</span><br><span class="line">           return response;</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line">        get: function() &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;,</span><br><span class="line">        post:function() &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="八、请求封装、异常统一处理"><a href="#八、请求封装、异常统一处理" class="headerlink" title="八、请求封装、异常统一处理"></a>八、请求封装、异常统一处理</h2><blockquote>
<p>vue中采用axios处理网络请求，避免请求接口重复代码，以及各种网络情况造成的异常情况的判断，采用axios请求封装和异常拦截操作</p>
</blockquote>
<h3 id="8-1-axios-请求封装"><a href="#8-1-axios-请求封装" class="headerlink" title="8.1 axios 请求封装"></a>8.1 axios 请求封装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//  引入axios文件包</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line"></span><br><span class="line">// POST 方法封装  (参数处理)</span><br><span class="line">export const postRequest = (url, params) =&gt; &#123;</span><br><span class="line">  return axios(&#123;</span><br><span class="line">    method: &#x27;post&#x27;,</span><br><span class="line">    url: url,</span><br><span class="line">    data: params,</span><br><span class="line">    transformRequest: [function (data) &#123;</span><br><span class="line">      let ret = &#x27;&#x27;</span><br><span class="line">      for (let it in data) &#123;</span><br><span class="line">        ret += encodeURIComponent(it) + &#x27;=&#x27; + encodeURIComponent(data[it]) + &#x27;&amp;&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">      return ret</span><br><span class="line">    &#125;],</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// POST 方法封装  (文件上传)</span><br><span class="line">export const uploadFileRequest = (url, params) =&gt; &#123;</span><br><span class="line">  return axios(&#123;</span><br><span class="line">    method: &#x27;post&#x27;,</span><br><span class="line">    url: url,</span><br><span class="line">    data: params,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  GET 方法封装</span><br><span class="line">export const getRequest = (url) =&gt; &#123;</span><br><span class="line">  return axios(&#123;</span><br><span class="line">    method: &#x27;get&#x27;,</span><br><span class="line">    url: url</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  PUT 方法封装</span><br><span class="line">export const putRequest = (url, params) =&gt; &#123;</span><br><span class="line">  return axios(&#123;</span><br><span class="line">    method: &#x27;put&#x27;,</span><br><span class="line">    url: url,</span><br><span class="line">    data: params,</span><br><span class="line">    transformRequest: [function (data) &#123;</span><br><span class="line">      let ret = &#x27;&#x27;</span><br><span class="line">      for (let it in data) &#123;</span><br><span class="line">        ret += encodeURIComponent(it) + &#x27;=&#x27; + encodeURIComponent(data[it]) + &#x27;&amp;&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">      return ret</span><br><span class="line">    &#125;],</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  DELETE 方法封装</span><br><span class="line">export const deleteRequest = (url) =&gt; &#123;</span><br><span class="line">  return axios(&#123;</span><br><span class="line">    method: &#x27;delete&#x27;,</span><br><span class="line">    url: url</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-axios请求异常统一处理"><a href="#8-2-axios请求异常统一处理" class="headerlink" title="8.2 axios请求异常统一处理"></a>8.2 axios请求异常统一处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">// 引入依赖包</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">import &#123;Message&#125; from &#x27;element-ui&#x27;</span><br><span class="line"></span><br><span class="line">//  REQUEST 请求异常拦截</span><br><span class="line">axios.interceptors.request.use(config=&gt; &#123;</span><br><span class="line"> //==========  所有请求之前都要执行的操作  ==============</span><br><span class="line">  return config;</span><br><span class="line">&#125;, err=&gt; &#123;</span><br><span class="line"> //==================  错误处理  ====================</span><br><span class="line">  Message.error(&#123;message: &#x27;请求超时!&#x27;&#125;);</span><br><span class="line">  return Promise.resolve(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//  RESPONSE 响应异常拦截</span><br><span class="line">axios.interceptors.response.use(data=&gt; &#123;</span><br><span class="line">//==============  所有请求完成后都要执行的操作  ==================</span><br><span class="line"></span><br><span class="line">// 第一种方式</span><br><span class="line"></span><br><span class="line">    // 根据返回的code值来做不同的处理（和后端约定）</span><br><span class="line">    switch (data.code) &#123;</span><br><span class="line">        case &#x27;0&#x27;:</span><br><span class="line">            // exp: 修复iPhone 6+ 微信点击返回出现页面空白的问题</span><br><span class="line">            if (isIOS()) &#123;</span><br><span class="line">                // 异步以保证数据已渲染到页面上</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    // 通过滚动强制浏览器进行页面重绘</span><br><span class="line">                    document.body.scrollTop += 1</span><br><span class="line">                &#125;, 0)</span><br><span class="line">            &#125;</span><br><span class="line">            // 这一步保证数据返回，如果没有return则会走接下来的代码，不是未登录就是报错</span><br><span class="line">            return data</span><br><span class="line"></span><br><span class="line">        // 需要重新登录</span><br><span class="line">        case &#x27;SHIRO_E5001&#x27;:</span><br><span class="line">            // 微信生产环境下授权登录</span><br><span class="line">            if (isWeChat() &amp;&amp; IS_PRODUCTION) &#123;</span><br><span class="line">                axios.get(apis.common.wechat.authorizeUrl).then((&#123; result &#125;) =&gt; &#123;</span><br><span class="line">                    location.replace(global.decodeURIComponent(result))</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 否则跳转到h5登录并带上跳转路由</span><br><span class="line">                const search = encodeSearchParams(&#123;</span><br><span class="line">                    next: location.href,</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                location.replace(`/user/login`)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 不显示提示消息</span><br><span class="line">            data.description = &#x27;&#x27;</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">    &#125;</span><br><span class="line">    // 若不是正确的返回code，且已经登录，就抛出错误</span><br><span class="line">    const err = new Error(data.description)</span><br><span class="line"></span><br><span class="line">    err.data = data</span><br><span class="line">    err.response = response</span><br><span class="line"></span><br><span class="line">  // 第二种方式，仅对200和error状态处理</span><br><span class="line">  if (data.status &amp;&amp; data.status == 200 &amp;&amp; data.data.status == &#x27;error&#x27;) &#123;</span><br><span class="line">    Message.error(&#123;message: data.data.msg&#125;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  return data;</span><br><span class="line">&#125;, err=&gt; &#123;</span><br><span class="line">//==============  错误处理  ====================</span><br><span class="line">   if (err &amp;&amp; err.response) &#123;</span><br><span class="line">        switch (err.response.status) &#123;</span><br><span class="line">            case 400: err.message = &#x27;请求错误(400)&#x27;; break;</span><br><span class="line">            case 401: err.message = &#x27;未授权，请重新登录(401)&#x27;; break;</span><br><span class="line">            case 403: err.message = &#x27;拒绝访问(403)&#x27;; break;</span><br><span class="line">            case 404: err.message = &#x27;请求出错(404)&#x27;; break;</span><br><span class="line">            case 408: err.message = &#x27;请求超时(408)&#x27;; break;</span><br><span class="line">            case 500: err.message = &#x27;服务器错误(500)&#x27;; break;</span><br><span class="line">            case 501: err.message = &#x27;服务未实现(501)&#x27;; break;</span><br><span class="line">            case 502: err.message = &#x27;网络错误(502)&#x27;; break;</span><br><span class="line">            case 503: err.message = &#x27;服务不可用(503)&#x27;; break;</span><br><span class="line">            case 504: err.message = &#x27;网络超时(504)&#x27;; break;</span><br><span class="line">            case 505: err.message = &#x27;HTTP版本不受支持(505)&#x27;; break;</span><br><span class="line">            default: err.message = `连接出错($&#123;err.response.status&#125;)!`;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err.message = &#x27;连接服务器失败!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  Message.err( &#123;message: err.message &#125; )</span><br><span class="line">  return Promise.resolve(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请求出错的时候执行的是：<code>Promise.resolve(err)</code>;，而不是<code>Promise.reject(err)</code>;，这样无论请求成功还是失败，在成功的回调中都能收到通知</p>
</blockquote>
<h3 id="8-3-vue-项目中使用该方法"><a href="#8-3-vue-项目中使用该方法" class="headerlink" title="8.3 vue 项目中使用该方法"></a>8.3 vue 项目中使用该方法</h3><blockquote>
<p>在main.js中导入所有请求方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  导入所有请求方法</span><br><span class="line">import &#123;getRequest,postRequest,deleteRequest,putRequest&#125; from &#x27;./utils/api&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将请求方法添加至 <code>Vue.prototype</code> 上</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//  向VUE的原型上添加请求方法</span><br><span class="line">Vue.prototype.getRequest = getRequest;</span><br><span class="line">Vue.prototype.postRequest = postRequest;</span><br><span class="line">Vue.prototype.deleteRequest = deleteRequest;</span><br><span class="line">Vue.prototype.putRequest = putRequest;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>发送请求（请求方法的调用）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//  发送网络请求</span><br><span class="line">this.postRequest(&#x27;/login&#x27;, &#123;userName，password&#125;).then(resp=&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="九、接口封装处理"><a href="#九、接口封装处理" class="headerlink" title="九、接口封装处理"></a>九、接口封装处理</h2><blockquote>
<p><code>vue</code>中<code>Axios</code>的封装与<code>API</code>接口的管理详解</p>
</blockquote>
<h3 id="9-1-axios的封装"><a href="#9-1-axios的封装" class="headerlink" title="9.1 axios的封装"></a>9.1 axios的封装</h3><blockquote>
<p>在<code>vue</code>项目中，和后台交互获取数据这块，我们通常使用的是<code>axios</code>库，它是基于<code>promise</code>的<code>http</code>库，可运行在浏览器端和<code>node.js</code>中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换<code>json</code>、客户端防御<code>XSRF</code>等</p>
</blockquote>
<ul>
<li>一般我会在项目的<code>src</code>目录中，新建一个<code>request</code>文件夹，然后在里面新建一个<code>http.js</code>和一个<code>api.js</code>文件。<code>http.js</code>文件用来封装我们的<code>axios</code>，<code>api.js</code>用来统一管理我们的接口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在http.js中引入axios</span><br><span class="line">import axios from &#x27;axios&#x27;; // 引入axios</span><br><span class="line">import QS from &#x27;qs&#x27;; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br><span class="line">// vant的toast提示框组件，大家可根据自己的ui组件更改。</span><br><span class="line">import &#123; Toast &#125; from &#x27;vant&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-环境的切换"><a href="#9-2-环境的切换" class="headerlink" title="9.2 环境的切换"></a>9.2 环境的切换</h3><blockquote>
<p>我们的项目环境可能有开发环境、测试环境和生产环境。我们通过<code>node</code>的环境变量来匹配我们的默认的接口<code>url</code>前缀。<code>axios.defaults.baseURL</code>可以设置<code>axios</code>的默认请求地址就不多说了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 环境的切换</span><br><span class="line">if (process.env.NODE_ENV == &#x27;development&#x27;) &#123; </span><br><span class="line"> axios.defaults.baseURL = &#x27;https://www.baidu.com&#x27;;&#125; </span><br><span class="line">else if (process.env.NODE_ENV == &#x27;debug&#x27;) &#123; </span><br><span class="line"> axios.defaults.baseURL = &#x27;https://www.ceshi.com&#x27;;</span><br><span class="line">&#125; </span><br><span class="line">else if (process.env.NODE_ENV == &#x27;production&#x27;) &#123; </span><br><span class="line"> axios.defaults.baseURL = &#x27;https://www.production.com&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-设置请求超时"><a href="#9-3-设置请求超时" class="headerlink" title="9.3 设置请求超时"></a>9.3 设置请求超时</h3><blockquote>
<p>通过<code>axios.defaults.timeout</code>设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.timeout = 10000;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post`请求头的设置`post`请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置`post`的请求头为`application/x-www-form-urlencoded;charset=UTF-8</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencode</span><br></pre></td></tr></table></figure>

<h3 id="9-4-请求拦截"><a href="#9-4-请求拦截" class="headerlink" title="9.4 请求拦截"></a>9.4 请求拦截</h3><blockquote>
<p>我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 先导入vuex,因为我们要使用到里面的状态对象</span><br><span class="line">// vuex的路径根据自己的路径去写</span><br><span class="line">import store from &#x27;@/store/index&#x27;;</span><br><span class="line"></span><br><span class="line">// 请求拦截器axios.interceptors.request.use( </span><br><span class="line"> config =&gt; &#123; </span><br><span class="line"> // 每次发送请求之前判断vuex中是否存在token </span><br><span class="line"> // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况</span><br><span class="line"> // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 </span><br><span class="line"> const token = store.state.token; </span><br><span class="line"> token &amp;&amp; (config.headers.Authorization = token); </span><br><span class="line"> return config; </span><br><span class="line"> &#125;, </span><br><span class="line"> error =&gt; &#123; </span><br><span class="line"> return Promise.error(error); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般是在登录完成之后，将用户的<code>token</code>通过<code>localStorage</code>或者<code>cookie</code>存在本地，然后用户每次在进入页面的时候（即在<code>main.js</code>中），会首先从本地存储中读取<code>token</code>，如果<code>token</code>存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的<code>header</code>中携带<code>token</code>，后台人员就可以根据你携带的<code>token</code>来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带<code>token</code>，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带<code>token</code>，但是后台可以选择不接收啊！</p>
</blockquote>
<h3 id="9-5-响应的拦截"><a href="#9-5-响应的拦截" class="headerlink" title="9.5 响应的拦截"></a>9.5 响应的拦截</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// 响应拦截器</span><br><span class="line">axios.interceptors.response.use( </span><br><span class="line"> response =&gt; &#123; </span><br><span class="line"> // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 </span><br><span class="line"> // 否则的话抛出错误</span><br><span class="line"> if (response.status === 200) &#123;  </span><br><span class="line">  return Promise.resolve(response); </span><br><span class="line"> &#125; else &#123;  </span><br><span class="line">  return Promise.reject(response); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;, </span><br><span class="line"> // 服务器状态码不是2开头的的情况</span><br><span class="line"> // 这里可以跟你们的后台开发人员协商好统一的错误状态码 </span><br><span class="line"> // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等</span><br><span class="line"> // 下面列举几个常见的操作，其他需求可自行扩展</span><br><span class="line"> error =&gt; &#123;  </span><br><span class="line"> if (error.response.status) &#123;  </span><br><span class="line">  switch (error.response.status) &#123;  </span><br><span class="line">  // 401: 未登录</span><br><span class="line">  // 未登录则跳转登录页面，并携带当前页面的路径</span><br><span class="line">  // 在登录成功后返回当前页面，这一步需要在登录页操作。  </span><br><span class="line">  case 401:   </span><br><span class="line">   router.replace(&#123;   </span><br><span class="line">   path: &#x27;/login&#x27;,   </span><br><span class="line">   query: &#123; </span><br><span class="line">    redirect: router.currentRoute.fullPath </span><br><span class="line">   &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   break;</span><br><span class="line"></span><br><span class="line">  // 403 token过期</span><br><span class="line">  // 登录过期对用户进行提示</span><br><span class="line">  // 清除本地token和清空vuex中token对象</span><br><span class="line">  // 跳转登录页面  </span><br><span class="line">  case 403:</span><br><span class="line">   Toast(&#123;</span><br><span class="line">   message: &#x27;登录过期，请重新登录&#x27;,</span><br><span class="line">   duration: 1000,</span><br><span class="line">   forbidClick: true</span><br><span class="line">   &#125;);</span><br><span class="line">   // 清除token</span><br><span class="line">   localStorage.removeItem(&#x27;token&#x27;);</span><br><span class="line">   store.commit(&#x27;loginSuccess&#x27;, null);</span><br><span class="line">   // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 </span><br><span class="line">   setTimeout(() =&gt; &#123;   </span><br><span class="line">   router.replace(&#123;    </span><br><span class="line">    path: &#x27;/login&#x27;,    </span><br><span class="line">    query: &#123; </span><br><span class="line">    redirect: router.currentRoute.fullPath </span><br><span class="line">    &#125;   </span><br><span class="line">   &#125;);   </span><br><span class="line">   &#125;, 1000);   </span><br><span class="line">   break;</span><br><span class="line"></span><br><span class="line">  // 404请求不存在</span><br><span class="line">  case 404:</span><br><span class="line">   Toast(&#123;</span><br><span class="line">   message: &#x27;网络请求不存在&#x27;,</span><br><span class="line">   duration: 1500,</span><br><span class="line">   forbidClick: true</span><br><span class="line">   &#125;);</span><br><span class="line">   break;</span><br><span class="line">  // 其他错误，直接抛出错误提示</span><br><span class="line">  default:</span><br><span class="line">   Toast(&#123;</span><br><span class="line">   message: error.response.data.message,</span><br><span class="line">   duration: 1500,</span><br><span class="line">   forbidClick: true</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return Promise.reject(error.response);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作</p>
</blockquote>
<ul>
<li>要注意的是，上面的<code>Toast()</code>方法，是我引入的<code>vant</code>库中的<code>toast</code>轻提示组件，你根据你的<code>ui</code>库，对应使用你的一个提示组件</li>
</ul>
<h3 id="9-6-封装get方法和post方法"><a href="#9-6-封装get方法和post方法" class="headerlink" title="9.6 封装get方法和post方法"></a>9.6 封装get方法和post方法</h3><blockquote>
<p>我们常用的<code>ajax</code>请求方法有<code>get</code>、<code>post</code>、<code>put</code>等方法。<code>axios</code>对应的也有很多类似的方法，不清楚的可以看下文档。但是为了简化我们的代码，我们还是要对其进行一个简单的封装。下面我们主要封装两个方法：<code>get</code>和<code>post</code></p>
</blockquote>
<ul>
<li><code>get</code>方法：我们通过定义一个<code>get</code>函数，<code>get</code>函数有两个参数，第一个参数表示我们要请求的<code>url</code>地址，第二个参数是我们要携带的请求参数。<code>get</code>函数返回一个<code>promise</code>对象，当<code>axios</code>其请求成功时<code>resolve</code>服务器返回值，请求失败时<code>reject</code>错误值。最后通过<code>export</code>抛出<code>get</code>函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * get方法，对应get请求</span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址]</span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数]</span><br><span class="line"> */</span><br><span class="line">export function get(url, params)&#123; </span><br><span class="line"> return new Promise((resolve, reject) =&gt;&#123; </span><br><span class="line"> axios.get(url, &#123;  </span><br><span class="line">  params: params </span><br><span class="line"> &#125;).then(res =&gt; &#123;</span><br><span class="line">  resolve(res.data);</span><br><span class="line"> &#125;).catch(err =&gt;&#123;</span><br><span class="line">  reject(err.data) </span><br><span class="line"> &#125;) </span><br><span class="line">&#125;);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>post</code>方法：原理同<code>get</code>基本一样，但是要注意的是，<code>post</code>方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过<code>node</code>的<code>qs</code>模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * post方法，对应post请求 </span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址] </span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数] </span><br><span class="line"> */</span><br><span class="line">export function post(url, params) &#123;</span><br><span class="line"> return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  axios.post(url, QS.stringify(params))</span><br><span class="line"> .then(res =&gt; &#123;</span><br><span class="line">  resolve(res.data);</span><br><span class="line"> &#125;)</span><br><span class="line"> .catch(err =&gt;&#123;</span><br><span class="line">  reject(err.data)</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>axios.get()</code>方法和<code>axios.post()</code>在提交数据时参数的书写方式还是有区别的。区别就是，<code>get</code>的第二个参数是一个<code>&#123;&#125;</code>，然后这个对象的<code>params</code>属性值是一个参数对象的。而<code>post</code>的第二个参数就是一个参数对象</p>
</blockquote>
<h3 id="9-7-api的统一管理"><a href="#9-7-api的统一管理" class="headerlink" title="9.7 api的统一管理"></a>9.7 api的统一管理</h3><blockquote>
<p>首先我们在<code>api.js</code>中引入我们封装的<code>get</code>和<code>post</code>方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * api接口统一管理</span><br><span class="line"> */</span><br><span class="line">import &#123; get, post &#125; from &#x27;./http&#x27;</span><br></pre></td></tr></table></figure>

<p>在<code>api.js</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const apiAddress = param =&gt; post(&#x27;api/v1/users&#x27;,param)</span><br></pre></td></tr></table></figure>

<p>在我们的页面中可以这样调用我们的<code>api</code>接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; apiAddress &#125; from &#x27;@/request/api&#x27;;// 导入我们的api接口</span><br><span class="line">export default &#123;  </span><br><span class="line"> name: &#x27;Address&#x27;, </span><br><span class="line"> created () &#123;</span><br><span class="line">  this.onLoad();</span><br><span class="line"> &#125;,</span><br><span class="line"> methods: &#123;   </span><br><span class="line">  // 获取数据   </span><br><span class="line">  onLoad() &#123;</span><br><span class="line">   // 调用api接口，并且提供了两个参数    </span><br><span class="line">   apiAddress(&#123;     </span><br><span class="line">    type: 0,     </span><br><span class="line">    sort: 1    </span><br><span class="line">   &#125;).then(res =&gt; &#123;</span><br><span class="line">    // 获取数据成功后的其他操作</span><br><span class="line">    ………………    </span><br><span class="line">   &#125;)   </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-8-完整封装代码"><a href="#9-8-完整封装代码" class="headerlink" title="9.8 完整封装代码"></a>9.8 完整封装代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">/**axios封装</span><br><span class="line"> * 请求拦截、相应拦截、错误统一处理</span><br><span class="line"> */</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line">import QS from &#x27;qs&#x27;;</span><br><span class="line">import &#123;</span><br><span class="line">	Toast</span><br><span class="line">&#125;</span><br><span class="line">from &#x27;vant&#x27;;</span><br><span class="line">import store from &#x27;../store/index&#x27;</span><br><span class="line"></span><br><span class="line">// 环境的切换</span><br><span class="line">if (process.env.NODE_ENV == &#x27;development&#x27;) &#123;</span><br><span class="line">	axios.defaults.baseURL = &#x27;/api&#x27;;</span><br><span class="line">&#125; else if (process.env.NODE_ENV == &#x27;debug&#x27;) &#123;</span><br><span class="line">	axios.defaults.baseURL = &#x27;&#x27;;</span><br><span class="line">&#125; else if (process.env.NODE_ENV == &#x27;production&#x27;) &#123;</span><br><span class="line">	axios.defaults.baseURL = &#x27;http://api.123dailu.com/&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 请求超时时间</span><br><span class="line">axios.defaults.timeout = 10000;</span><br><span class="line"></span><br><span class="line">// post请求头</span><br><span class="line">axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;;</span><br><span class="line"></span><br><span class="line">// 请求拦截器</span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">config = &gt; &#123;</span><br><span class="line">	// 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了</span><br><span class="line">	// 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</span><br><span class="line">	const token = store.state.token;</span><br><span class="line">	token &amp;&amp; (config.headers.Authorization = token);</span><br><span class="line">	return config;</span><br><span class="line">&#125;, error = &gt; &#123;</span><br><span class="line">	return Promise.error(error);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 响应拦截器</span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">response = &gt; &#123;</span><br><span class="line">	if (response.status === 200) &#123;</span><br><span class="line">		return Promise.resolve(response);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return Promise.reject(response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 服务器状态码不是200的情况 </span><br><span class="line">error = &gt; &#123;</span><br><span class="line">	if (error.response.status) &#123;</span><br><span class="line">		switch (error.response.status) &#123;</span><br><span class="line">			// 401: 未登录    </span><br><span class="line">			// 未登录则跳转登录页面，并携带当前页面的路径    </span><br><span class="line">			// 在登录成功后返回当前页面，这一步需要在登录页操作。    </span><br><span class="line">		case 401:</span><br><span class="line">			router.replace(&#123;</span><br><span class="line">				path: &#x27;/login&#x27;,</span><br><span class="line">				query: &#123;</span><br><span class="line">					redirect: router.currentRoute.fullPath</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			break;</span><br><span class="line">			// 403 token过期    </span><br><span class="line">			// 登录过期对用户进行提示    </span><br><span class="line">			// 清除本地token和清空vuex中token对象    </span><br><span class="line">			// 跳转登录页面    </span><br><span class="line">		case 403:</span><br><span class="line">			Toast(&#123;</span><br><span class="line">				message: &#x27;登录过期，请重新登录&#x27;,</span><br><span class="line">				duration: 1000,</span><br><span class="line">				forbidClick: true</span><br><span class="line">			&#125;);</span><br><span class="line">			// 清除token     </span><br><span class="line">			localStorage.removeItem(&#x27;token&#x27;);</span><br><span class="line">			store.commit(&#x27;loginSuccess&#x27;, null);</span><br><span class="line">			// 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面</span><br><span class="line">			setTimeout(() = &gt; &#123;</span><br><span class="line">				router.replace(&#123;</span><br><span class="line">					path: &#x27;/login&#x27;,</span><br><span class="line">					query: &#123;</span><br><span class="line">						redirect: router.currentRoute.fullPath</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;, 1000);</span><br><span class="line">			break;</span><br><span class="line">			// 404请求不存在    </span><br><span class="line">		case 404:</span><br><span class="line">			Toast(&#123;</span><br><span class="line">				message: &#x27;网络请求不存在&#x27;,</span><br><span class="line">				duration: 1500,</span><br><span class="line">				forbidClick: true</span><br><span class="line">			&#125;);</span><br><span class="line">			break;</span><br><span class="line">			// 其他错误，直接抛出错误提示    </span><br><span class="line">		default:</span><br><span class="line">			Toast(&#123;</span><br><span class="line">				message: error.response.data.message,</span><br><span class="line">				duration: 1500,</span><br><span class="line">				forbidClick: true</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		return Promise.reject(error.response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">/** </span><br><span class="line"> * get方法，对应get请求</span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址]</span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数]</span><br><span class="line"> */</span><br><span class="line">export</span><br><span class="line">function get(url, params) &#123;</span><br><span class="line">	return new Promise((resolve, reject) = &gt; &#123;</span><br><span class="line">		axios.get(url, &#123;</span><br><span class="line">			params: params</span><br><span class="line">		&#125;).then(res = &gt; &#123;</span><br><span class="line">			resolve(res.data);</span><br><span class="line">		&#125;).</span><br><span class="line">		catch (err = &gt; &#123;</span><br><span class="line">			reject(err.data)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">/** </span><br><span class="line"> * post方法，对应post请求</span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址]</span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数]</span><br><span class="line"> */</span><br><span class="line">export</span><br><span class="line">function post(url, params) &#123;</span><br><span class="line">	return new Promise((resolve, reject) = &gt; &#123;</span><br><span class="line">		axios.post(url, QS.stringify(params)).then(res = &gt; &#123;</span><br><span class="line">			resolve(res.data);</span><br><span class="line">		&#125;).</span><br><span class="line">		catch (err = &gt; &#123;</span><br><span class="line">			reject(err.data)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/05/27/Vue/vue-axios%E5%B0%81%E8%A3%85/" data-id="cl7icg72s00pkugunevp93hlw" data-title="axios封装" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-http/TCP和UDP的区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/05/13/http/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2018-05-13T04:46:51.000Z" itemprop="datePublished">2018-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/05/13/http/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/">TCP和UDP的区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-基于连接vs无连接"><a href="#1-基于连接vs无连接" class="headerlink" title="1. 基于连接vs无连接"></a><strong>1. 基于连接vs无连接</strong></h3><ul>
<li>TCP是面向连接的协议。</li>
<li>UDP是无连接的协议。UDP更加适合消息的多播发布，从单个点向多个点传输消息。</li>
</ul>
<h3 id="2-可靠性"><a href="#2-可靠性" class="headerlink" title="2. 可靠性"></a><strong>2. 可靠性</strong></h3><ul>
<li>TCP提供交付保证，传输过程中丢失，将会重发。</li>
<li>UDP是不可靠的，不提供任何交付保证。（网游和视频的丢包情况）</li>
</ul>
<h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a><strong>3. 有序性</strong></h3><ul>
<li>TCP保证了消息的有序性，即使到达客户端顺序不同，TCP也会排序。</li>
<li>UDP不提供有序性保证。</li>
</ul>
<h3 id="4-数据边界"><a href="#4-数据边界" class="headerlink" title="4. 数据边界"></a><strong>4. 数据边界</strong></h3><ul>
<li>TCP不保存数据边界。<br>虽然TCP也将在收集所有字节之后生成一个完整的消息，但是这些信息在传给传输给接受端之前将储存在TCP缓冲区，以确保更好的使用网络带宽。</li>
<li>UDP保证。<br>在UDP中，数据包单独发送的，只有当他们到达时，才会再次集成。包有明确的界限来哪些包已经收到，这意味着在消息发送后，在接收器接口将会有一个读操作，来生成一个完整的消息。</li>
</ul>
<h3 id="5-速度"><a href="#5-速度" class="headerlink" title="5. 速度"></a><strong>5. 速度</strong></h3><ul>
<li>TCP速度慢</li>
<li>UDP速度快。应用在在线视频媒体，电视广播和多人在线游戏。</li>
</ul>
<h3 id="6-发送消耗"><a href="#6-发送消耗" class="headerlink" title="6. 发送消耗"></a><strong>6. 发送消耗</strong></h3><ul>
<li>TCP是重量级。</li>
<li>UDP是轻量级。<br>因为UDP传输的信息中不承担任何间接创造连接，保证交货或秩序的的信息。<br>这也反映在用于报头大小。</li>
</ul>
<h3 id="7-报头大小"><a href="#7-报头大小" class="headerlink" title="7. 报头大小"></a><strong>7. 报头大小</strong></h3><ul>
<li>TCP头大。<br>一个TCP数据包报头的大小是20字节。<br>TCP报头中包含序列号，ACK号，数据偏移量，保留，控制位，窗口，紧急指针，可选项，填充项，校验位，源端口和目的端口。</li>
<li>UDP头小。<br>UDP数据报报头是8个字节。<br>而UDP报头只包含长度，源端口号，目的端口，和校验和。</li>
</ul>
<h3 id="8-拥塞或流控制"><a href="#8-拥塞或流控制" class="headerlink" title="8. 拥塞或流控制"></a><strong>8. 拥塞或流控制</strong></h3><ul>
<li>TCP有流量控制。<br>在任何用户数据可以被发送之前，TCP需要三数据包来设置一个套接字连接。TCP处理的可靠性和拥塞控制。</li>
<li>UDP不能进行流量控制。</li>
</ul>
<h3 id="9-应用"><a href="#9-应用" class="headerlink" title="9. 应用"></a><strong>9. 应用</strong></h3><ul>
<li>由于TCP提供可靠交付和有序性的保证，它是最适合需要高可靠并且对传输时间要求不高的应用。</li>
<li>UDP是更适合的应用程序需要快速，高效的传输的应用，如游戏。</li>
<li>UDP是无状态的性质，在服务器端需要对大量客户端产生的少量请求进行应答的应用中是非常有用的。</li>
<li>在实践中，TCP被用于金融领域，如FIX协议是一种基于TCP的协议，而UDP是大量使用在游戏和娱乐场所。</li>
</ul>
<h3 id="10-上层使用的协议"><a href="#10-上层使用的协议" class="headerlink" title="10.上层使用的协议"></a><strong>10.上层使用的协议</strong></h3><ul>
<li>基于TCP协议的：Telnet，FTP以及SMTP协议。</li>
<li>基于UDP协议的：DHCP、DNS、SNMP、TFTP、BOOTP。</li>
<li></li>
</ul>
<h2 id="一、UDP"><a href="#一、UDP" class="headerlink" title="一、UDP"></a>一、UDP</h2><p>UDP（User Datagram Protocol），用户数据包协议，是一个简单的<strong>面向数据报的通信协议</strong>，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层</p>
<p>也就是说无论应用层交给<code>UDP</code>多长的报文，它统统发送，一次发送一个报文</p>
<p>而对接收方，接到后直接去除首部，交给上面的应用层就完成任务</p>
<p><code>UDP</code>报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小</p>
<p><img src="https://static.vue-js.com/928e5d20-b393-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>特点如下：</p>
<ul>
<li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务</li>
<li>传输途中出现丢包，UDP 也不负责重发</li>
<li>当包的到达顺序出现乱序时，UDP没有纠正的功能。</li>
<li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为</li>
</ul>
<h2 id="二、TCP"><a href="#二、TCP" class="headerlink" title="二、TCP"></a>二、TCP</h2><p>TCP（Transmission Control Protocol），传输控制协议，是一种可靠、<strong>面向字节流的通信协议</strong>，把上面应用层交下来的数据看成无结构的字节流来发送</p>
<p>可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小</p>
<p><code>TCP</code>报文首部有20个字节，额外开销大</p>
<p><img src="https://static.vue-js.com/a0010d40-b393-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>特点如下：</p>
<ul>
<li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li>
<li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li>
<li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）</li>
</ul>
<h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p><code>UDP</code>与<code>TCP</code>两者的都位于传输层，如下图所示：</p>
<p><img src="https://static.vue-js.com/a92bda80-b393-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>两者区别如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>可靠性</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>连接性</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>报文</td>
<td>面向字节流</td>
<td>面向报文</td>
</tr>
<tr>
<td>效率</td>
<td>传输效率低</td>
<td>传输效率高</td>
</tr>
<tr>
<td>双共性</td>
<td>全双工</td>
<td>一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td>流量控制</td>
<td>滑动窗口</td>
<td>无</td>
</tr>
<tr>
<td>拥塞控制</td>
<td>慢开始、拥塞避免、快重传、快恢复</td>
<td>无</td>
</tr>
<tr>
<td>传输效率</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody></table>
<ul>
<li>TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取</li>
<li>TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方</li>
<li>TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用</li>
<li>TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信</li>
</ul>
<p>两者应用场景如下图：</p>
<p><img src="https://static.vue-js.com/b6cdd800-b393-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>可以看到，TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/05/13/http/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="cl7icg75y00qhugunaoi1581o" data-title="TCP和UDP的区别" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-http/TCPIP协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/05/11/http/TCPIP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2018-05-11T03:13:48.000Z" itemprop="datePublished">2018-05-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/05/11/http/TCPIP%E5%8D%8F%E8%AE%AE/">TCP/IP协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>TCP&#x2F;IP，<strong>传输控制协议</strong>&#x2F;<strong>网际协议</strong>，是指能够在多个不同网络间实现信息传输的协议簇</p>
<ul>
<li>TCP（传输控制协议）</li>
</ul>
<p>一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<ul>
<li>IP（网际协议）</li>
</ul>
<p>用于封包交换数据网络的协议</p>
<p>TCP&#x2F;IP协议不仅仅指的是<code>TCP</code>和<code>IP</code>两个协议，而是指一个由<code>FTP</code>、<code>SMTP</code>、<code>TCP</code>、<code>UDP</code>、<code>IP</code>等协议构成的协议簇，</p>
<p>只是因为在<code>TCP/IP</code>协议中<code>TCP</code>协议和<code>IP</code>协议最具代表性，所以通称为TCP&#x2F;IP协议族（英语：TCP&#x2F;IP Protocol Suite，或TCP&#x2F;IP Protocols）</p>
<h2 id="二、划分"><a href="#二、划分" class="headerlink" title="二、划分"></a>二、划分</h2><p>TCP&#x2F;IP协议族按层次分别了五层体系或者四层体系</p>
<p>五层体系的协议结构是综合了 OSI 和 TCP&#x2F;IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层</p>
<p>五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层</p>
<p>如下图所示：</p>
<p><img src="https://static.vue-js.com/5bb93610-b647-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<h3 id="五层体系"><a href="#五层体系" class="headerlink" title="五层体系"></a>五层体系</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><code>TCP/IP</code> 模型将 <code>OSI</code>参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务</p>
<p>如：<code>FTP</code>、<code>Telnet</code>、<code>DNS</code>、<code>SMTP</code> 等</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能</p>
<p>传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）</p>
<p>其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机</p>
<p>在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/http/TCP_IP.html#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"></a>数据链路层</h4><p>数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境</p>
<h3 id="四层体系"><a href="#四层体系" class="headerlink" title="四层体系"></a>四层体系</h3><p>TCP&#x2F;IP 的四层结构则如下表所示：</p>
<table>
<thead>
<tr>
<th>层次名称</th>
<th>单位</th>
<th>功 能</th>
<th>协 议</th>
</tr>
</thead>
<tbody><tr>
<td>网络接口层</td>
<td>帧</td>
<td>负责实际数据的传输，对应OSI参考模型的下两层</td>
<td>HDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）</td>
</tr>
<tr>
<td>网络层</td>
<td>数据报</td>
<td>负责网络间的寻址数据传输，对应OSI参考模型的第三层</td>
<td>IP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）</td>
</tr>
<tr>
<td>传输层</td>
<td>报文段</td>
<td>负责提供可靠的传输服务，对应OSI参考模型的第四层</td>
<td>TCP（控制传输协议） UDP（用户数据报协议）</td>
</tr>
<tr>
<td>应用层</td>
<td></td>
<td>负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层</td>
<td>FTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）</td>
</tr>
</tbody></table>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>OSI 参考模型与 TCP&#x2F;IP 参考模型区别如下：</p>
<p>相同点：</p>
<ul>
<li>OSI 参考模型与 TCP&#x2F;IP 参考模型都采用了层次结构</li>
<li>都能够提供面向连接和无连接两种通信服务机制</li>
</ul>
<p>不同点：</p>
<ul>
<li>OSI 采用的七层模型； TCP&#x2F;IP 是四层或五层结构</li>
<li>TCP&#x2F;IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分</li>
<li>OSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP&#x2F;IP 参考模型作为一种简化的分层结构是可以的</li>
<li>TCP&#x2F;IP协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 <code>OSI</code> 设想中的应用程序维度的分层是无法实现的</li>
</ul>
<p>三种模型对应关系如下图所示：</p>
<p><img src="https://static.vue-js.com/3fbff4d0-b647-11eb-ab90-d9ae814b240d.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/05/11/http/TCPIP%E5%8D%8F%E8%AE%AE/" data-id="cl7icg75x00q8ugunf1uq7gmk" data-title="TCP/IP协议" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/14/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/16/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/liunx/">liunx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">问题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/">框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/">算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">架构模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%A1%86%E6%9E%B6/">框架</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mock/" rel="tag">Mock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/async-await/" rel="tag">async&#x2F;await</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echart/" rel="tag">echart</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/" rel="tag">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/" rel="tag">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glup/" rel="tag">glup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/" rel="tag">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vs-code/" rel="tag">vs code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue3/" rel="tag">vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml/" rel="tag">xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" rel="tag">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mock/" style="font-size: 10px;">Mock</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/React/" style="font-size: 19.17px;">React</a> <a href="/tags/Redux/" style="font-size: 11.67px;">Redux</a> <a href="/tags/async-await/" style="font-size: 10px;">async/await</a> <a href="/tags/css/" style="font-size: 11.67px;">css</a> <a href="/tags/echart/" style="font-size: 10px;">echart</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/git/" style="font-size: 16.67px;">git</a> <a href="/tags/glup/" style="font-size: 10.83px;">glup</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/http/" style="font-size: 17.5px;">http</a> <a href="/tags/javascript/" style="font-size: 18.33px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10.83px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 13.33px;">nodejs</a> <a href="/tags/python/" style="font-size: 10.83px;">python</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/typescript/" style="font-size: 12.5px;">typescript</a> <a href="/tags/vs-code/" style="font-size: 11.67px;">vs code</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/vue3/" style="font-size: 10px;">vue3</a> <a href="/tags/webpack/" style="font-size: 19.17px;">webpack</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 14.17px;">优化</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10.83px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15.83px;">小程序</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" style="font-size: 10.83px;">移动端</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10.83px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/25/Js%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">变量类型</a>
          </li>
        
          <li>
            <a href="/2022/04/25/http/DNS%E5%8D%8F%E8%AE%AE/">DNS协议</a>
          </li>
        
          <li>
            <a href="/2022/01/18/React/React-%E6%8F%90%E9%AB%98%E7%BB%84%E4%BB%B6%E6%95%88%E7%8E%87%20%20%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84render/">React-提高组件效率  避免不必要的render</a>
          </li>
        
          <li>
            <a href="/2022/01/12/%E5%B7%A5%E5%85%B7/git-stach/">git-stach</a>
          </li>
        
          <li>
            <a href="/2021/10/16/Vue/vue3%E4%BC%98%E5%8C%96/">vue3优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>