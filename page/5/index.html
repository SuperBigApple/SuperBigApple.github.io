<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="John Doe">
    
    
    
    
    
    
    <title>Hexo</title>
    <!-- inject:style -->
    <link href="/css/style.css" rel="stylesheet" type="text/css">
    <!-- endinject -->
    <style>
        .cube-loading {
            top: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('/images/lg/loading.gif') no-repeat center center;
            background-color: rgba(0,0,0,.7);
        }

        .cube-loading.out {
            display: none;
        }

        .cube-loading:before {
            display: block;
            content: 'Loading';
            position: relative;
            width: 100%;
            top: 50%;
            right: -50%;
            color: #fff;
        }

        @media(max-width: 768px) {
            .cube-loading:before {
                font-size: 1.2em;
                transform: translate(-24px,20px);
                -webkit-transform: translate(-24px,20px);
                -o-transform: translate(-24px,20px);
                -ms-transform: translate(-24px,20px);
            }
        }

        @media(min-width: 768px) {
            .cube-loading:before {

            }
        }
    </style>
    
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
<div class="cube-body">
    <nav id="cube-top-memu" class="cube-menu">
    <ul class="cube-menu-collapse">
        
        <li>
            <i class="cube-icon cube-icon-home" aria-hidden="true"></i>
            <a href="/">首页</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-archive" aria-hidden="true"></i>
            <a href="/archives">归档</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-categories" aria-hidden="true"></i>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-tags" aria-hidden="true"></i>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-about" aria-hidden="true"></i>
            <a href="/about-me">关于我</a>
        </li>
        
    </ul>
</nav>
<nav class="cube-side-menu" id="cube-side-menu">
    <ul class="cube-menu-list">
        
        <li>
            <a class="lrc-control">Open Lyrics</a>
        </li>
        
        <li>
            <a class="scroll-to-top">Top</a>
        </li>
    </ul>
</nav>
    <header class="cube-header" id="cube-header">
    <img src=" https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201502%2F28%2F20150228220759_zaP3N.png&amp;refer=http%3A%2F%2Fb-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664943562&amp;t=f546331d7d5aee27ceb7af09c60899f2 " alt="头部背景图片">
    
    <div class="cube-type">
        <span class="cube-typed-title">🍍的个人博客 ^_^</span>
        <span class="cube-typed-cursor">|</span>
    </div>
    
</header>

    <style>
        nav.cube-menu:before {
            content: '';
            visibility: hidden;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 44px;
        
            filter: blur(5px);
            -webkit-filter: blur(5px);
        
            z-index: -1;
            background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201502%2F28%2F20150228220759_zaP3N.png&amp;refer=http%3A%2F%2Fb-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664943562&amp;t=f546331d7d5aee27ceb7af09c60899f2');
            background-repeat: no-repeat;
            background-position: center -356px;
            background-size: cover;
            background-color: transparent;
        }

        header.cube-background.cube-header-background {
            visibility: hidden;
            background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201502%2F28%2F20150228220759_zaP3N.png&amp;refer=http%3A%2F%2Fb-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664943562&amp;t=f546331d7d5aee27ceb7af09c60899f2');
            background-position: center -400px;
        }
    </style>
    <header class="cube-background cube-header-background">
        
        <div class="cube-type">
            <span class="cube-typed-title">🍍的个人博客 ^_^</span>
            <span class="cube-typed-cursor">|</span>
        </div>
        
    </header>
    <div class="load-header-background"></div>
    <script>
        (function (window) {

            window.headerModule = {}
            window.headerModule.image = {
                width: '2000',
                height: '1414'
            }

        })(window)
    </script>
    
    <div class="cube-content">
        <div class="cube-left">
            
<div class="cube-excerpt" id="cube-excerpt-webpack高级">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/11/28/webpack/webpack%E9%AB%98%E7%BA%A7/">webpack高级</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-11-28
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="webpack高级篇"><a href="#webpack高级篇" class="headerlink" title="webpack高级篇"></a>webpack高级篇</h1><p>完善配置以及常用并强大的工具</p>
<h2 id="一-如何提高开发效率与完善团队开发规范"><a href="#一-如何提高开发效率与完善团队开发规范" class="headerlink" title="一.如何提高开发效率与完善团队开发规范"></a>一.如何提高开发效率与完善团队开发规范</h2><p><strong>source-map</strong><br>debug  将打包好的bundle.js里的报错内容和我们源代码index.js文件进行关联<br>webpack已经内置了source-map的功能   只要我们简单的配置一下就可以开启它了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool:&quot;inline-source-map&quot;  //通过devtool去复制一个值就可以开启 source-map</span><br></pre></td></tr></table></figure>
<p>七种source-map：<br><img src="http://hghqz.vip/webpack/source-map.jpg" alt="source-map" title="source-map"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install webpack webpack-cli webpack-dev-server html-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>eval模式：每个module会封装到eval里包裹起来执行，并且会在末尾追加注释 &#x2F;&#x2F;@sourceURL<br>默认情况下 没有配置source-map  webpack会帮助我们在开发环境下面去设置一个source-map默认值，eval。所以我们在浏览器上才能精准的锁定我们代码的行数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devtool:false      // 关闭source-map   浏览器锁定的是在打包后bundle.js文件中的位置</span><br><span class="line">devtool:&#x27;eval&#x27;</span><br><span class="line">devtool:&#x27;source-map&#x27;    //它可以生成一个SourceMap我文件其他的功能会保持eval的功能</span><br><span class="line">devtool:&#x27;hidden-source-map&#x27;  //和source-map一样，但不会在bundle末尾追加注释      那么就不能有锁定代码行数了   但是它会生成一个.map文件  连着不关联了</span><br><span class="line">devtool:&#x27;inline-source-map&#x27;   //生成一个DataUrl形式的SourceMap文件  没有map文件了  指向data64格式</span><br><span class="line">devtool:&#x27;eval-source-map&#x27;   // 每个module会通过eval()来执行，并且生成一个DataUrl形式的SourceMap</span><br><span class="line">devtool:&#x27;cheap-source-map&#x27;   // 它会生成一个没有列信息的SourceMaps文件，不包含loader的sourcemap    只保留代码的行数不去记录代码的列数    可以减少生成的map文件的大小</span><br><span class="line">devtool:&#x27;cheap-module-source-map&#x27; //生成一个没有列信息的SourceMaps文件，同时loader的sourcemap也被简化为只包含对应行的信息。       **推荐使用**</span><br></pre></td></tr></table></figure>

<p><strong>devServer</strong><br>在开发环境下我们往往要启动一个web服务，方便我们模拟一个用户从浏览器中访问我们的web服务，读取我们的打包产物，以观测我们的代码在客户端的表现。webpack内置了这样的功能，我们只需要简单的配置就可以开启它了。<br>npm install webpack-dev-server -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">//为了在浏览器看到效果配置插件</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">devServer:&#123;</span><br><span class="line">	static: path.resolve(__dirname,&#x27;./dist&#x27;)  // 指向我们当前服务的物理路径</span><br><span class="line">	compress:true  // 可以设置我们是不是在服务器端进行代码压缩 使他在传输过程中可以减少传输的这个数据的大小浏览器请求头   Content-Encoding:gzip  保证我们从服务器到浏览器传输的过程中这个文件是压缩的。从而提高我们的传输效率。</span><br><span class="line">	port :3000  //  配置端口号</span><br><span class="line">	// 添加响应头 在有些场景需求下，我们需要通过http传输给我们浏览器，为所有响应添加headers，来对资源的请求和响应打入标志，以便做一些安全规范，或者方便发生异常后做请求的链路追踪</span><br><span class="line">	headers:&#123;</span><br><span class="line">		&#x27;X-Access-token&#x27;:&#x27;啊师傅撒大附件是辣的回复&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">	//开启代理，在我们打包出来的js bundle里有时会含有一些对特定接口的网络请求(ajax/fetch),比如：我们的客户端地址实在http://localhost:3000下，加入我们的接口来自http://localhost:4001/,那么毫无疑问，此时的控制台会报错来提示你跨域。  解决：在开发环境下，我们可以使用devServer自带的proxy功能。</span><br><span class="line">	const http = require(&#x27;http&#x27;)</span><br><span class="line">	cosnt app = http.createServer((request,response)=&gt;&#123;</span><br><span class="line">		if (request.url===&#x27;/api/hello&#x27;)&#123;</span><br><span class="line">			response.end(&#x27;hello mode&#x27;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;) 创建服务</span><br><span class="line">	app.listen(9000，&#x27;服务器的名字域名localhost可以省略&#x27;,()=&gt;&#123;</span><br><span class="line">		console.log(&#x27;提醒用户  9000端口开放&#x27;)</span><br><span class="line">	&#125;)  //监听app</span><br><span class="line">	node server.js启动服务</span><br><span class="line">	fetch(&#x27;/api/hello&#x27;) //返回一个promise</span><br><span class="line">	.then(response=&gt;response.text) // 将返回内容变成一个文本</span><br><span class="line">	.then(reuslt=&gt;&#123;</span><br><span class="line">		console.log(&#x27;result&#x27;)</span><br><span class="line">	&#125;)</span><br><span class="line">	peoxy解决跨域</span><br><span class="line">	proxy:&#123;  //proxy对象 里边可以写很多的所谓的访问的路径（暗号）</span><br><span class="line">		&#x27;/api&#x27;:&#x27;http://localhost:9000&#x27;  //当用户请求资源为/api时  把它指向到一个新的服务器上去</span><br><span class="line">	&#125;</span><br><span class="line">	//  https配置  我们在本地访问时将http变为https</span><br><span class="line">	https:true   //由于默认配置使用的时自签名证书  所以有得浏览器会告诉你时不安全的，但我们依然可以继续访问它。当然我们也可以提供自己的证书</span><br><span class="line">	https:&#123;</span><br><span class="line">		cacert:&quot;./server.pem&quot;,</span><br><span class="line">		pfx:&quot;./server.pfx&quot;,</span><br><span class="line">		key:&quot;./server.key&quot;,</span><br><span class="line">		cert:&#x27;./server.crt&#x27;,</span><br><span class="line">		passphrase:&quot;webpack-dev-server&quot;,</span><br><span class="line">		requestCert:true</span><br><span class="line">	&#125;</span><br><span class="line">	// http2 自带https的自签名证书  仍然可以通过https来访问我们的项目</span><br><span class="line">	http2:true</span><br><span class="line">	// historyApiFallback  如果我们的应用是个SPA（单页面应用），但路由到/some时（可以直接在地址栏里输入），会发现此时刷新页面后，控制台会报错。  原因：浏览器把这个路由当作了静态资源地址去请求，然后我们并没有打包出/some这样的资源，所以这个访问时404。  解决：可以通过配置来提供页面代替任何404的静态资源。</span><br><span class="line">	historyApiFallback:true</span><br><span class="line">	// 此时重启服务刷新后发现请求变成了index.html。当然，在多数业务场景下，我们需要根据不同的访问路径定制替代的页面，  可以使用rewrites这个配置项</span><br><span class="line">	historyApiFallback:&#123;</span><br><span class="line">		rewrites:[</span><br><span class="line">			&#123;form:/^\/$/,to:&#x27;asd.html&#x27;&#125;,  //正则获取路径</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">	//开发服务器主机   如果你在开发环境中起了一个devserver服务，并期望你的同事能访问它，</span><br><span class="line">	devServer:&#123;</span><br><span class="line">		host:0.0.0.0</span><br><span class="line">	&#125;//这是如果你的同事和你处于一个局域网的话，就可以通过局域网ip来访问你的服务了</span><br><span class="line">&#125;</span><br><span class="line">plugins:[</span><br><span class="line">	new HtmlWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>模块热替换与热加载</strong><br>模块热替换：(HMR - hot module replacement)功能会在应用程序运行过程中，替换 添加或删除 模块，而无需重新加载整个页面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">	hot:true</span><br><span class="line">&#125;</span><br><span class="line">if (module.hot)&#123;</span><br><span class="line">	module.hot.accept(&#x27;./input.js&#x27;,()=&gt;&#123;</span><br><span class="line">		console.log(123)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">//css并不需要做这个开关  是因为css-loader已经帮助我们完成这个工作了</span><br></pre></td></tr></table></figure>
<p>热加载（文件更新时，自动刷新我们的服务和页面）新版的webpack-dev-server默认开启热加载的功能，它对应的参数是devServer.liveReload ,默认为true。  如果想要关掉它,liveReload这是为false同时也要关掉hot</p>
<p><strong>Eslint</strong><br>eslint是用来扫描我们所写的代码是否符合规范的工具，往往我们的项目是多人协作开发的，我们期望同一的代码规范，这时候可以让eslint来对我们进行约束。严格意义上来说，eslint配置跟webpack无关，但在工程化环境中，它往往是不可或缺的。<br>npx exlint –init<br>会给我们三个选项（说明我们在使用的时候用那种方式）：1.仅仅检查语法错误，2.不但可以检查语法而且还可以发现问题，3.既可以检查语法，发现问题，还可以规范我们代码的格式。<br>之后是问我们在项目中到底使用那种模块化的开发方式：   es6  commonJS  什么都不用<br>我们在项目中使用的是那种框架：React  Vue.js  没有使用   第三篇讲解webpack如何与react  vue进行合作<br>项目中是否使用ts<br>代码是运行在哪里的   browser浏览器  还是node后端<br>在项目中到底如何去配置代码规范   1.选择一些流行的代码格式（使用第一个）， 2.实现一问一答的方式来配置，3.导入一个我们自有的文件<br>配置文件放在什么地方  javascript  yaml   json<br>生成.eslintrc.json文件<br><img src="http://hghqz.vip/webpack/exlint%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.jpg" alt="exlint配置选项" title="exlint配置选项"><br>env：脚本的运行环境<br>extends  ：检查代码格式的文件<br>parserOptions ： 指定ecmaVersion的版本  sourceType：module<br>rules：启用规则以及各自的错误级<br>globals：可以在执行脚本的期间访问一些额外的全局变量，这些全局变量是不在环境中定义的变量。<br>npx eslint 文件夹或文件<br>使用vscode 的eslint插件  就会告诉我们哪里不符合规范 出现了问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;rules&quot;:&#123;</span><br><span class="line">		&quot;no-console&quot;:0, //关闭no-console提示</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合webpack来实现eslint<br>我们期望eslint能够实时提示报错而不必等待执行命令，这个功能可以通过给自己的IDE（代码编辑器）安装对应的eslint插件来实现，然而，不是每个IDE都有插件，如果不想使用插件，又想实现实时提示报错，那么我们可以结合webpack的打包编译功能来实现。<br>在打包js文件之前，通过eslint-loader以及babel-loader来进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">	client:&#123;</span><br><span class="line">		overlay:false,   // 浏览器不在有覆盖层eslint错误提示</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">module:&#123;</span><br><span class="line">	rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:/\.js$/,</span><br><span class="line">			use:[&#x27;babel-loader&#x27;,&#x27;eslint-loader&#x27;]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>git-hooks与husky</strong><br>为了保证团队里的开发人员提交的代码符合规范，我们可以在开发者上传代码的时候进行校验。我们常用husky来协助进行代码提交时的eslint校验。在使用husky前，我们先来研究一下git-hooks.<br>husky时基于git-hooks git的钩子来实现的</p>
<p>git –version<br>git init<br>ls -la<br>.gitignore  在git提交时有一些文件不需要提交<br>**&#x2F;node_modules<br>git status  查看当前git的状态   可以看到文件都没有进行本地的仓库的添加的            可以查看到修改了那些文件<br>git add . 添加到缓存区   git commit -m ‘init’  所有代码添加到了本地仓库   并没有关联远端的仓库<br>cd .git  ls -la   cd hooks  ls -la<br>.sample的扩展名文件，这些文件都是git的hooks    hook就是我们在执行命令的时候需要提前或者之后去执行的一些命令这些命令时自动执行的   只要配置好   git会帮助我们运行。<br>需求：在每次git提交的时候来检查代码的问题。   可以运行eslint  钩子可以采用pre-commit-sample<br>cat pre-commit-sample   浏览文件   如果想要指定它或者时让他生效我们可以修改文件名  .sample是不能起作用的我们想要起作用必须重新创建一个文件pre-commit<br>touch  pre-commit   这个文件我们就可以事先写一写shell脚本  当commit实行的时候这些脚本就会被提前运行<br>vim pre&#x3D;commit       &#x2F;&#x2F;编辑这个文件   i进行输入  echo pre-commit   esc退出  :wq<br>修改文件的读写权限  chmod +x .&#x2F;pre-commit   &#x2F;&#x2F;添加写权限<br>脚本  ：  d+d删除当前行  i（insert）插入   npx eslint .&#x2F;src<br>在团队开发时不对代码做任何处理    只有在我们代码提交到git仓库时在进行校验<br>问题：如果把git的配置放在.git文件夹里那个文件夹每个人的配置都是不一样的   也没有办法把配置放到git仓库里   那我们需要把这个配置放置到项目的根目录下<br>文件以.开头表示这个文件是隐藏的<br>.mygithooks  .pre-commit   希望我们在git提交的时候读取的不是我们在git默认的hooks里面配置的pre-commit 而是读取我们项目中的pre-commit   通过git配置实现   git config core.hooksPash .mygithooks  会自动读取文件夹中约定好的pre-commit这个文件名<br>vim .git&#x2F;config   &#x2F;&#x2F;查看我们刚才通过命令行添加的命令<br>chmod +x .mygithooks&#x2F;pre-commit   ls -la查看文件权限<br>现在都是通过手工去完成的    我们可以通过现成的工具(husky)来完成<br>vim .git&#x2F;config   删除刚才的配置<br>npm install husky -D<br>npx husky install &#x2F;&#x2F;执行  让我们的命令行hook生效   会在当天目录下面创建.husky文件夹<br>自己配置一个脚本 “prepare” : husky install  它会实现到我们的一些命令执行之前去安装我们的husky<br>npx husky add .husky&#x2F;per-commit 在.husky下创建pre-commit文件   npx eslint .&#x2F;src<br>添加权限</p>
<h2 id="二-模块与依赖"><a href="#二-模块与依赖" class="headerlink" title="二.模块与依赖"></a>二.模块与依赖</h2><p>在模块化的编程中  开发者会将程序分解为功能离散的一些文件   我们把这些文件称之为模块  每个模块都很轻量  这使得我们项目的验证  调试以及测试会变得轻而易举。  这些精心编写得模块提供了可靠的抽象和封装界限。使得我们应用程序的每个模块都具备了调理清晰的设计和明确的目的。<br>nodejs从一开始就支持模块化的编程  但是浏览器端的模块化还在缓慢的支持中。大多数浏览器支持esm模块化。<br>能在webpack工程化的环境里成功导入的模块都应该视做为webpack模块。与nodejs项目webpack模块能以各种方式来表达它的利害关系。<br>es6 import from          nodejs  module  require              AMD   define  require<br>css,scss,less,assets这些文件里的@import语句     和样式里的url资源  这些都是webpack应用的模块<br>webpack模块解析简易原理：webpack将js,css,less,scss,img,html等文件  通过loader+module(内置模块)  的方法解析成模块化的文件。<br>这个打包编译的解析过程是怎么完成的：webpack执行会返回一个描述webpack打包编译的整个流程的一个对象我们将这个对象称之为compiler,compiler对象描述的是整个webpack打包的流程，它内置打包状态，随着打包过程的进行  状态也实施的发生变化。同时会触发相应状态的webpack生命周期钩子，我们可以将它类比成一个promise对象，这个状态从打包前，打包中到打包完成或者打包失败都是通过这个过程完成的，每一个webpack打包都是创建一个compiler对象，它会走完整个声明周期的过程。而webpack中所有的模块解析都是compiler对象内置模块的解析器去做的，通过这个对象的属性resolvers解析器主题主题功能就是解析模块它是基于enhanced-resolve这个包来实现的，在webpack中无论使用怎样的模块引用语句本质其实都是调用这个包的api来进行模块的构建解析的</p>
<p><strong>模块解析(resolve)</strong><br>webpack是通过Resolves实现了模块之间的依赖和引用。在打包的时候，webpack使用enhanced-resolve来解析文件路径（webpack_resolver的代码实现很有思想，webpack基于次进行treeshaking。）<br>webpack可以解析三种文件路径：1.绝对路径（相对于项目的根目录&#x2F;）    2.相对路径（相对于当前文件.&#x2F;）    3.模块路径（全局的node_modules文件）(不用&#x2F;  或  .&#x2F;它会自动到node_modules中找模块)<br>可以给某个路径或某个文件夹下的目录去起个别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">resolve:&#123;</span><br><span class="line">	alias:&#123;</span><br><span class="line">		&#x27;@&#x27;: path.resulve(__dirname,&#x27;./src&#x27;)   // @指向src目录</span><br><span class="line">	&#125;,</span><br><span class="line">	extensions: [&#x27;.json&#x27;,&#x27;js&#x27;,&#x27;.vue&#x27;]   //优先请求 .json的后缀。(不配置该选项默认请求.js)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>外部扩展(Externals)</strong><br>有时候我们会为了减小bundle的体积，从而把一些不变的第三方库用cdn的形式引入进来，比如jquery：index.html。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">externalsType:&#x27;script&#x27;,</span><br><span class="line">externals:&#123;   //他是一个对象   可以去定义我们的外部一些第三方包</span><br><span class="line">	jquery:&#x27;jQuery($)&#x27;      //key 的名字一定要和  其他地方引用的报名一样，值是我们在window对象上面去暴露的一个对象        // 无法正常运行  jquery没有定义    需要在index.html收到导入script标签</span><br><span class="line">	jquery:[</span><br><span class="line">		&#x27;cdn地址&#x27;,   //jquery  script标签  将来要放到的页面的连接</span><br><span class="line">		&#x27;jQuery($)&#x27;   //表示  这个script在浏览器上面暴露的一个对象</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>依赖图(dependency graph)</strong><br>每当一个文件依赖另一个文件时，webpack会直接将文件视为存在依赖关系。这使得webpack可以获取非代码资源，如image或web字体等，并会把他们作为 依赖 提供给应用程序，当webpack开始工作时，它会根据我们写好的配置，从 入口（entry）开始，webpack会递归的构建一个 依赖关系图，这个依赖关系图包含着应用程序中所需的每个模块，然后将所有模块打包为bundle(也就是output配置项)<br>单纯将可能很抽象，我们更期望能够可视化打包产物的依赖图，  bundle分析工具：<br>官网分析工具   第三方工具：webpack-chart   webpack-visualizer    webpack-bundle-analyzer    webpack bundle  optimize helper       bundle-stats<br><img src="http://hghqz.vip/webpack/bundle%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7.jpg" alt="bundle分析工具" title="bundle分析工具"><br>npm install webpack-bundle-analyzer -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const &#123; BundleAnalyzerPlugin &#125; = require(&#x27;webpack-bundle-analyzer&#x27;)</span><br><span class="line">plugins:&#123;</span><br><span class="line">	new BundleAnalyzerPlugin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-扩展功能"><a href="#三-扩展功能" class="headerlink" title="三.扩展功能"></a>三.扩展功能</h2><p>PostCSS和css模块，Web Works,Typescript<br><img src="http://hghqz.vip/webpack/PostCSs%E4%B8%8Ecss%E6%A8%A1%E5%9D%97.jpg" alt="PostCSS与css模块" title="PostCSS与css模块"></p>
<p>postcss : 1.可以给样式添加前缀兼容浏览器   2.可以在样式里书写一些关于嵌套的功能  它可以编译成浏览器能够识别的样式。<br>css模块：解决页面class引用次数多，或引用别人的样式 名重复，可以使用css模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader -D</span><br><span class="line">npm install autoprefixer -D   //帮助我们去加载一些样式的前缀</span><br><span class="line">webpack.config.js</span><br><span class="line">module:&#123;</span><br><span class="line">	rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:/\.css$/,</span><br><span class="line">			use:[</span><br><span class="line">				&#x27;style-loader&#x27;,</span><br><span class="line">				&#x27;css-loader&#x27;,</span><br><span class="line">				&#x27;postcss-loader&#x27;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">postcss.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	plugins:[</span><br><span class="line">		require(&#x27;autoprefixer&#x27;),</span><br><span class="line">		require(&#x27;postcss-nested&#x27;)   //嵌套</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">package.json</span><br><span class="line">&quot;browerlist&quot;:[</span><br><span class="line">	&quot;&gt;1%&quot;,   //应用在全球浏览器大于1%的浏览器上</span><br><span class="line">	&quot;last 2 versions&quot;  //每个浏览器的最新的两个版本</span><br><span class="line">]</span><br><span class="line">// css模块实现</span><br><span class="line">rules:[</span><br><span class="line">	&#123;</span><br><span class="line">		test:/\.css$/,</span><br><span class="line">		use:[</span><br><span class="line">			&#x27;tyle-loader&#x27;,</span><br><span class="line">			&#123;</span><br><span class="line">				loader:&#x27;css-loader&#x27;,</span><br><span class="line">				options:&#123;</span><br><span class="line">					modules:true        //开启css模块</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#x27;postcss-loader&#x27;,</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//获取hash字符串  将css文件当成一个模块</span><br><span class="line">import style from &#x27;./asasd.css&#x27;</span><br><span class="line">console.log(style)</span><br><span class="line">样式为：style.class名</span><br><span class="line">配置部分开启css模块  css module模式  ，全局样式.global不开启css模块 不同模式。</span><br><span class="line"></span><br><span class="line">// css module</span><br><span class="line">&#123;</span><br><span class="line"> test: new RegExp(`^(?!.*\\.global).*\\.css`),</span><br><span class="line"> use: [</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;style-loader&#x27;</span><br><span class="line"> &#125;，</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;css-loader&#x27;,</span><br><span class="line">   options: &#123;</span><br><span class="line">    modules: true,</span><br><span class="line">    localIdentName: &#x27;[hash:base64:6]&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;postcss-loader&#x27;</span><br><span class="line"> &#125;</span><br><span class="line">],</span><br><span class="line"> exclude:[path.resolve(__dirname, &#x27;..&#x27;, &#x27;node_modules&#x27;)]</span><br><span class="line">&#125;</span><br><span class="line">// 普通模式</span><br><span class="line">&#123;</span><br><span class="line"> test: new RegExp(`^(.*\\.global).*\\.css`),</span><br><span class="line"> use: [</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;style-loader&#x27;</span><br><span class="line"> &#125;，</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;css-loader&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;postcss-loader&#x27;</span><br><span class="line"> &#125;</span><br><span class="line">],</span><br><span class="line"> exclude:[path.resolve(__dirname, &#x27;..&#x27;, &#x27;node_modules&#x27;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Web Works</strong><br>有时我们需要在客户端进行大量的运算，但又不想让它阻塞我们的js主线程。你可能<br>第一时间考虑到的是异步。<br>但事实上，运算量过大(执行时间过长)的异步也会阻塞js事件循环，甚至会导致浏览<br>器假死状态。<br>这时候，HTML5的新特性 WebWorker就派上了用场。<br>在此之前，我们简单的了解下这个特性。<br>html5之前，打开一个常规的网页，浏览器会启用几个线程？<br>一般而言，至少存在三个线程(公用线程不计入在内):<br>分别是js引擎线程(处理js)、GUI渲染线程(渲染页面)、浏览器事件触发线程(控制交<br>互)。<br>当一段JS脚本长时间占用着处理机,就会挂起浏览器的GUI更新，而后面的事件响应也<br>被排在队列中得不到处理，从而造成了浏览器被锁定进入假死状态。<br>现在如果遇到了这种情况，我们可以做的不仅仅是优化代码————html5提供了解<br>决方案，webworker。<br>webWorkers提供了js的后台处理线程的API，它允许将复杂耗时的单纯js逻辑处理放<br>在浏览器后台线程中进行处理，让js线程不阻塞UI线程的渲染。<br>多个线程间也是可以通过相同的方法进行数据传递。<br>它的使用方式如下：<br>也就是说，需要单独写一个js脚本，然后使用new Worker来创建一个Work线程实<br>例。<br>这意味着并不是将这个脚本当做一个模块引入进来，而是单独开一个线程去执行这个<br>脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   loader: &#x27;css-loader&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;postcss-loader&#x27;</span><br><span class="line"> &#125;</span><br><span class="line">],</span><br><span class="line"> exclude:[path.resolve(__dirname, &#x27;..&#x27;, &#x27;node_modules&#x27;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;new Worker(scriptURL: string | URL, options?: WorkerOptions)<br>new Worker(“someWorker.js”);</p>
<p>我们知道，常规模式下，我们的webpack工程化环境只会打包出一个bundle.js，那<br>我们的worker脚本怎么办？<br>也许你会想到设置多入口(Entry)多出口(ouotput)的方式。<br>事实上不需要那么麻烦，webpack4的时候就提供了worker-loader专门配置<br>webWorker。<br>令人开心的是，webpack5之后就不需要用loader啦，因为webpack5内置了这个功<br>能。<br>我们来试验一下：<br>第一步<br>创建一个work脚本 work.js,我们甚至不需要写任何内容，我们的重点不是<br>webWorker的使用，而是在webpack环境中使用这个特性。<br>当然，也可以写点什么，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.onmessage = (&#123; data: &#123; question &#125; &#125;) =&gt; &#123;</span><br><span class="line"> self.postMessage(&#123;</span><br><span class="line">  answer: 42,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 index.js 中使用它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 下面的代码属于业务逻辑</span><br><span class="line">const worker = new Worker(new URL(&#x27;./work.js&#x27;, import.meta.url));</span><br><span class="line">worker.postMessage(&#123;</span><br><span class="line"> question:</span><br><span class="line">  &#x27;hi，那边的workder线程，请告诉我今天的幸运数字是多少？&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line">worker.onmessage = (&#123; data: &#123; answer &#125; &#125;) =&gt; &#123;</span><br><span class="line"> console.log(answer);</span><br><span class="line">&#125;;</span><br><span class="line">千</span><br></pre></td></tr></table></figure>
<p>(import.meta.url这个参数能够锁定我们当前的这个模块——注意，它不能在<br>commonjs中使用。)<br>这时候我们执行打包命令，会发现,dist目录下除了bundle.js之外，还有另外一个<br>xxx.bundle.js!<br>这说明我们的webpack5自动的将被new Work使用的脚本单独打出了一个bundle。<br>我们加上刚才的问答代码，执行npm run dev，发现它是能够正常工作。<br>并且在network里也可以发现多了一个src_worker_js.bundle.js。<br>总结：<br>webpack5以来内置了很多功能，让我们不需要过多的配置，比如之前讲过的hot模<br>式，和现在的web workder。</p>
<p><strong>Typescript</strong></p>
<p>在前端生态里，TS扮演着越来越重要的角色。<br>我们直入正题，讲下如何在webpack工程化环境中集成TS。<br>首先，当然是安装我们的ts和对应的loader。<br>npm install –save-dev typescript ts-loader</p>
<p>接下来我们需要在项目根目录下添加一个ts的配置文件————tsconfig.json，我们<br>可以用ts自带的工具来自动化生成它。<br>npx tsc –init<br>我们发现生成了一个tsconfig.json，里面注释掉了绝大多数配置。<br>现在，根据我们想要的效果来打开对应的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;compilerOptions&quot;: &#123;</span><br><span class="line">  &quot;outDir&quot;: &quot;./dist/&quot;,</span><br><span class="line">  &quot;noImplicitAny&quot;: true,</span><br><span class="line">  &quot;sourceMap&quot;: true,</span><br><span class="line">  &quot;module&quot;: &quot;es6&quot;,</span><br><span class="line">  &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">  &quot;jsx&quot;: &quot;react&quot;,</span><br><span class="line">  &quot;allowJs&quot;: true,</span><br><span class="line">  &quot;moduleResolution&quot;: &quot;node&quot; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> const path = require(&#x27;path&#x27;);</span><br><span class="line"> module.exports = &#123;</span><br><span class="line"> entry: &#x27;./src/index.ts&#x27;,</span><br><span class="line"> devtool: &#x27;inline-source-map&#x27;,</span><br><span class="line">千</span><br></pre></td></tr></table></figure>
<p>好了，接下来我们新增一个src&#x2F;index.ts，内置一些内容。<br>然后我们别忘了更改我们的entry及配置对应的loder。<br>当然，还有resolve.extensions，将.ts放在.js之前，这样它会先找.ts。<br>注意，如果我们使用了sourceMap，一定记得和上面的ts配置一样，设置<br>sourcemap为true。<br>也别忘记在我们的webpack.config.js里，添加sourcemap,就像我们之前课程里讲的<br>那样。<br>更改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"> module.exports = &#123;</span><br><span class="line"> entry: &#x27;./src/index.ts&#x27;,</span><br><span class="line"> devtool: &#x27;inline-source-map&#x27;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">   rules: [</span><br><span class="line">   &#123;</span><br><span class="line">     test: /\.(ts|tsx)$/,</span><br><span class="line">     use: &#x27;ts-loader&#x27;,</span><br><span class="line">     exclude: /node_modules/,</span><br><span class="line">   &#125;,</span><br><span class="line">  ],</span><br><span class="line"> &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">   extensions: [ &#x27;.tsx&#x27;, &#x27;.ts&#x27;, &#x27;.js&#x27; ],</span><br><span class="line"> &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">   filename: &#x27;bundle.js&#x27;,</span><br><span class="line">   path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行我们的项目，我们发现完全没有问题呢！<br>使用第三方类库<br>在从 npm 上安装第三方库时，一定要记得同时安装这个库的类型声明文件(typing<br>definition)。<br>我们可以从 TypeSearch中找到并安装这些第三方库的类型声明文件(<a target="_blank" rel="noopener" href="https://www.ty/">https://www.ty</a><br>pescriptlang.org&#x2F;dt&#x2F;search?search&#x3D;) 。<br>举个例子，如果想安装 lodash 类型声明文件，我们可以运行下面的命令：<br>npm install –save-dev @types&#x2F;lodash</p>
<p>eslint &amp; ts<br>注意，如果要使用eslint，使用初始化命令的时候，记得选择“使用了typesctipt”。<br>如果已经配置了eslint，但没有配置ts相关的配置，那么我们需要先安装对应的<br>plugin<br>注意如果需要用到react的话，记得也要安装</p>
<p>yarn add -D  @typescript-eslint&#x2F;eslint-plugin@latest</p>
<p>vue或者其他常用框架同样如此，一般都会有专门的plugin。<br>然后我们队.esilntrc进行更改~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    &quot;browser&quot;: true,</span><br><span class="line">    &quot;es2021&quot;: true</span><br><span class="line"> &#125;,</span><br><span class="line">  &quot;extends&quot;: [</span><br><span class="line">    &quot;eslint:recommended&quot;, // 如果需要react的话</span><br><span class="line">    &quot;plugin:react/recommended&quot;,</span><br><span class="line">    &quot;plugin:@typescript-eslint/recommended&quot;</span><br><span class="line"> ],</span><br><span class="line">  &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,</span><br><span class="line">  &quot;parserOptions&quot;: &#123;</span><br><span class="line">    &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">      &quot;jsx&quot;: true</span><br><span class="line">   &#125;, // 如果需要react的话</span><br><span class="line">    &quot;ecmaVersion&quot;: 13,</span><br><span class="line">    &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line"> &#125;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;react&quot;,</span><br><span class="line">    &quot;@typescript-eslint&quot;</span><br><span class="line"> ],</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">   // ...一些自定义的rules</span><br><span class="line">    &quot;no-console&quot;: &quot;error&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行npm run eslint试一下！</p>
<h2 id="四-多页面应用"><a href="#四-多页面应用" class="headerlink" title="四.多页面应用"></a>四.多页面应用</h2><p><strong>entry配置</strong><br>在实际项目的开发中一个完整的系统不会将所有的功能都放在一个网页上，因为这样会导致网页的性能不佳，实际可以按照功能模块划分多个单页应用每个单页应用又生处一个html文件并且随着业务的发展更多的单页应用可以被逐渐的加入到这个项目里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">entry: [&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;，&#x27;node_modules里的模块 lodash&#x27;],</span><br><span class="line">entry:&#123;</span><br><span class="line">	main:[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],    //这里使用lodash  还会打包在这里打包一遍</span><br><span class="line">	lodash:&#x27;lodash&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">entry:&#123;</span><br><span class="line">	main:&#123;</span><br><span class="line">	import :[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],  //这两个文件可能依赖于lodash，而lodash单独打包了，所以dependOn这个依赖可以把公共的lodash给抽离出来            lodash  就不会在打包一遍了</span><br><span class="line">	dependOn:&#x27;lodash&#x27;,           // 做依赖  这里的lodash  是下面的对应名  可以随意起</span><br><span class="line">	&#125;,    //这里使用lodash  还会打包在这里打包一遍</span><br><span class="line">	lodash:&#x27;lodash&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。<br>描述入口的对象：<br>用于描述入口的对象。你可以使用如下属性：<br>dependOn : 当前入口所依赖的入口。它们必须在该入口被加载前被加载。<br>filename : 指定要输出的文件名称。<br>import : 启动时需加载的模块。<br>library : 指定 library 选项，为当前 entry 构建一个 library。<br>runtime : 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时<br>chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时<br>chunk。<br>publicPath : 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共<br>URL 地址。请查看 output.publicPath。<br>webpack.config.js<br>runtime 和 dependOn 不应在同一个入口上同时使用，所以如下配置无效，并且会<br>抛出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a2: &#x27;dependingfile.js&#x27;,</span><br><span class="line">  b2: &#123;</span><br><span class="line">   dependOn: &#x27;a2&#x27;,</span><br><span class="line">   import: &#x27;./src/app.js&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a2: &#x27;./a&#x27;,</span><br><span class="line">  b2: &#123;</span><br><span class="line">   runtime: &#x27;x2&#x27;,</span><br><span class="line">   dependOn: &#x27;a2&#x27;,</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>确保 runtime 不能指向已存在的入口名称，例如下面配置会抛出一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a1: &#x27;./a&#x27;,</span><br><span class="line">  b1: &#123;</span><br><span class="line">   runtime: &#x27;a1&#x27;,</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外 dependOn 不能是循环引用的，下面的例子也会出现错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a3: &#123;</span><br><span class="line">   import: &#x27;./a&#x27;,</span><br><span class="line">   dependOn: &#x27;b3&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">  b3: &#123;</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line">   dependOn: &#x27;a3&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>配置index.html模板</strong><br>要生成多个HTML文件，请在插件数组中多次声明插件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line"> 	main:&#123;</span><br><span class="line">		import :[],</span><br><span class="line">		dependOn:&#x27;lodash2&#x27;,</span><br><span class="line">		filename:&#x27;chanel1.[name].js&#x27;</span><br><span class="line">	&#125;,</span><br><span class="line">	lodash2:&#123;</span><br><span class="line">		import :&#x27;lodash&#x27;,</span><br><span class="line">		filename:&#x27;common/[name].js&#x27;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(), // Generates default index.html</span><br><span class="line">  new HtmlWebpackPlugin(&#123;  // Also generate a test.html</span><br><span class="line">   title:   &#x27;ejs&#x27;,     //在页面可以使用ejs模板语法获取数据</span><br><span class="line">   filename: &#x27;chanel1/test.html&#x27;,                      //执行打包后的页面文件     输出的文件名</span><br><span class="line">   template: &#x27;src/assets/test.html&#x27;       //指定模板的路径</span><br><span class="line">   inject:&#x27;body/head&#x27;,                       // 定义当前所生成的script标签的位置</span><br><span class="line">   chunks:[&#x27;自定义那个入口  如：main.js&#x27;]，              //规定当前页面到底打包那些chunk   如何实现多个页面去载入不同的chunk   chunk就是我们在路口配置的项    每一项就是一个chunk  默认会把所有chunk都放进去</span><br><span class="line">   publicPash:&#x27;http://www.a.com/&#x27;        //包的前缀</span><br><span class="line"> &#125;)</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title  %&gt;&lt;/title&gt;  options.就是我们在HtmlWebpackPlugin定制的选项</span><br><span class="line">index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;/&gt;</span><br><span class="line">  &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>多页面应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  pageOne: &#x27;./src/pageOne/index.js&#x27;,</span><br><span class="line">  pageTwo: &#x27;./src/pageTwo/index.js&#x27;,</span><br><span class="line">  pageThree: &#x27;./src/pageThree/index.js&#x27;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是什么？ 我们告诉 webpack 需要三个独立分离的依赖图（如上面的示例）</p>
<p>为什么？ 在多页面应用程序中，server 会拉取一个新的 HTML 文档给你的客户端。<br>页面重新加载此新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很<br>多事，例如使用 optimization.splitChunks 为页面间共享的应用程序代码创建<br>bundle。由于入口起点数量的增多，多页应用能够复用多个入口起点之间的大量代<br>码&#x2F;模块，从而可以极大地从这些技术中受益。</p>
<h2 id="五-Tree-Shaking"><a href="#五-Tree-Shaking" class="headerlink" title="五.Tree Shaking"></a>五.Tree Shaking</h2><p>tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 静态结构 特性，例如 import 和export 。这个术语和概念实际上是由 ES2015 模块打包工具 rollup 普及起来的。webpack 2 正式版本内置支持 ES2015 模块（也叫做 harmony modules）和未使用模块检测能力。新的 webpack4 正式版本扩展了此检测能力，通过 package.json的 “sideEffects” 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 “pure(纯正 ES2015 模块)”，由此可以安全地删除文件中未使用的部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line"> usedExports: true,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>webpack5打包更加精简化           只打包用到的方法或属性      tree shaking  优化到了极质，把一些没有用的代码全部摇掉只是给我们用到了的数据<br>理论：只要是我认为这个代码在项目中没有使用  那么就给摇掉。它基于es  module</p>
<p><strong>sideEffects</strong><br>注意 Webpack 不能百分百安全地进行 tree-shaking。有些模块导入，只要被引入，就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配置的JavaScript 文件。</p>
<p>Webpack 认为这样的文件有“副作用”。具有副作用的文件不应该做 tree-shaking，因为这将破坏整个应用程序。<br>Webpack 的设计者清楚地认识到不知道哪些文件有副作用的情况下打包代码的风险，因此webpack4默认地将所有代码视为有副作用。这可以保护你免于删除必要的文件，但这意味着 Webpack 的默认行为实际上是不进行 tree-shaking。值得注意的是webpack5默认会进行 tree-shaking。<br>如何告诉 Webpack 你的代码无副作用，可以通过 package.json 有一个特殊的属性<br>sideEffects，就是为此而存在的。<br>它有三个可能的值：<br>true<br>如果不指定其他值的话。这意味着所有的文件都有副作用，也就是没有一个文件<br>可以 tree-shaking。<br>false<br>告诉 Webpack 没有文件有副作用，所有文件都可以 tree-shaking。<br>数组[…]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#x27;sideEffects&#x27;:true/false,</span><br><span class="line">&#x27;sideEffects&#x27;:[&#x27;*.css&#x27;,&#x27;*.global.js&#x27;],</span><br></pre></td></tr></table></figure>
<p>是文件路径数组。它告诉 webpack，除了数组中包含的文件外，你的任何文件<br>都没有副作用。因此，除了指定的文件之外，其他文件都可以安全地进行 tree-<br>shaking。<br>webpack4 曾经不进行对 CommonJs 导出和 require() 调用时的导出使用分析。<br>webpack 5 增加了对一些 CommonJs 构造的支持，允许消除未使用的 CommonJs<br>导出，并从 require() 调用中跟踪引用的导出名称。</p>
<h2 id="六-渐进式网络应用程序PWA"><a href="#六-渐进式网络应用程序PWA" class="headerlink" title="六.渐进式网络应用程序PWA"></a>六.渐进式网络应用程序PWA</h2><p>渐进式网络应用程序(progressive web application - PWA)，是一种可以提供类似于native app(原生应用程序) 体验的 web app(网络应用程序)，就是说我们在浏览器端能够实现类似于原生应用程序的体验。PWA 可以用来做很多事。其中最重要的是，在离线(offline)时应用程序能够继续运行功能。这是通过使用名为 Service Workers 的 web 技术来实现的。</p>
<p><strong>非离线环境下运行</strong></p>
<p>到目前为止，我们一直是直接查看本地文件系统的输出结果。通常情况下，真正的用户是通过网络访问 web app；用户的浏览器会与一个提供所需资源（例如， .html ,.js 和 .css 文件）的 server 通讯。<br>我们通过搭建一个拥有更多基础特性的 server 来测试下这种离线体验。这里使用http-server package： npm install http-server –save-dev 。还要修改package.json 的 scripts 部分，来添加一个 start script：</p>
<p>不使用webpack-dev-server，使用第三方server，相当于我们把dist已经打包出来准备发布了<br>npm install http-server -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;http-server dist&quot;</span><br><span class="line">&#125;,</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">//注意：webpack-dev-server 是一个非离线 在线的server。 默认情况下，webpack DevServer 会写入到内存（当我们修改代码的时候重新启动服务它并不能够把我们的文件打包到dist下面，因为他是直接放到内存里的。）。我们需要启用devserverdevmiddleware.writeToDisk 配置项，来让 http-server 处理 ./dist 目录中的文件。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line"> devMiddleware: &#123;    //开发环境的server的中间件</span><br><span class="line">  writeToDisk:true,    // 写入到硬盘里</span><br><span class="line">  index: true,</span><br><span class="line">  writeToDisk: true,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你打开浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> (即 <a target="_blank" rel="noopener" href="http://127.0.0.1/">http://127.0.0.1</a> )，你应该会看到 webpack 应用程序被 serve 到 dist 目录。如果停止 server 然后刷新，则 webpack 应用程序不再可访问。这就是我们为实现离线体验所需要的改变。在本章结束时，我们应该要实现的是，停止 server 然后刷新，仍然可以看到应用程序正常运行。</p>
<p><strong>添加 Workbox</strong><br>添加 workbox-webpack-plugin 插件，然后调整 webpack.config.js 文件：    实现PWA<br>npm install workbox-webpack-plugin –save-dev</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line">const WorkboxPlugin = require(&#x27;workbox-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  app: &#x27;./src/index.js&#x27;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">   // 这些选项帮助快速启用 ServiceWorkers</span><br><span class="line">   // 不允许遗留任何“旧的” ServiceWorkers</span><br><span class="line">   clientsClaim: true,  // 快速的启用ServiceWorkers</span><br><span class="line">   skipWaiting: true,     // 跳出等待</span><br><span class="line"> &#125;),</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">  filename: &#x27;[name].bundle.js&#x27;,</span><br><span class="line">  path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  clean: true,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以看到，生成了两个额外的文件： service-worker.js 和名称冗长的workbox-718aa5be.js 。 service-worker.js 是 Service Worker 文件， workbox-718aa5be.js 是 service-worker.js 引用的文件，所以它也可以运行。你本地生成的文件可能会有所不同；但是应该会有一个 service-worker.js 文件。所以，值得高兴的是，我们现在已经创建出一个 Service Worker。接下来该做什么？</p>
<p><strong>注册 Service Worker  实现离线浏览页面的功能</strong><br>接下来我们注册 Service Worker，使其出场并开始表演。通过添加以下注册代码来<br>完成此操作：<br>index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (&#x27;serviceWorker&#x27; in navigator) &#123;    //浏览器是否支持serviceWorker</span><br><span class="line"> window.addEventListener(&#x27;load&#x27;, () =&gt; &#123;   //绑定事件load在页面加载完之后执行</span><br><span class="line">  navigator.serviceWorker.register(&#x27;/service-     // 方法传入刚刚打包好的service-worker.js。</span><br><span class="line">worker.js&#x27;).then(registration =&gt; &#123;                  // 拿到注册以后的成功的结果</span><br><span class="line">   console.log(&#x27;SW 注册成功: &#x27;, registration);</span><br><span class="line"> &#125;).catch(registrationError =&gt; &#123;</span><br><span class="line">   console.log(&#x27;SW 注册失败: &#x27;, registrationError);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于在浏览器里我们的页面被缓存下来了<br>chrome:&#x2F;&#x2F;serviceworker-internals    清除http-server缓存。   服务就跑不起来了。</p>
<p>再次运行 npx webpack 来构建包含注册代码版本的应用程序。然后用 npm start启动服务。访<a href="http://localhost:8080并查看">http://localhost:8080并查看</a> console 控制台。在那里你应该看到：<br>SW registered<br>现在来进行测试。停止 server 并刷新页面。如果浏览器能够支持 Service Worker，应该可以看到你的应用程序还在正常运行。然而，server 已经停止 serve 整个 dist文件夹，此刻是 Service Worker 在进行 serve。</p>
<h2 id="七-Shimming预置依赖"><a href="#七-Shimming预置依赖" class="headerlink" title="七.Shimming预置依赖"></a>七.Shimming预置依赖</h2><p>不导入直接就可以使用一些变量</p>
<p>webpack compiler 能够识别遵循 ES2015 模块语法、CommonJS 或 AMD 规范编写的模块。然而，一些 third party(第三方库) 可能会引用一些全局依赖（例如 jQuery中的 $ ）。因此这些 library 也可能会创建一些需要导出的全局变量这些 “brokenmodules(不符合规范的模块)” 就是 shimming(预置依赖) 发挥作用的地方。<br>shim 另外一个极其有用的使用场景就是：当你希望 polyfill 扩展浏览器能力，来支持到更多用户时。在这种情况下，你可能只是想要将这些 polyfills 提供给需要修补(patch)的浏览器（也就是实现按需加载）。</p>
<p><strong>Shimming 预置全局变量</strong></p>
<p>让我们开始第一个 shimming 全局变量的用例。还记得我们之前用过的 lodash吗？出于演示目的，例如把这个应用程序中的模块依赖，改为一个全局变量依赖。要实现这些，我们需要使用 ProvidePlugin 插件。使用 ProvidePlugin 后，能够在 webpack 编译的每个模块中，通过访问一个变量来获取一个 package。如果 webpack 看到模块中用到这个变量，它将在最终bundle 中引入给定的 package。让我们先移除 lodash 的 import 语句，改为通过插件提供它：<br>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(_.join([&#x27;hello&#x27;, &#x27;webpack&#x27;], &#x27; &#x27;))</span><br><span class="line">webpack.config.js</span><br><span class="line"></span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;development&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new webpack.ProvidePlugin(&#123;</span><br><span class="line">   _: &#x27;lodash&#x27;     // lodash变成全局  遇到_将lodash包引进来</span><br><span class="line"> &#125;)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们本质上所做的，就是告诉 webpack……如果你遇到了至少一处用到 _ 变量的模块实例，那请你将 lodash package 引入进来，并将其提供给需要用到它的模块。运行我们的构建脚本，将会看到同样的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[felix] 01-third-party-shimming $ npx webpack</span><br><span class="line">asset main.js 549 KiB [emitted] (name: main)</span><br><span class="line">runtime modules 344 bytes 2 modules</span><br><span class="line">cacheable modules 528 KiB</span><br><span class="line">./src/index.js 46 bytes [built] [code generated]</span><br><span class="line">../../../../../node_modules/lodash/lodash.js 528 KiB [built]</span><br><span class="line">[code generated]</span><br><span class="line">webpack 5.61.0 compiled successfully in 275 ms</span><br></pre></td></tr></table></figure>
<p>还可以使用 ProvidePlugin 暴露出某个模块中单个导出，通过配置一个“数组路径”（例如 [module, child, …children?] ）实现此功能。所以，我们假想如下，无论 join 方法在何处调用，我们都只会获取到 lodash 中提供的 join 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">src/index.js</span><br><span class="line">console.log(join([&#x27;hello&#x27;, &#x27;webpack&#x27;], &#x27; &#x27;))</span><br><span class="line">webpack.config.js</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;development&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new webpack.ProvidePlugin(&#123;</span><br><span class="line">   // _: &#x27;lodash&#x27;</span><br><span class="line">   join: [&#x27;lodash&#x27;, &#x27;join&#x27;],</span><br><span class="line"> &#125;)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就能很好的与 tree shaking 配合，将 lodash library 中的其余没有用到的导出<br>去除</p>
<p><strong>细粒度 Shimming</strong><br>一些遗留模块依赖的 this 指向的是 window 对象。在接下来的用例中，调整我们的 index.js ：<br>npm istall imports-loader -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.alert(&#x27;hello webpack&#x27;)</span><br></pre></td></tr></table></figure>
<p>当模块运行在 CommonJS 上下文中，这将会变成一个问题，也就是说此时的 this指向的是 module.exports 。在这种情况下，你可以通过使用 imports-loader 覆盖 this 指向：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: require.resolve(&#x27;./src/index.js&#x27;),     // 调用require.resolve去调用  文件。</span><br><span class="line">    use: &#x27;imports-loader?wrapper=window&#x27;,     //webpack解析到  这个文件时使用的loader  wrapper=window  指明包里面的this指向浏览器的window。</span><br><span class="line">  &#125;,</span><br><span class="line"> ]</span><br><span class="line">&#125;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new webpack.ProvidePlugin(&#123;</span><br><span class="line">   _: &#x27;lodash&#x27;</span><br><span class="line"> &#125;),</span><br><span class="line">  new HtmlWebpackPlugin()</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>全局 Exports</strong></p>
<p>让我们假设，某个 library 创建出一个全局变量，它期望 consumer(使用者) 使用这个变量。为此，我们可以在项目配置中，添加一个小模块来演示说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">src/globals.js</span><br><span class="line">const file = &#x27;example.txt&#x27;;</span><br><span class="line">const helpers = &#123;</span><br><span class="line"> test: function () &#123;</span><br><span class="line">  console.log(&#x27;test something&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line"> parse: function () &#123;</span><br><span class="line">  console.log(&#x27;parse something&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">npm install exports-loader -D</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: require.resolve(&#x27;./src/index.js&#x27;),</span><br><span class="line">    use: &#x27;imports-loader?wrapper=window&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: require.resolve(&#x27;./src/globals.js&#x27;),</span><br><span class="line">    use: &#x27;exports-loader?type=commonjs&amp;exports=file,multiple|helpers.parse（value）|parse（key）&#x27;,   //  type：类型为模块导出的类型commonjs    导出的变量file  js文件中的File    ，multiple表示导出一个key|value的形式。</span><br><span class="line">  &#125;,</span><br><span class="line"> ]</span><br><span class="line">&#125;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new webpack.ProvidePlugin(&#123;</span><br><span class="line">   _: &#x27;lodash&#x27;</span><br><span class="line"> &#125;),</span><br><span class="line">  new HtmlWebpackPlugin()</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123;file,parse&#125; = require(&#x27;./globals&#x27;)   //  那我直接导入不就行了，前提条件globals.js是外部的一个文件，一般情况下我们并不知道它是如何导出的   所有我们在配置文件里边做一个  一些内容的导出   这样我们就可以单独的去使用我们想要的一些模块了</span><br></pre></td></tr></table></figure>

<p>此时，在我们的 entry 入口文件中（即 src&#x2F;index.js ），可以使用 const {file, parse } &#x3D; require(‘.&#x2F;globals.js’); ，可以保证一切将顺利运行。</p>
<p><strong>加载 Polyfills</strong><br>目前为止，我们讨论的所有内容 都是处理那些遗留的 package，让我们进入到第二个话题：polyfill。<br>有很多方法来加载 polyfill。例如，想要引入 @babel&#x2F;polyfill 我们只需如下操作：<br>npm install –save @babel&#x2F;polyfill<br>然后，使用 import 将其引入到我们的主 bundle 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index.js</span><br><span class="line">import &#x27;@babel/polyfill&#x27;    //polyfill俗称垫片   在执行下面的语句之前，把所有的可能需要降级的代码都放在了我们代码的前面</span><br><span class="line">console.log(Array.from([1, 2, 3], x =&gt; x + x))    //from方法不是所有的浏览器都支持的   如果是我们不告诉webpack那么他就纯粹八Array.from直接的打到我们的页面上去了，即使是我们可能会使用一些@babal/loader,但是他也不会  100%的将我们的代码全部转换为低版本的浏览器能够识别的所有代码。所以我们得告诉浏览器 在某些版本里面得把他转成低版本的代码比如  es6=&gt;es3.1  这是我们就需要一个垫片来完成。</span><br></pre></td></tr></table></figure>
<p>注意，这种方式优先考虑正确性，而不考虑 bundle 体积大小。为了安全和可靠，polyfill&#x2F;shim 必须运行于所有其他代码之前，而且需要同步加载，或者说，需要在所有 polyfill&#x2F;shim 加载之后，再去加载所有应用程序代码。 社区中存在许多误解，即现代浏览器“不需要”polyfill，或者 polyfill&#x2F;shim 仅用于添加缺失功能 - 实际上，它们通常用于修复损坏实现(repair broken implementation)，即使是在最现代的浏览器中，也会出现这种情况。 因此，最佳实践仍然是，不加选择地和同步地加载所有polyfill&#x2F;shim，尽管这会导致额外的 bundle 体积成本。</p>
<p><strong>进一步优化 Polyfills</strong><br>不建议使用 import @babel&#x2F;polyfilll 。因为这样做的缺点是会全局引入整个polyfill包，比如 Array.from 会全局引入，不但包的体积大，而且还会污染全局环境。<br>babel-preset-env package 通过 browserslist 来指定来对那些浏览器那些浏览器的版本进行转换，来转译那些你浏览器中不支持的特性。这个 preset 使用 useBuiltIns 选项，默认值是 false ，这种方式可以将全局babel-polyfill 导入，改进为更细粒度的 import 格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;core-js/modules/es7.string.pad-start&#x27;;</span><br><span class="line">import &#x27;core-js/modules/es7.string.pad-end&#x27;;</span><br><span class="line">import &#x27;core-js/modules/web.timers&#x27;;</span><br><span class="line">import &#x27;core-js/modules/web.immediate&#x27;;</span><br><span class="line">import &#x27;core-js/modules/web.dom.iterable&#x27;;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;安装 @babel&#x2F;preset-env 及 相关的包<br>npm i babel-loader @babel&#x2F;core @babel&#x2F;preset-env -D<br>&#x2F;&#x2F; webpack.config.js<br>const HtmlWebpackPlugin &#x3D; require(‘html-webpack-plugin’)<br>module.exports &#x3D; {<br> mode: ‘production’,<br> entry: ‘.&#x2F;src&#x2F;index.js’,<br> plugins: [<br>  new HtmlWebpackPlugin()<br>],<br> module: {<br>  rules: [<br>  {<br>    test: &#x2F;.js$&#x2F;,<br>    exclude: &#x2F;node_modules&#x2F;,<br>    use: {<br>     loader: ‘babel-loader’,<br>     options: {<br>      presets: [<br>      [<br>        ‘@babel&#x2F;preset-env’,<br>       {<br>         targets: [  &#x2F;&#x2F;也可以顶知道package.json中  符合这个条件的代码都需要通过Polyfill来进行垫片的添加<br>          “last 1 version”,<br>          “&gt; 1%”,<br>         ],<br>         useBuiltIns: ‘usage’ ，    &#x2F;&#x2F;  这里这个@babel&#x2F;preset-env  后我们就不需要手动的导入  import ‘@babel&#x2F;polyfill’了。        使用这个选项需要 Core.js翻译器，这是优雅降级的一些库<br>         &#x2F;&#x2F;添加corejs配置<br>           corejs: 3,     &#x2F;&#x2F;定义core.js的版本魏三<br>       }<br>      ]<br>     ]<br>    }<br>   }<br>  }<br> ]<br>}<br>}<br>useBuiltIns: 参数有 “entry”、”usage”、false 三个值默认值是 false ，此参数决定了babel打包时如何处理@babel&#x2F;polyfilll 语句。<br>“entry”: 会将文件中 import @babel&#x2F;polyfilll 语句 结合 targets ，转换为一系列引入语句，去掉目标浏览器已支持的 polyfilll 模块，不管代码里有没有用到，只要目标浏览器不支持都会引入对应的 polyfilll 模块。<br>“usage”: 不需要手动在代码里写 import @babel&#x2F;polyfilll ，打包时会自动根据实际代码的使用情况，结合 targets 引入代码里实际用到部分 polyfilll 模块<br>false: 对 import‘@babel&#x2F;polyfilll’不作任何处理，也不会自动引入 polyfilll 模块。需要注意的是在 webpack 打包文件配置的 entry 中引入的 @babel&#x2F;polyfill 不会根据useBuiltIns 配置任何转换处理。</p>
<p>由于@babel&#x2F;polyfill在7.4.0中被弃用，我们建议直接添加corejs并通过corejs选项设置版本。<br>执行编译 npx webpack</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[felix] 02-polyfill $ npx webpack</span><br><span class="line">WARNING (@babel/preset-env): We noticed you&#x27;re using the</span><br><span class="line">`useBuiltIns` option without declaring a core-js version.</span><br><span class="line">Currently, we assume version 2.x when no version is passed. Since</span><br><span class="line">this default version will likely change in future versions of</span><br><span class="line">Babel, we recommend explicitly setting the core-js version you</span><br><span class="line">are using via the `corejs` option.</span><br><span class="line">You should also be sure that the version you pass to the `corejs`</span><br><span class="line">option matches the version specified in your `package.json`&#x27;s</span><br><span class="line">`dependencies` section. If it doesn&#x27;t, you need to run one of the</span><br><span class="line">following commands:</span><br><span class="line">npm install --save core-js@2   npm install --save core-js@3</span><br><span class="line">yarn add core-js@2       yarn add core-js@3</span><br><span class="line">More info about useBuiltIns: https://babeljs.io/docs/en/babel-</span><br><span class="line">preset-env#usebuiltins</span><br><span class="line">More info about core-js: https://babeljs.io/docs/en/babel-preset-</span><br><span class="line">env#corejs</span><br><span class="line">asset main.js 16.7 KiB [emitted] [minimized] (name: main)</span><br><span class="line">asset index.html 214 bytes [compared for emit]</span><br><span class="line">runtime modules 663 bytes 3 modules</span><br><span class="line">modules by path ./node_modules/core-js/modules/*.js 38.9 KiB 68</span><br><span class="line">modules</span><br><span class="line">./src/index.js 374 bytes [built] [code generated]</span><br><span class="line">webpack 5.61.0 compiled successfully in 1613 ms</span><br></pre></td></tr></table></figure>
<p>提示我们需要安装 core-js 。<br>npm i core-js@3 -S<br>此时还需要 添加一个配置：<br>&#x2F;&#x2F; 添加corejs配置<br>corejs: 3,<br>成功优化</p>
<h2 id="八-创建-library"><a href="#八-创建-library" class="headerlink" title="八.创建 library"></a>八.创建 library</h2><p>除了打包应用程序，webpack 还可以用于打包 JavaScript library。<br>例如：当我们想要自己开发一个组件库工具或者框架的时候也就是说我们自己造一个轮子给别人用的时候我们免不了要开发很多的模块，最终都可以请webpack来帮我们打包。</p>
<p><strong>创建一个 library</strong><br>假设我们正在编写一个名为 webpack-numbers 的小的 library，可以将数字 1 到 5转换为文本表示，反之亦然，例如将 2 转换为 ‘two’。<br>使用 npm 初始化项目，然后安装 webpack ， webpack-cli 和 lodash ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli lodash -D</span><br></pre></td></tr></table></figure>
<p>我们将 lodash 安装为 devDependencies 而不是 dependencies ，因为我们不需要将其打包到我们的库中，否则我们的库体积很容易变大。</p>
<p>src&#x2F;ref.json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 1,</span><br><span class="line">  &quot;word&quot;: &quot;One&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 2,</span><br><span class="line">  &quot;word&quot;: &quot;Two&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 3,</span><br><span class="line">  &quot;word&quot;: &quot;Three&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 4,</span><br><span class="line">  &quot;word&quot;: &quot;Four&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 5,</span><br><span class="line">  &quot;word&quot;: &quot;Five&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 0,</span><br><span class="line">  &quot;word&quot;: &quot;Zero&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import _ from &#x27;lodash&#x27;;</span><br><span class="line">import numRef from &#x27;./ref.json&#x27;;</span><br><span class="line">export function numToWord(num) &#123;</span><br><span class="line"> return _.reduce(</span><br><span class="line">  numRef,</span><br><span class="line"> (accum, ref) =&gt; &#123;</span><br><span class="line">   return ref.num === num ? ref.word : accum;</span><br><span class="line"> &#125;,</span><br><span class="line">  &#x27;&#x27;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">export function wordToNum(word) &#123;</span><br><span class="line"> return _.reduce(</span><br><span class="line">  numRef,</span><br><span class="line"> (accum, ref) =&gt; &#123;</span><br><span class="line">   return ref.word === word &amp;&amp; word.toLowerCase() ? ref.num :</span><br><span class="line">accum;</span><br><span class="line"> &#125;,</span><br><span class="line">  -1</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode:&#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  filename: &#x27;webpack-numbers.js&#x27;,</span><br><span class="line">  library:&#123;</span><br><span class="line">    name:&#x27;webpackNumbers&#x27;,</span><br><span class="line">	type&#x27;umd&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  globalObject:&#x27;globalThis&#x27;</span><br><span class="line">&#125;,</span><br><span class="line"> externals:&#123;</span><br><span class="line"> 	lodash:&#123;   lodash  引入包的名字</span><br><span class="line">		commonjs:&#x27;lodash&#x27;,   //  兼容引入形式</span><br><span class="line">		commonjs2:&#x27;lodash&#x27;,</span><br><span class="line">		amd:&#x27;lodash&#x27;,</span><br><span class="line">		root:&#x27;_&#x27;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>发布到线上</strong><br>拥有npm账号<br>npm config get registry   &#x2F;&#x2F; 一定要保证本地的registry的地址是<a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a>    因为这样的话才是真正的连接到npm官网的地址上   有些人可能是淘宝  那么就访问不上去了<br>npm adduser  &#x2F;&#x2F;添加用户   输入用户名密码<br>包的名字必须是全球唯一的。   npm publish    上传时package.json中的main入口必须对应：dist&#x2F;文件名   因为别人通过 require去载入包的时候  会读取 这个main这是的暴露的包的名字<br>npm install 包名就可以下载了</p>
<p><strong>Webpack 配置</strong></p>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">	path:&#x27;&#x27;,</span><br><span class="line">	filname:&#x27;&#x27;,</span><br><span class="line">	library:&#x27;&#x27;,    //我们只是定义了导出 并且没有使用它  所以webpack认为这个代码是没有用的。   如何让他作为一个library来进行一个对外的打包   让代码不被 Webpack Tree shaking   配置 library:&#x27;包的名字&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，一切都应该与打包应用程序一样，这里是不同的部分 - 我们需要通过output.library 配置项暴露从入口导出的内容。<br>我们暴露了 webpackNumbers ，以便用户可以通过 script 标签使用。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> window.webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然而它只能通过被 script 标签引用而发挥作用，它不能运行在 CommonJS、AMD、Node.js 等环境中。<br>作为一个库作者，我们希望它能够兼容不同的环境，也就是说，用户应该能够通过以下方式使用打包后的库：<br>CommonJS module require:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const webpackNumbers = require(&#x27;webpack-numbers&#x27;);</span><br><span class="line">// ...</span><br><span class="line">webpackNumbers.wordToNum(&#x27;Two&#x27;);</span><br></pre></td></tr></table></figure>
<p>AMD module require:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require([&#x27;webpackNumbers&#x27;], function (webpackNumbers) &#123;</span><br><span class="line"> // ...</span><br><span class="line"> webpackNumbers.wordToNum(&#x27;Two&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>script tag:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line"> &lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">  // ...</span><br><span class="line">  // Global variable</span><br><span class="line">  webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">  // Property in the window object</span><br><span class="line">  window.webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">  // ...</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>我们更新 output.library 配置项，将其 type 设置为 ‘umd’ ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  filename: &#x27;webpack-numbers.js&#x27;,</span><br><span class="line">  library: &#123;</span><br><span class="line">   name: &#x27;webpackNumbers&#x27;,</span><br><span class="line">   type: &#x27;umd&#x27;,   //  window&#x27;(es module)   &#x27;commonjs&#x27;   &#x27;module&#x27; 它在experiments:&#123;outputModule:true&#125;才能使用，他是一个实验性的功能，就不需要这个name了。&lt;script type=&quot;module&quot;&gt;    &#x27;umd&#x27;支持所有的类型。  esmodule 有问题</span><br><span class="line">  &#125;,</span><br><span class="line">  globalObject:&#x27;globalThis&#x27;    //需要全局的this来去  代替self   否则浏览器会self  undefined报错</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在 webpack 将打包一个库，其可以与 CommonJS、AMD 以及 script 标签使用</p>
<h2 id="九-模块联邦-Module-Federation"><a href="#九-模块联邦-Module-Federation" class="headerlink" title="九.模块联邦(Module Federation)"></a>九.模块联邦(Module Federation)</h2><p>多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。<br>这通常被称作微前端，但并不仅限于此。<br>Webpack5 模块联邦可以让 Webpack 达到了线上 Runtime 的效果，让代码直接在项目间利用 CDN 直接共享，不再需要本地安装 Npm 包、构建再发布了！<br>我们知道 Webpack 可以通过 DLL 或者 Externals 做代码共享时 Common Chunk，但不同应用和项目间这个任务就变得困难了，我们几乎无法在项目之间做到按需热插拔。</p>
<p>早期NPM方式共享模块   代码的共享是将依赖作为library安装到我们的项目里进行webpack打包并且构建上线<br>对于项目 Home 与 Search，需要共享一个模块时，最常见的办法就是将其抽成通用依赖并分别安装在各自项目中。虽然 Monorepo 可以一定程度解决重复安装和修改困难的问题，但依然需要走本地编译。</p>
<p>真正 Runtime 的方式可能是 UMD 方式共享代码模块，即将模块用 Webpack UMD模式打包，并输出到其他项目中。这是非常普遍的模块共享方式：<br>对于项目 Home 与 Search，直接利用 UMD 包复用一个模块。但这种技术方案问题也很明显，就是包体积无法达到本地编译时的优化效果，且库之间容易冲突。</p>
<p>微前端：micro-frontends (MFE) 也是最近比较火的模块共享管理方式，微前端就是要解决多项目并存问题，多项目并存的最大问题就是模块共享，模块之间是不能有冲突。  对于微前端我们还要考虑样式冲突，声明周期管理冲突等问题，我们先不考虑这些   想把问题聚焦在资源加载的方式上   微前端一般有两种打包方式：1.子应用独立打包，模块实现解耦，但这种方式无法抽取公共的依赖，2.整体应用打一个打包 很好的解决我们上面第一种方式的问题，但是打包效率速度实在是太慢了。不具备水平的扩展能力。<br>由于微前端还要考虑样式冲突、生命周期管理，所以本文只聚焦在资源加载方式上。微前端一般有两种打包方式：</p>
<ol>
<li>子应用独立打包，模块更解耦，但无法抽取公共依赖等。</li>
<li>整体应用一起打包，很好解决上面的问题，但打包速度实在是太慢了，不具备水平扩展能力。</li>
</ol>
<p>终于提到本文的主角了，模块联邦方式作为 Webpack5 内置核心特性之一的 FederatedModule：<br>这个方案是直接将一个应用的包应用于另一个应用，同时具备整体应用一起打包的公共依赖抽取能力。  比如：我们直接可以在Search应用里直接使用已经发布到线上的Home应用的组件。</p>
<p><strong>应用案例</strong><br>本案例模拟三个应用： Nav 、 Search 及 Home 。每个应用都是独立的，又通过模块邦联系到了一起。<br>比如Home需要使用Nav组件共享出来的header，Search可能要使用Header和Home组件构建出来的HomeList。<br>模块联邦将他们共享的模块暴露出来进行引用。<br>1、Nav 导航<br>src&#x2F;header.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Header = () =&gt; &#123;</span><br><span class="line"> const header = document.createElement(&#x27;h1&#x27;)</span><br><span class="line"> header.textContent = &#x27;公共头部内容&#x27;</span><br><span class="line"> return header</span><br><span class="line">&#125;</span><br><span class="line">export default Header</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Header from &#x27;./Header&#x27;</span><br><span class="line">const div = document.createElement(&#x27;div&#x27;)</span><br><span class="line">div.appendChild(Header())</span><br><span class="line">document.body.appendChild(div)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   // 模块联邦名字</span><br><span class="line">   name: &#x27;nav&#x27;,</span><br><span class="line">   // 外部访问的资源名字</span><br><span class="line">   filename: &#x27;remoteEntry.js&#x27;,</span><br><span class="line">   // 引用的外部资源列表</span><br><span class="line">   remotes: &#123;&#125;,</span><br><span class="line">   // 暴露给外部资源列表</span><br><span class="line">   exposes: &#123;</span><br><span class="line">    &#x27;./Header&#x27;: &#x27;./src/Header.js&#x27;,   // 暴露 Header组件  key：可以定义成./Header 这个./Header并不代表是我当前引用下的某个路径   而是将来在别人用的时候基于这个路径来拼接url，值是正真的我们本地项目的应用</span><br><span class="line">  &#125;,</span><br><span class="line">   // 共享模块，如lodash</span><br><span class="line">   shared: &#123;&#125;,   // 如果我们的 header模块里有共享的第三方模块比如：lodash等，我们可以把他放到这里在打包的时候可以把第三方的共享的模块打到单独的一个包里。</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3003</span><br></pre></td></tr></table></figure>

<p>2、Home 首页<br>src&#x2F;HomeList</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const HomeList = (num) =&gt; &#123;</span><br><span class="line"> let str = &#x27;&lt;ul&gt;&#x27;</span><br><span class="line"> for (let i = 0; i &lt; num; i++) &#123;</span><br><span class="line">  str += &#x27;&lt;li&gt;item &#x27; + i + &#x27;&lt;/li&gt;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"> str += &#x27;&lt;/ul&gt;&#x27;</span><br><span class="line"> return str</span><br><span class="line">&#125;</span><br><span class="line">export default HomeList</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import HomeList from &#x27;./HomeList&#x27;</span><br><span class="line">remotes: &#123;</span><br><span class="line">    nav</span><br><span class="line">	(&#x27;nav/Header&#x27;)：remotes: &#123; nav &#125;Header    exposes: &#123;./Header&#x27;:&#x27;&#x27;&#125;</span><br><span class="line">import(&#x27;nav/Header&#x27;).then((Header) =&gt; &#123;  //引用模块联邦的组件  这样导入别人组件的时候需要通过异步的方式因为 网络共享或者是模块载入 是由延迟的，所以要通过promise的方式（异步模块加载的形式）去引用它。</span><br><span class="line"> const body = document.createElement(&#x27;div&#x27;)</span><br><span class="line"> body.appendChild(Header.default())</span><br><span class="line"> document.body.appendChild(body)</span><br><span class="line"> document.body.innerHTML += HomeList(5)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   name: &quot;home&quot;,</span><br><span class="line">   filename: &quot;remoteEntry.js&quot;,</span><br><span class="line">   remotes: &#123;</span><br><span class="line">    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,    // 引用第三方或别人写好的应用的路径。远端的服务路径</span><br><span class="line">  &#125;,</span><br><span class="line">   exposes: &#123;</span><br><span class="line">    &#x27;./HomeList&#x27;: &#x27;./src/HomeList.js&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   shared: &#123;&#125;,</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3001</span><br></pre></td></tr></table></figure>

<p>3、search 搜索<br>src&#x2F;index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([import(&#x27;nav/Header&#x27;), import(&#x27;home/HomeList&#x27;)])</span><br><span class="line">.then(([&#123;</span><br><span class="line">  default: Header</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  default: HomeList</span><br><span class="line">&#125;]) =&gt; &#123;</span><br><span class="line">  document.body.appendChild(Header())</span><br><span class="line">  document.body.innerHTML += HomeList(4)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   name: &#x27;search&#x27;,</span><br><span class="line">   filename: &#x27;remoteEntry.js&#x27;,</span><br><span class="line">   remotes: &#123;</span><br><span class="line">    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,</span><br><span class="line">    home: &quot;home@http://localhost:3001/remoteEntry.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">   exposes: &#123;&#125;,</span><br><span class="line">   shared: &#123;&#125;,</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3002</span><br></pre></td></tr></table></figure>
<h2 id="十-提升构建性能"><a href="#十-提升构建性能" class="headerlink" title="十. 提升构建性能"></a>十. 提升构建性能</h2><p>澄清：有时候我们会笼统的说webpack的性能提升，实际上webpack的性能提升可以分为两类  第一类是通过webpack来提升我们项目性能  如：网站的首屏到达时间，这个优化的受益者是c端的用户  ，2.提升webpack的构建编译性能，如：提高打包速度，降低打包时间，这个优化的受益者是我们的开发人员。   本章讲的是第二种<br>把官网上提出的webpack5 提升构建性能的点  列：<br><strong>注意：</strong>  webpack 每个版本的优化点都是不一样的<br>通用环境：这些优化既适用于开发化境也适用于生产环境。<br>开发环境：<br>生产环境：<br><strong>通用环境</strong><br>无论你是在 开发环境 还是在 生产环境 下运行构建脚本，以下最佳实践都会有所帮助。</p>
<p>1、更新到最新版本<br>使用最新的 webpack 版本。我们会经常进行性能优化。webpack 的最新稳定版本是：<br>将 Node.js 更新到最新版本，也有助于提高性能。除此之外，将你的 package 管理工具（例如 npm 或者 yarn ）更新到最新版本，也有助于提高性能。较新的版本能够建立更高效的模块树以及提高解析速度。</p>
<p>2、loader<br>将 loader 应用于最少数量的必要模块。而非如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> //...</span><br><span class="line"> module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    loader: &#x27;babel-loader&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line"> ],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过使用 include 字段，仅将 loader 应用在实际需要将其转换的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> //...</span><br><span class="line"> module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    include: path.resolve(__dirname, &#x27;src&#x27;),</span><br><span class="line">    loader: &#x27;babel-loader&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line"> ],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3、引导(bootstrap)<br>每个额外的 loader&#x2F;plugin 都有其启动时间。尽量少地使用工具。</p>
<p>4、解析<br>以下步骤可以提高解析速度：<br>减少 resolve.modules , resolve.extensions , resolve.mainFiles ,resolve.descriptionFiles 中条目数量，因为他们会增加文件系统调用的次数。</p>
<p>如果你不使用 symlinks（例如 npm link 或者 yarn link ），可以设置resolve.symlinks: false 。</p>
<p>如果你使用自定义 resolve plugin 规则，并且没有指定 context 上下文，可以设置 resolve.cacheWithContext: false 。</p>
<p>5、小即是快(smaller &#x3D; faster)<br>减少编译结果的整体大小，以提高构建性能。尽量保持 chunk 体积小。使用数量更少&#x2F;体积更小的 library。</p>
<p>在多页面应用程序中使用 SplitChunksPlugin 。<br>在多页面应用程序中使用 SplitChunksPlugin ，并开启 async 模式。<br>移除未引用代码。<br>只编译你当前正在开发的那些代码。</p>
<p>6、持久化缓存<br>在 webpack 配置中使用 cache 选项。使用 package.json 中的 “postinstall”清除缓存目录。<br>将 cache 类型设置为内存或者文件系统。 memory 选项很简单，它告诉 webpack在内存中存储缓存，不允许额外的配置：<br>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> //...</span><br><span class="line"> cache: &#123;</span><br><span class="line">  type: &#x27;memory&#x27;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>7、自定义 plugin&#x2F;loader<br>对它们进行概要分析，以免在此处引入性能问题。<br>8、dll<br>使用 DllPlugin 为更改不频繁的代码生成单独的编译结果。这可以提高应用程序的编译速度，尽管它增加了构建过程的复杂度。</p>
<p>webpack.all.config.js  配置关于dll相关的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	mode:&#x27;production&#x27;   // 在生产环境下面去做事情</span><br><span class="line">	entry:&#123;</span><br><span class="line">		jquery:[&#x27;jquery&#x27;],</span><br><span class="line">	&#125;,  //注意：这个entry不是配置本地的包，而是要配置我们在node_modules里面安装的第三方的包</span><br><span class="line">	output:&#123;</span><br><span class="line">		filename:&#x27;[name].js&#x27;     // [name]  取到的是本身的jquery的chunk的名字</span><br><span class="line">		path:path.resolve(__dirname,&#x27;dll&#x27;),</span><br><span class="line">		library:&#x27;[name]_[hash]&#x27;    // 把他导出一个库    给这个包起了一个名字，打他导出一个第三方的包。</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins:[</span><br><span class="line">		new webpack.DllPlugin(&#123;</span><br><span class="line">			name:&#x27;[name]_[hash]&#x27;,     //名字和上面library取的名字是一样的</span><br><span class="line">			path:path.resolve(__dirname,&#x27;dll/manifest.json&#x27;)      // 把一个manifest的文件给生成出来</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">	&quot;scripts&quot;:&#123;</span><br><span class="line">		&quot;all&quot;:&quot;webpack --config ./webpack.dll.config.js&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">plugins:[</span><br><span class="line">	new webpack.DllReferencePlugin(&#123;</span><br><span class="line">		manifest:path.resolve(__dirname,&#x27;./all/manifest.json&#x27;)     // 它的值就是刚刚生成的manifest</span><br><span class="line">	&#125;)    //和刚才的DllPlugin做了一个呼应</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>仅仅是提高了构建速度  如果想把jquery放到页面上显示的话还是有些问题的。   还需要对dll文件进行一次打包   可以使用插件来完成<br>npm install add-asset-html-webpack-plugin -D<br>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const AddAssetHtmlPlugin = require(&#x27;add-asset-html-webpack-plugin&#x27;)</span><br><span class="line">plugins:[</span><br><span class="line">	new AddAssetHtmlPlugin(&#123;</span><br><span class="line">		filepath:path.resolve(__dirname,&#x27;./dll/jquery.js&#x27;),</span><br><span class="line">		publicPath:&#x27;./&#x27;</span><br><span class="line">	&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>编译大小有右边回来之前的大小，但是jquery会单独做成一个文件打出来，那我们可以在最后的时候在做一次打包，之前打包的时候可以使用dll这个所谓的link，实时上他还是通过link去加载的我们的jquery.js文件</p>
<p>9、worker 池(worker pool)<br>thread-loader 可以将非常消耗资源的 loader 分流给一个 worker pool。</p>
<p>该怎么去测试worker pool  ，定义：它的实现原理就是我们可以把他定义在其他的loader前面然后把其他的loader放在另外一个worker pool的池里面去运行来提高我们的打包速度，其实就是把他放到另外一个cpu去运行了，来利用我们电脑的cpu。<br>npm install thread-loader -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">	rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:/\.js$/,</span><br><span class="line">			exclude:/node_modules/,</span><br><span class="line">			use:[</span><br><span class="line">				&#123;</span><br><span class="line">					loader:&#x27;babel-loader&#x27;   //问了提高Babel-loader的打包速度可以把他放在 worker pool里运行（可以在单独的cpu里去运行）</span><br><span class="line">				options:&#123;</span><br><span class="line">					presets:[&#x27;@babel/preset-env&#x27;]   //这样他就可以解析我们js里面的一些es6的代码了</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				&#123;  // thread-loader启动需要大概耗费600ms的时间（有开销），这个loader对耗时非常打的loader有意义。</span><br><span class="line">					loader:&#x27;thread-loader&#x27;,</span><br><span class="line">					options:&#123;</span><br><span class="line">						workers:2    // cpu的数量</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要使用太多的 worker，因为 Node.js 的 runtime 和 loader 都有启动开销。最小化 worker 和 mainprocess(主进程) 之间的模块传输。进程间通讯(IPC,inter process communication)是非常消耗资源的。</p>
<p>10、Progress plugin<br>将 ProgressPlugin 从 webpack 中删除，可以缩短构建时间。请注意，<br>ProgressPlugin 可能不会为快速构建提供太多价值，因此，请权衡利弊再使用。</p>
<p><strong>开发环境</strong><br>以下步骤对于 开发环境 特别有帮助。<br>1、增量编译<br>使用 webpack 的 watch mode(监听模式)。而不使用其他工具来 watch 文件和调用webpack 。内置的 watch mode 会记录时间戳并将此信息传递给 compilation 以使缓存失效。</p>
<p>在某些配置环境中，watch mode 会回退到 poll mode(轮询模式)。监听许多文件会导致 CPU 大量负载。在这些情况下，可以使用 watchOptions.poll 来增加轮询的间隔时间。</p>
<p>2、在内存中编译<br>下面几个工具通过在内存中（而不是写入磁盘）编译和 serve 资源来提高性能：</p>
<p>webpack-dev-server<br>webpack-hot-middleware<br>webpack-dev-middleware<br>3、stats.toJson 加速<br>webpack 4 默认使用 stats.toJson() 输出大量数据。除非在增量步骤中做必要的统计，否则请避免获取 stats 对象的部分内容。 webpack-dev-server 在 v3.1.3 以后的版本，包含一个重要的性能修复，即最小化每个增量构建步骤中，从 stats 对象获取的数据量。</p>
<p>4、Devtool<br>需要注意的是不同的 devtool 设置，会导致性能差异。</p>
<p>“eval” 具有最好的性能，但并不能帮助你转译代码。<br>如果你能接受稍差一些的 map 质量，可以使用 cheap-source-map 变体配置来提高性能<br>使用 eval-source-map 变体配置进行增量编译。</p>
<p>在大多数情况下，最佳选择是 eval-cheap-module-source-map 。</p>
<p>5、避免在生产环境下才会用到的工具<br>某些 utility, plugin 和 loader 都只用于生产环境。例如，在开发环境下使用TerserPlugin 来 minify(压缩) 和 mangle(混淆破坏) 代码是没有意义的。通常在开发环境下，应该排除以下这些工具：</p>
<p>TerserPlugin<br>[fullhash] &#x2F; [chunkhash] &#x2F; [contenthash]<br>AggressiveSplittingPlugin<br>AggressiveMergingPlugin<br>ModuleConcatenationPlugin</p>
<p>6、最小化 entry chunk<br>Webpack 只会在文件系统中输出已经更新的 chunk。某些配置选项（HMR,output.chunkFilename 的 [name] &#x2F; [chunkhash]&#x2F;[contenthash] ，[fullhash] ）来说，除了对已经更新的 chunk 无效之外，对于 entry chunk 也不会生效。<br>确保在生成 entry chunk 时，尽量减少其体积以提高性能。下面的配置为运行时代码创建了一个额外的 chunk，所以它的生成代价较低：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> // ...</span><br><span class="line"> optimization: &#123;</span><br><span class="line">  runtimeChunk: true,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>7、避免额外的优化步骤<br>Webpack 通过执行额外的算法任务，来优化输出结果的体积和加载性能。这些优化适用于小型代码库，但是在大型代码库中却非常耗费性能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> // ...</span><br><span class="line"> optimization: &#123;</span><br><span class="line">  removeAvailableModules: false,</span><br><span class="line">  removeEmptyChunks: false,</span><br><span class="line">  splitChunks: false,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>8、输出结果不携带路径信息<br>Webpack 会在输出的 bundle 中生成路径信息。然而，在打包数千个模块的项目中，这会导致造成垃圾回收性能压力。在 options.output.pathinfo 设置中关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> // ...</span><br><span class="line"> output: &#123;</span><br><span class="line">  pathinfo: false,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>9、Node.js 版本 8.9.10-9.11.1<br>Node.js v8.9.10 - v9.11.1 中的 ES2015 Map 和 Set 实现，存在 性能回退。Webpack 大量地使用这些数据结构，因此这次回退也会影响编译时间。<br>之前和之后的 Node.js 版本不受影响。</p>
<p>10、TypeScript loader<br>你可以为 loader 传入 transpileOnly 选项，以缩短使用 ts-loader 时的构建时间。使用此选项，会关闭类型检查。如果要再次开启类型检查，请使用<br>ForkTsCheckerWebpackPlugin 。使用此插件会将检查过程移至单独的进程，可以加快 TypeScript 的类型检查和 ESLint 插入的速度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> // ...</span><br><span class="line"> test: /\.tsx?$/,</span><br><span class="line"> use: [</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;ts-loader&#x27;,</span><br><span class="line">   options: &#123;</span><br><span class="line">    transpileOnly: true,</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;,</span><br><span class="line">],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>生产环境</strong><br>以下步骤对于 生产环境 特别有帮助。<br>Source Maps<br>source map 相当消耗资源。你真的需要它们？</p>
<h2 id="本篇完–"><a href="#本篇完–" class="headerlink" title="-本篇完–"></a>-本篇完–</h2><p><strong>三、项目实战篇</strong></p>
<p>Webpack与React<br>Webpack与Vue<br>Webpack与jQuery<br>Webpck与Node&#x2F;Express</p>
<p><strong>四、内部原理篇</strong><br>webpack原理<br>开发loader plugin</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/11/28/webpack/webpack%E9%AB%98%E7%BA%A7/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack基础">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/11/24/webpack/webpack%E5%9F%BA%E7%A1%80/">webpack基础</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-11-24
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一-基础感念"><a href="#一-基础感念" class="headerlink" title="一.基础感念"></a>一.基础感念</h2><p>webpack是运行在nodejs中的<br>webpack 的 why 与how</p>
<p>为什么学   （原先script要按顺序）<br>构建打包？习惯使用开箱即用的脚手架来完成项目配置，对开发环境和生产环境的搭建了解知之甚少，前端架构最重要的点在于 前端工程化（webpack就是我们搭建前端环境的技术选型，也是最主流的）</p>
<p>为什么需要使用webpack<br>问题：作用域，文件大（网络瓶颈，短暂白屏），可读性差，可维护性弱</p>
<p>解决：<br>1.作用域：使用grunt和gulp管理项目资源，称之为任务执行器，将所有的项目文件拼接在一起，（利用js的立即调用表达式IIFE）<br>    当函数变成一个立即调用表达式时，表达式的变量是不能在外部访问的，不会污染我们的window环境，解决了作用域问题。<br>    可以通过赋值变量 函数中通过return暴露出来变量获取数据<br><img src="http://hghqz.vip/webpack/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98.jpg" alt="作用域问题" title="作用域问题"></p>
<pre><code>问题使用十行代码可能就要加载万行代码（通过代码拆分解决,模块化，commonjs,amd,cmd,es6）
</code></pre>
<p>node环境语法在浏览器无法加载它不支持commonjs  以及一些其他的语法<br>早期解决方案（页面导入require  define,script标签data-main）<br>现在ECMAscript  通过es6拥有自己的模块化  export default  import from (script 标签指定type&#x3D;”module”)<br>通过http-server搭建一个http请求</p>
<p>es6可能还不太兼容所以使用webpack帮我们打包（vs竞品 parcel称零配置用户一般无需做其他的配置开即聚用 rollup.js用标准化的格式来编写代码es6通过减少无用的代码来尽可能的缩小包的体积，一般只用来打包js  黑马vite vue3使用  有petite vue框架 从开发 编译 发布 demo 几乎全部都是Vite完成的 基于esmodule的构建方式 按需编译 热模块更新  丝滑体验 与vue3原理结合）<br>不会谁取代谁  各有各的应用场景</p>
<h2 id="二-基础应用"><a href="#二-基础应用" class="headerlink" title="二.基础应用"></a>二.基础应用</h2><p><strong>安装使用</strong>（要注意webpack与nodejs版本兼容问题）<br>1.要有nodejs 运行环境<br>2.全局与工作目录下安装<br>    npm install webpack webpack-cli –global  全局 在任何目录都可以运行webpack(不推荐全局使用)<br>    本地安装需要先有npm的包管理的配置文件npm init -y  npm install webpack webpack-cli –save-dev<br><strong>运行</strong><br>1.直接使用 webpack  默认打包  （入口：.&#x2F;src&#x2F;index 出口：dist&#x2F;main.js）<br>2.webpack –stats detailed 可以看到详细的打包信息<br>npx 执行没有找到命令会到上层目录查找</p>
<p><strong>自定义webpack配置</strong><br>webpack –help查看 配置<br>npx 工具概念：<br>命令配置：<br>npx webpack –entry .&#x2F;src&#x2F;index.js –mode production</p>
<p>配置文件配置(webpack.config.js文件名不允许随意起，他是webpack自动读取的)<br><img src="http://hghqz.vip/webpack/%E5%87%BA%E5%85%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.jpg" alt="出入口基本配置" title="出入口基本配置"><br>path需是绝对路径</p>
<h2 id="三-自动引入资源（插件）（html中引入资源）"><a href="#三-自动引入资源（插件）（html中引入资源）" class="headerlink" title="三.自动引入资源（插件）（html中引入资源）"></a>三.自动引入资源（插件）（html中引入资源）</h2><p><strong>什么是插件：</strong><br>webpack就像是一条生产线，需要经过一系列的流程后才能将源文件（入口文件，可以相互依赖（js,css-loaders加载器））经过编译（工具插件plugins 帮助webpack来执行一些特定的任务（打包优化，资源管理））转化成输出的结果</p>
<p>插件：三组（community社区插件   webpack内置官方插件   webpack contrib 第三方插件）</p>
<p><strong>如何使用htmlWebpackPlugin?</strong><br>npm install html-webpack-plugin -D</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin)</span></span><br><span class="line"><span class="string">module.exports=&#123;</span></span><br><span class="line"><span class="string">	plugins:[</span></span><br><span class="line"><span class="string">		new HtmlWebpackPlugin(&#123;</span></span><br><span class="line"><span class="string">			template:&#x27;</span>./index.<span class="property">html</span><span class="string">&#x27;,</span></span><br><span class="line"><span class="string">			filename:&#x27;</span>app.<span class="property">html</span><span class="string">&#x27;,</span></span><br><span class="line"><span class="string">			inject:&#x27;</span>body<span class="string">&#x27;</span></span><br><span class="line"><span class="string">		&#125;)</span></span><br><span class="line"><span class="string">	]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>清理上次dist里的垃圾</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line">	<span class="attr">filename</span>:    ,</span><br><span class="line">	<span class="attr">path</span>:    ,</span><br><span class="line">	<span class="attr">clean</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-搭建开发环境"><a href="#四-搭建开发环境" class="headerlink" title="四.搭建开发环境"></a>四.搭建开发环境</h2><p>解决手工工作：复制index.html路径到地址栏才能访问页面，每次更新代码都需要刷新页面。通过搭建开发环境来解决，提高开发体验</p>
<p>mode:’development’  开发模式   通过代码对环境进行调试（core.js模块）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production webpack --config webpack.config.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack serve&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">const</span> isDev = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;development&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>精准锁定代码出错的位置</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devtool</span>:<span class="string">&#x27;inline-source-map&#x27;</span>,</span><br></pre></td></tr></table></figure>
<p><strong>使用watch mode(观察模式)</strong><br>每次编译都要手动运行npx webpack<br>npx webpack –watch   实时监测编译变化 （需要重新刷新页面）</p>
<p><strong>webpack-dev-server</strong><br>为我们提供了一个最基本的web server，并具有live reloading（实时重新加载）功能。当页面修改了编译后浏览器会监听到文件的修改实现自动刷新<br>npm install webpack-dev-server -D</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>:&#123;</span><br><span class="line">	<span class="attr">devServer</span>:&#123;</span><br><span class="line">		<span class="attr">static</span>: <span class="string">&#x27;./dist&#x27;</span> #server的根目录</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>npx debpack-dev-server –open(自动打开一个页面)  启动项目   实际是吧数据的打包以后的bundle文件放到了内存里。提高开发效率和webpack的编译效率</p>
<h2 id="五-资源模块加载"><a href="#五-资源模块加载" class="headerlink" title="五.资源模块加载"></a>五.资源模块加载</h2><p>内置资源模块asset modules来引入任何的其他类型资源   是一种模块类型  它允许我们用webpack来打包其他的资源文件 如：字体，图标等<br>资源模块类型：asset module type   会通过四种新的类型模块来替换所有的loader<br>1.asset&#x2F;resource他会发送一个单独的文件并导出URL  2.asset&#x2F;inline 它会导出一个资源的Data URL<br>3.asset&#x2F;source 会导出资源的源代码<br>4.asset 通用资源类型 会在导出一个Data URL 和发送一个单独的文件之间自动进行选择</p>
<p>module配置模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line">	<span class="attr">assetModuleFilename</span>:<span class="string">&#x27;images/[contenthash].[ext]&#x27;</span> <span class="comment">//自动生成一个文件名//根据文件的内容来生成一个哈希的字符串</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">	<span class="attr">rules</span>:&#123; <span class="comment">//规则</span></span><br><span class="line">		&#123;  <span class="comment">//配置对象来去加载不同类型的文件</span></span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.png$/&#x27;</span>, <span class="comment">//test 更正则表达式 来加载定义文件的类型</span></span><br><span class="line">		 	<span class="attr">type</span>:<span class="string">&#x27;asset/resource&#x27;</span>,<span class="comment">// 图片为URL格式</span></span><br><span class="line">			<span class="attr">generator</span>:&#123; <span class="comment">// 优先级高于在output 配置的优先级</span></span><br><span class="line">				<span class="attr">filename</span>:<span class="string">&#x27;images/[contenthash].[ext]&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.svg$/&#x27;</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">&#x27;asset/inline&#x27;</span> <span class="comment">//图片为base64格式</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.txt$/&#x27;</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">&#x27;asset/source&#x27;</span> <span class="comment">// 加载文件的源内容</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.jpg$/&#x27;</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>, <span class="comment">//会在导出一个Data URL 和发送一个单独的文件之间自动进行选择   小于8k生成base64  大于8k创建资源</span></span><br><span class="line">			<span class="attr">parser</span>:&#123;</span><br><span class="line">				<span class="attr">dataUrlCondition</span>:&#123;</span><br><span class="line">					<span class="attr">maxSize</span>:<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>  <span class="comment">// 当突变大于4兆在生成一个资源文件  否则的话就是base64</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-loader"><a href="#六-loader" class="headerlink" title="六.loader"></a>六.loader</h2><p>上面采用四种资源模块来引入外部资源<br>webpack还可以通过loader引入其他类型的文件<br>webpack智能理解js和json这样的文件<br>loader可以让webpack去解析其他的类型的文件  并且将这些文件转化为有效的模块  以供我们应用程序的使用  例如加载css</p>
<p><strong>如何使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">	<span class="attr">rules</span>:&#123;</span><br><span class="line">		&#123; <span class="comment">//当碰到通过require或import去解析 .txt文件时在对文件进行打包之前先使用raw-loader进行转化</span></span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.txt$/&#x27;</span>, <span class="comment">// 定义那种类型的文件被转换</span></span><br><span class="line">		 	<span class="attr">use</span>:<span class="string">&#x27;raw-loader&#x27;</span>,  <span class="comment">// 在定义转化的时候应该使用哪个loader来进行转换</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">	<span class="attr">rules</span>:&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.css$/&#x27;</span>,</span><br><span class="line">		 	<span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>],  <span class="comment">// 自下而上 loader链式调用  先需要用css-loader让我们打包没有问题识别我们css文件   在通过style-loader把css放置到我们的页面上</span></span><br><span class="line">		&#125;，</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.(css|less)/$&#x27;</span>,</span><br><span class="line">		 	<span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">		&#125;，</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>抽离和压缩css</strong><br>抽离：npm install mini-css-extract-plugin -D   这个插件时基于webpack5构建的<br>压缩：npm install css-minimizer-webpack-plugin -D  这个属于优化插件在optimization选项配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">mode</span>:<span class="string">&#x27;production&#x27;</span>,   <span class="comment">//使用压缩环境必须时这个</span></span><br><span class="line"><span class="attr">plugins</span>:&#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">		<span class="attr">filename</span>:<span class="string">&#x27;style/[contenthash].css&#x27;</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">	<span class="attr">rules</span>:&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.(css|less)/$&#x27;</span>,</span><br><span class="line">		 	<span class="attr">use</span>:[<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>],  <span class="comment">//之前通过style-loader 将样式放到页面的style 更改为通过link引入的css文件</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">optimization</span>:&#123;</span><br><span class="line">	<span class="attr">minimizer</span>:[</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">CssMinimizerWebpackPlugin</span>()</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加载image图像</strong><br>如何在css里加载图片资源<br>mode:’development’   清除提示</p>
<p><strong>加载fonts字体</strong><br>css3中新增webfont功能可以在css3中去加载一个font字库  然后在代码中就可以定义自己的icon图标了<br>如何去加载字体这样的资源（asset module资源模块）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">test</span>:<span class="string">&#x27;/\.(woff|woff2|eot|ttf|otf)$/&#x27;</span>,  <span class="comment">//字体文件会有很多种类型</span></span><br><span class="line">	<span class="attr">type</span>:<span class="string">&#x27;asset/resource&#x27;</span>  <span class="comment">//载入任何类型的资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://hghqz.vip/webpack/%E5%AD%97%E4%BD%93%E9%85%8D%E7%BD%AE.jpg" alt="字体配置" title="字体配置"></p>
<p>之后向文本一样去加载一个文本代码  <span class='icon'>&amp;#xe668;</span>(操作dom时必须是innerhtml不能使innertext)</p>
<p><strong>加载数据</strong><br>之前图片  cion图标  文本文件等等都数据<br>还有类似于json，csv，tsv，xml等，json和nodejs类似webpack可以直接支持但是像csv，tsv和xml我都没需要使用loader才能处理他们<br>npm install csv-loader xml-loader -D</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">text</span>:<span class="string">&#x27;/\.(tsv|csv)$/&#x27;</span>, <span class="comment">//会转换成 数组 </span></span><br><span class="line">	<span class="attr">use</span>:<span class="string">&#x27;csv-loader&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">text</span>:<span class="string">&#x27;/\.xml$/&#x27;</span>,  <span class="comment">//会转换成 js对象</span></span><br><span class="line">	<span class="attr">use</span>:<span class="string">&#x27;xml-loader&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义JSON模块parser</strong><br>通过使用自定义parser替代指定的webpack loader，可以将任何toml，yaml，或json5文件作为JSON模块导入。<br>npm install toml yaml json5 -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const toml = require(&#x27;toml&#x27;)</span><br><span class="line">const yaml = require(&#x27;yaml&#x27;)</span><br><span class="line">const json5 = require(&#x27;json5&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">	text:&#x27;/\.toml$/&#x27;,  //会转换成 js对象</span><br><span class="line">	type:&#x27;json&#x27;,</span><br><span class="line">	parser:&#123;</span><br><span class="line">		parse:toml.parse</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	text:&#x27;/\.yaml$/&#x27;,  //会转换成 js对象</span><br><span class="line">	type:&#x27;json&#x27;,</span><br><span class="line">	parser:&#123;</span><br><span class="line">		parse:yaml.parse</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	text:&#x27;/\.json5$/&#x27;,  //会转换成 js对象</span><br><span class="line">	type:&#x27;json&#x27;,</span><br><span class="line">	parser:&#123;</span><br><span class="line">		parse:json5.parse</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七-如何使用babel-loader"><a href="#七-如何使用babel-loader" class="headerlink" title="七.如何使用babel-loader"></a>七.如何使用babel-loader</h2><p>webpack默认转换  是源代码原封不动进行转换的  那么如果浏览器不兼容呢？<br>使用babel-loader将es6 转换成低版本浏览器能够识别的js代码<br>npm install babel-loader @babal&#x2F;core @babel&#x2F;preset-env -D<br>babel-loader: 解析es6的桥梁<br>@babal&#x2F;core babel： 核心模块<br>@babel&#x2F;preset-env： babel预设，一组Babel插件的集合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">test</span>:<span class="string">&#x27;/\.js$/&#x27;</span>,</span><br><span class="line">	<span class="attr">exclude</span>:<span class="string">&#x27;/node_modules/&#x27;</span>,<span class="comment">//业务里既可以加载本地js也可以加载全局里的node modules里面的js  对于全局的node modules里的js我们是不需要进行babel-loader的编译的  所以需要排除 node modules 里的代码</span></span><br><span class="line">	<span class="attr">use</span>:&#123;</span><br><span class="line">		<span class="attr">loader</span>:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">			<span class="attr">options</span>:&#123;</span><br><span class="line">				<span class="attr">presets</span>:[<span class="string">&#x27;@babel/preset-env&#x27;</span>],</span><br><span class="line">				<span class="attr">plugins</span>:[</span><br><span class="line">					[<span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span>]</span><br><span class="line">				]</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>regeneratorRuntime是webpack打包生成的全局辅助函数，有babel生成，用于兼容async&#x2F;await的语法<br>npm install @babel&#x2F;runtime -D<br>插件： npm install @babel&#x2F;plugin-transform-runtime -D<br>@babel&#x2F;runtime： 包含了regeneratorRuntime运行时需要的内容<br>@babel&#x2F;plugin-transform-runtime： 会在需要regeneratorRuntime的地方自动require打包然后编译的时候就会需要它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">					[&#x27;@babel/plugin-transform-runtime&#x27;]</span><br><span class="line">				]</span><br></pre></td></tr></table></figure>

<h2 id="八-代码分离"><a href="#八-代码分离" class="headerlink" title="八.代码分离"></a>八.代码分离</h2><p>能够把代码分离到不同的bundle中<br>bundle就是我们打包分离出来的文件然后我们把这些文件按需加载或者是并行加载<br>代码分离可以用于获取更小的bundle以及控制资源加载的优先级，如果使用合理会极大的影响加载事件<br>常用的代码分离：1.配置入口节点，使用entry来手动配置分离代码（如果是多个入口那么这些多个入口共享的文件会分别在每个包里面去重复打包）<br>2.防止重的分离方法：在entry（入口）的地方通过entry dependencies或者 SplitChunksPlagin去重和分离代码<br>3.动态导入 通过模块的内联函数import来调用这个函数分离代码</p>
<p><strong>第一种</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entry</span>:&#123;</span><br><span class="line">	<span class="attr">index</span>:<span class="string">&#x27;./src/index&#x27;</span>,</span><br><span class="line">	<span class="attr">another</span>:<span class="string">&#x27;./src/another-module.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line">	<span class="attr">filename</span>:<span class="string">&#x27;[name]&#x27;</span>.<span class="property">bundle</span>.<span class="property">js</span>,   <span class="comment">//方式多个入口打包出口文件冲突，使用[&#x27;name&#x27;]可以拿到我们入口里面的key的名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span>（_.<span class="title function_">join</span>([<span class="string">&#x27;Vue&#x27;</span>,<span class="string">&#x27;React!&#x27;</span>],<span class="string">&#x27;-&#x27;</span>)）</span><br></pre></td></tr></table></figure>
<p><strong>第二种 防止重复</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 1.entry dependencies</span><br><span class="line">entry:&#123;</span><br><span class="line">	index:&#123;</span><br><span class="line">		import :&#x27;./src/index&#x27;,</span><br><span class="line">		dependOn:&#x27;shared&#x27;,  //可以把一些共享的文件给定义出来</span><br><span class="line">	&#125;,</span><br><span class="line">	another:&#123;</span><br><span class="line">		import :&#x27;./src/another-module.js&#x27;,</span><br><span class="line">		dependOn:&#x27;shared&#x27;,  //可以把一些共享的文件给定义出来</span><br><span class="line">	&#125;</span><br><span class="line">	shared:&#x27;lodash&#x27; //当我们这两个模块里边 有lodash这个模块的时候  他就会把他抽离出来  并且把他取名为叫shared这样的一个chunk。</span><br><span class="line">&#125;</span><br><span class="line">//2.SplitChunksPlagin插件</span><br><span class="line">entry:&#123;</span><br><span class="line">	index:&#x27;./src/index&#x27;,</span><br><span class="line">	another:&#x27;./src/another-module.js&#x27;</span><br><span class="line">&#125;</span><br><span class="line">optimization:&#123;</span><br><span class="line">	splitChunks:&#123;</span><br><span class="line">		chunks:&#x27;all&#x27;  //实现代码分割并把公共的代码 抽离到一个单独的文件里</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>第三种</strong><br>使用  ECMAScript提案的import()函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function getComponent()&#123;</span><br><span class="line">	return import(&#x27;lodash&#x27;)   // 返回的是一个Promise对象</span><br><span class="line">	.then((&#123;default:_&#125;)=&gt;&#123;    // .then的回调函数拿到的是 载入的lodash的一个引用</span><br><span class="line">		const element = document.createElement(&#x27;div&#x27;)</span><br><span class="line">		element.innerHTML = _.join([&#x27;Vue&#x27;,&#x27;React!&#x27;],&#x27;-&#x27;)</span><br><span class="line">		return element</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"> // 这样写的目的是为了让 import 来去帮助我们去抽离一个单独的lodash文件</span><br><span class="line">getComponent().then((element)=&gt;&#123;</span><br><span class="line">	document.body.appendChild(element)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 静态导入的内容和动态导入的内容一起来 去做代码抽离</span><br><span class="line">optimization:&#123;</span><br><span class="line">	splitChunks:&#123;</span><br><span class="line">		chunks:&#x27;all&#x27;  //实现代码分割并把公共的代码 抽离到一个单独的文件里</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>为什么使用动态导入，静态导入不就行了吗？动态导入的应用</strong><br>1.可以实现懒加载： 按需加载，是一种很好的优化页面或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会加载。<br><img src="http://hghqz.vip/webpack/import%E6%87%92%E5%8A%A0%E8%BD%BD.jpg" alt="import懒加载" title="import懒加载"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//懒加载</span><br><span class="line">import(/* webpackChunkName: &#x27;打包后的文件名&#x27;*/&#x27;文件地址&#x27;).then(回调)//通过注释 控制懒加载打包后的文件名  +bundle.js</span><br></pre></td></tr></table></figure>

<p>2.可以实现预获取&#x2F;预加载模块<br>webpack v4.6.0+ 增加了对预获取和预加载的支持。<br>在声明import时，使用下面这些内置指令，可以让webpack输出”resource hint(资源提示)”,来告诉浏览器：<br>prefetch(预获取)：将来某些导航下可能需要的资源<br>preload(预加载)：当前导航下可能需要资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 预获取   意义首页面的内容都加载完毕在网络空闲的时候再去加载我们打包好的 文件     比懒加载还要优秀</span><br><span class="line">import(/* webpackChunkName: &#x27;打包后的文件名&#x27;, webpackPrefetch:true*/&#x27;文件地址&#x27;)</span><br><span class="line">// 预加载   和懒加载类似   实现页面模块的并行加载</span><br><span class="line">import(/* webpackChunkName: &#x27;打包后的文件名&#x27;, webpackPreload:true*/&#x27;文件地址&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="九-缓存"><a href="#九-缓存" class="headerlink" title="九.缓存"></a>九.缓存</h2><p>以前我们使用webpack来打包我们模块化以后的应用程序，webpack会生成一个可以部署的dist目录。然后我们把打包好的内容放置到这个目录里将来我们把这个目录的内容部署到server上也就是服务器上，浏览器就可以访问我们这个服务器上的网站和资源了，而最后一步获取资源是比较耗时间的，这就是为什么浏览器会使用缓存的技术，可以通过命中缓存以降低网络流量，使网站加载速度更快，然而我们在部署新版本的时候不更改资源的文件名，浏览器可能会认为你没有更新，那就会使用它的缓存版本，由于缓存的存在，我们需要获取新的代码的时候，就会显的很棘手，<br>现在我们通过webpack配置来确保编译生成的文件能够被客户端缓存而在文件优化的时候又能够请求新的文件。<br>问题：在dist文件里看到打包好以后的文件，浏览器有缓存特性会把文件缓存下来，但是如果我们修改了这个文件里的内容，而文件名没有变，浏览器会认为我们没有修改这个文件，所以我们必须在打包的时候把这个文件的名字也一同给重新打包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line">	<span class="attr">filename</span>:<span class="string">&#x27;[name].[contenthash].js&#x27;</span>  <span class="comment">//文件名 会跟随这我们文件内容的变化而变化，这样的话就不怕浏览器缓存了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缓存第三方库代码，如：lodash需不需要缓存</strong><br>缓存自己的业务逻辑代码，第三方的代码比如lodash需不需要缓存。<br>如果我们把lodash单独提取到一个vendor chunk里边，是比较推荐的方法，这是因为他们很少像本地源代码那样频繁修改。因此通过以上的步骤，我们利用client或浏览器的长效缓存的机制，命中的缓存来消除请求。从而减少向server获取资源的次数同时还能保证client代码和server代码版本的一致。<br>把第三方库的代码像lodash单独打包缓存到浏览器里，这样只有我们自己代码发生变化的时候我们可以去更新但是第三方的代码始终可以是浏览器缓存的内容，那就需要对第三方的代码做一个缓存。<br>对文件进行单独打包并缓存到浏览器里，代码（文件内容以及文件名都是不变的）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">optimization</span>:&#123;</span><br><span class="line">	splitChunks：&#123;</span><br><span class="line">		<span class="attr">cacheGroups</span>:&#123;    <span class="comment">//定义缓存组    缓存第三方文件（node_modules里的）</span></span><br><span class="line">			<span class="attr">vendor</span>:&#123;</span><br><span class="line">				<span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>  <span class="comment">//通过文件目录的文件名去识别   这个目录的前面后面可能会有斜线</span></span><br><span class="line">				<span class="attr">name</span>:<span class="string">&#x27;vendors&#x27;</span>,</span><br><span class="line">				<span class="attr">chunks</span>:<span class="string">&#x27;all&#x27;</span>         <span class="comment">// 定义那些chunk做处理</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将所有的js文件，放到一个文件夹中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">	filename:&#x27;scripts/[name].[contenthash].js&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：缓存业务代码：当我们的项目部署到服务器上的时候，浏览器加载完我们服务器上的文件会缓存我们打包好的模块。这样如果我们修改了js代码，文件名如果没变，浏览器会使用用户本地缓存的内容，就获取不到新的内容了。因此我们通过修改输出文件的文件名来解决   使用可替换模板字符串方法来定义contenthash   实现只要文件的内容不变哈希的字符串也不变<br>缓存第三方代码：这些文件不频繁更新  可以提高我们首屏的打开速度 节省我们网络流量</p>
<h2 id="十-拆分开发环境和生产环境的配置-让打包变得更灵活"><a href="#十-拆分开发环境和生产环境的配置-让打包变得更灵活" class="headerlink" title="十.拆分开发环境和生产环境的配置  让打包变得更灵活"></a>十.拆分开发环境和生产环境的配置  让打包变得更灵活</h2><p>平常我们都是手动的调整mode选项  实现生产环境和开发环境的切换<br>很多配置在生产环境和开发环境存在不一致的情况如：开发环境没有必要设置缓存，生产环境还需要设置公共路径等</p>
<p><strong>公共路径</strong><br>publicPash 配置选项在各种场景中都非常有用，可以通过它来指定应用程序中所有资源的基础路径</p>
<p>现在所有的资源都是通过相对路径来去引用的。我们可不可以根据cdn的路径或者当前服务器的某个路径 来去修改我们link上面的这个路径的前缀。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">	publicPash: &#x27;http://localhost:8080/&#x27;    // 指定一个域名    这个域名可以指定为项目的前端域名，或者cdn服务器的域名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>环境变量</strong><br>可以帮助我们清除webpack.config.js这个配置文件里边的开发环境和生产环境之间的差异<br>在命令行 npx webpack –env production (–env goal&#x3D;local)    知道用户在开发环境使用还是生产环境使用  配置对应的mode选项<br>将导出的对象变为函数，函数拿到env   生产环境代码压缩  开发环境代码不压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode:env.production?&#x27;production&#x27;:&#x27;development&#x27;</span><br></pre></td></tr></table></figure>
<p>webpack开箱即用的terser插件进行压缩js代码  当我们配置minimizer压缩css代码时  terser功能失效<br>npm install terser-webpack-plugin -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;)</span><br><span class="line">optimization:&#123;</span><br><span class="line">	minimizer:&#123;</span><br><span class="line">		//此处时压缩css的插件</span><br><span class="line">		new TerserPlugin()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拆分配置文件</strong><br>我们使用环境变量将webpack中的生产环境和开发环境的区别都通过三元运算符判断  很糟糕<br>我们将配置文件拆分成两个配置  一个生产环境  一个开发环境<br>只当启动配置文件 npx webpack -c .&#x2F;config&#x2F;webpack.config.dev.js</p>
<p><strong>npm脚本</strong><br>每次打包或者启动服务的时候 都需要在命令行里输入一长串的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package.json文件</span><br><span class="line">&#123;</span><br><span class="line">	&quot;scripts&quot;:&#123;</span><br><span class="line">		&quot;start&quot;:&quot;npx webpack serve -c ./config/webpack.config.dev.js --env development&quot;,</span><br><span class="line">		&quot;build&quot;:&quot;npx wenpack -c ./config/webpack.config.prod.js --env production&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产环境进行打包  提示我们在打包的时候超过了打包的预期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performance:&#123;   // 性能方面配置</span><br><span class="line">	hints:false   //性能提示去掉</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提取公共配置</strong><br>开发环境和生产环境  配置有大量的重复代码   把这些重复代码单独抽到一个配置文件里<br>npm install webpack-merge -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.common.js   //通过深merge进行合并三个文件   插件：webpack-merge</span><br><span class="line">webpack.config.js   //这里合并三个文件</span><br><span class="line">const &#123;merge&#125; = require(&#x27;webpack-merge&#x27;)</span><br><span class="line">const commonConfig = require(&#x27;./webpack.config.common.js&#x27;)</span><br><span class="line">const developmentConfig = require(&#x27;./webpack.config.dev.js&#x27;)</span><br><span class="line">const productionConfig = require(&#x27;./webpack.config.prod.js&#x27;)</span><br><span class="line">module.exports = (env)=&gt;&#123;</span><br><span class="line">	switch(true)&#123;</span><br><span class="line">		case env.development:</span><br><span class="line">			return merge(commonConfig,developmentConfig)</span><br><span class="line">		case env.production:</span><br><span class="line">			return merge(commonConfig,productionConfig)</span><br><span class="line">		default:</span><br><span class="line">			return new Error(&#x27;没有找到对应的配置环境&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/11/24/webpack/webpack%E5%9F%BA%E7%A1%80/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack构建流程">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/11/20/webpack/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/">webpack构建流程</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-11-20
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
                <a href="/tags/%E5%89%8D%E7%AB%AF/" class="cube-excerpt-tag-link">#前端</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、运行流程"><a href="#一、运行流程" class="headerlink" title="一、运行流程"></a>一、运行流程</h2><p><code>webpack</code> 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来</p>
<p>在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条<code>webpack</code>机制中，去改变<code>webpack</code>的运作，使得整个系统扩展性良好</p>
<p>从启动到结束会依次执行以下三大步骤：</p>
<ul>
<li>初始化流程：从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>
<li>编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li>
<li>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</li>
</ul>
<p><img src="https://static.vue-js.com/b566d400-a658-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p>从配置文件和 <code>Shell</code> 语句中读取与合并参数，得出最终的参数</p>
<p>配置文件默认下为<code>webpack.config.js</code>，也或者通过命令的形式指定配置文件，主要作用是用于激活<code>webpack</code>的加载项和插件</p>
<p>关于文件配置内容分析，如下注释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> node_modules = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;node_modules&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> pathToReact = path.<span class="title function_">resolve</span>(node_modules, <span class="string">&#x27;react/dist/react.min.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>，</span><br><span class="line">  <span class="comment">// 文件路径指向(可加快打包过程)。</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;react&#x27;</span>: pathToReact</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生成文件，是模块构建的终点，包括输出文件与输出路径。</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">loaders</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel&#x27;</span>,</span><br><span class="line">        <span class="attr">query</span>: &#123;</span><br><span class="line">          <span class="attr">presets</span>: [<span class="string">&#x27;es2015&#x27;</span>, <span class="string">&#x27;react&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">noParse</span>: [pathToReact]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// webpack 各插件对象，在 webpack 的事件流中执行对应的方法。</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack` 将 `webpack.config.js` 中的各个配置项拷贝到 `options` 对象中，并加载用户配置的 `plugins</span><br></pre></td></tr></table></figure>

<p>完成上述步骤之后，则开始初始化<code>Compiler</code>编译对象，该对象掌控者<code>webpack</code>声明周期，不执行具体的任务，只是进行一些调度工作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Tapable</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">context</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">            <span class="attr">beforeCompile</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;params&quot;</span>]),</span><br><span class="line">            <span class="attr">compile</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&quot;params&quot;</span>]),</span><br><span class="line">            <span class="attr">afterCompile</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;compilation&quot;</span>]),</span><br><span class="line">            <span class="attr">make</span>: <span class="keyword">new</span> <span class="title class_">AsyncParallelHook</span>([<span class="string">&quot;compilation&quot;</span>]),</span><br><span class="line">            <span class="attr">entryOption</span>: <span class="keyword">new</span> <span class="title class_">SyncBailHook</span>([<span class="string">&quot;context&quot;</span>, <span class="string">&quot;entry&quot;</span>])</span><br><span class="line">            <span class="comment">// 定义了很多不同类型的钩子</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">webpack</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> compiler = <span class="keyword">new</span> <span class="title class_">Compiler</span>();</span><br><span class="line">  ...<span class="comment">// 检查options,若watch字段为true,则开启watch线程</span></span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>Compiler</code> 对象继承自 <code>Tapable</code>，初始化时定义了很多钩子函数</p>
<h3 id="编译构建流程"><a href="#编译构建流程" class="headerlink" title="编译构建流程"></a>编译构建流程</h3><p>根据配置中的 <code>entry</code> 找出所有的入口文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/file.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成后会调用<code>Compiler</code>的<code>run</code>来真正启动<code>webpack</code>编译构建流程，主要流程如下：</p>
<ul>
<li><code>compile</code> 开始编译</li>
<li><code>make</code> 从入口点分析模块及其依赖的模块，创建这些模块对象</li>
<li><code>build-module</code> 构建模块</li>
<li><code>seal</code> 封装构建结果</li>
<li><code>emit</code> 把各个chunk输出到结果文件</li>
</ul>
<h4 id="compile-编译"><a href="#compile-编译" class="headerlink" title="compile 编译"></a>compile 编译</h4><p>执行了<code>run</code>方法后，首先会触发<code>compile</code>，主要是构建一个<code>Compilation</code>对象</p>
<p>该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象</p>
<h4 id="make-编译模块"><a href="#make-编译模块" class="headerlink" title="make 编译模块"></a>make 编译模块</h4><p>当完成了上述的<code>compilation</code>对象后，就开始从<code>Entry</code>入口文件开始读取，主要执行<code>_addModuleChain()</code>函数，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">_addModuleChain</span>(<span class="params">context, dependency, onModule, callback</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 根据依赖查找对应的工厂函数</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title class_">Dep</span> = <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">DepConstructor</span>&#125; */</span> (dependency.<span class="property">constructor</span>);</span><br><span class="line">   <span class="keyword">const</span> moduleFactory = <span class="variable language_">this</span>.<span class="property">dependencyFactories</span>.<span class="title function_">get</span>(<span class="title class_">Dep</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象</span></span><br><span class="line">   moduleFactory.<span class="title function_">create</span>(&#123;</span><br><span class="line">       <span class="attr">dependencies</span>: [dependency]</span><br><span class="line">       ...</span><br><span class="line">   &#125;, <span class="function">(<span class="params">err, <span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">const</span> <span class="title function_">afterBuild</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">processModuleDependencies</span>(<span class="variable language_">module</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line">         <span class="title function_">callback</span>(<span class="literal">null</span>, <span class="variable language_">module</span>);</span><br><span class="line">           &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">       </span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">buildModule</span>(<span class="variable language_">module</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">           <span class="title function_">afterBuild</span>();</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<p><code>_addModuleChain</code>中接收参数<code>dependency</code>传入的入口依赖，使用对应的工厂函数<code>NormalModuleFactory.create</code>方法生成一个空的<code>module</code>对象</p>
<p>回调中会把此<code>module</code>存入<code>compilation.modules</code>对象和<code>dependencies.module</code>对象中，由于是入口文件，也会存入<code>compilation.entries</code>中</p>
<p>随后执行<code>buildModule</code>进入真正的构建模块<code>module</code>内容的过程</p>
<h4 id="build-module-完成模块编译"><a href="#build-module-完成模块编译" class="headerlink" title="build module 完成模块编译"></a>build module 完成模块编译</h4><p>这里主要调用配置的<code>loaders</code>，将我们的模块转成标准的<code>JS</code>模块</p>
<p>在用<code>Loader</code> 对一个模块转换完后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便 <code>Webpack</code>后面对代码的分析</p>
<p>从配置的入口模块开始，分析其 <code>AST</code>，当遇到<code>require</code>等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系</p>
<h3 id="输出流程"><a href="#输出流程" class="headerlink" title="输出流程"></a>输出流程</h3><h4 id="seal-输出资源"><a href="#seal-输出资源" class="headerlink" title="seal 输出资源"></a>seal 输出资源</h4><p><code>seal</code>方法主要是要生成<code>chunks</code>，对<code>chunks</code>进行一系列的优化操作，并生成要输出的代码</p>
<p><code>webpack</code> 中的 <code>chunk</code> ，可以理解为配置在 <code>entry</code> 中的模块，或者是动态引入的模块</p>
<p>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表</p>
<h4 id="emit-输出完成"><a href="#emit-输出完成" class="headerlink" title="emit 输出完成"></a>emit 输出完成</h4><p>在确定好输出内容后，根据配置确定输出的路径和文件名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Compiler</code> 开始生成文件前，钩子 <code>emit</code> 会被执行，这是我们修改最终文件的最后一个机会</p>
<p>从而<code>webpack</code>整个打包过程则结束了</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://static.vue-js.com/d77fc560-a658-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/11/20/webpack/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack概念">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/11/14/webpack/webpack%E6%A6%82%E5%BF%B5/">webpack概念</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-11-14
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="一、webpack概述"><a href="#一、webpack概述" class="headerlink" title="一、webpack概述"></a>一、webpack概述</h1><h2 id="1-什么是webpack？"><a href="#1-什么是webpack？" class="headerlink" title="1. 什么是webpack？"></a>1. 什么是webpack？</h2><p>webpack被定义为现代 JavaScript 应用程序的静态模块打包器(module bundler)，是目前最为流行的JavaScript打包工具之一。</p>
<p>webpack会以一个或多个js文件为入口，递归检查每个js模块的依赖，从而构建一个依赖关系图(dependency graph)，然后依据该关系图，将整个应用程序打包成一个或多个bundle。</p>
<p>由于webpack是用nodejs编写的，所以它依赖的运行环境就是nodejs。也正因为这一点，webpack只能识别JavaScript，所有非JavaScript（包括HTML，CSS，Typescript等）编写的文件都需要经过处理，这是借助对应的loader实现的。</p>
<p>webpack使用的是nodejs默认的模块系统：commonjs，借助nodejs提供的API来操作待打包项目的源文件（如fs模块、path模块等）。webpack将这些文件整合压缩后，输出到一个特定的目录下（通常是dist）。处理过的dist一般会被直接上传到静态资源服务器使用。</p>
<p>webpack 是一个开源的前端包工具。webpack 提供了前端开发缺乏的模块化开发方式,将各种静态资源视为模块,并从它生成优化过的代码。 要使用 webpack 前须先安装 node.js。</p>
<p>webpack是前端的一个自动化工具,有了它可以大大提高写项目的效率,可以对css,js文件进行自动压缩,把sass代码自动解析成对应的css文件,让你的代码和样式实时的显示在浏览器上,当然,我们使用webpack的目的还是为了项目完成后进行打包,webpack并不强制使用AMD或者CMD这之中的某一种方案,而是通过兼容所有模块化方案让你可以按需接入项目，有了webpack，你可以随意选择你喜欢的模块化方案，至于怎么处理模块之间的依赖关系及如何按需打包，webpack会帮你处理好。</p>
<h2 id="2-为什么要使用webpack？"><a href="#2-为什么要使用webpack？" class="headerlink" title="2. 为什么要使用webpack？"></a>2. 为什么要使用webpack？</h2><p>第一，未打包的项目通常体积庞大，文件数量众多。如果将其直接上传到服务器，用户访问网站时，浏览器会发送大量的http请求来下载这些文件，这会给服务器带来很大的压力，同时客户端的体验也非常不好。</p>
<p>第二，浏览器本身不支持任何模块系统。因此，使用模块系统开发出的JavaScript代码无法直接在浏览器中运行，而模块系统对现代JavaScript开发是非常重要的。这样，我们需要有一个工具，将模块系统编写出的代码转化为浏览器所能识别的代码。webpack就可以完成这一任务。</p>
<p>第三，大多数情况下，我们不希望源代码暴露给用户，即使是保密性要求不那么高的前端代码。我们知道，PC端浏览器通常都提供开发者工具，可以方便地查看和调试前端代码，这在开发环境下意义重大。但对于生产环境，暴露源代码不仅没有太大意义，反而存在安全隐患（如果黑客比你更先发现代码中的bug，你可能面临严重损失）。因此，我们可以借助webpack重组和混淆源代码，增加黑客阅读源代码的难度，以提升系统的安全性。</p>
<p>第四，借助webpack提供的dev-server，可以实现前后端分离。dev-server本质上就是一个node服务。当通过命令行启用dev-server时，webpack会在本地启动一个node服务，将打包后的文件作为静态资源注入该服务，这样就可以在不依赖后台（这种说法并不完全准确，实际上webpack是通过node为你提供后台服务）的情况下进行前端开发了。</p>
<p>除了以上这些，webpack还有很多强大的功能，这里暂不详述。</p>
<h2 id="3-工作原理"><a href="#3-工作原理" class="headerlink" title="3. 工作原理"></a>3. 工作原理</h2><p>简单的说就是分析代码，找到“require”、“exports”、“define”等关键词，并替换成对应模块的引用。</p>
<p>在一个配置文件中，指明对某些文件进行编译、压缩、组合等任务。把你的项目当成一个整体，通过一个给定的主文件 （index.js），webpack将从这个文件开始找到你的项目的所有的依赖文件，使用loaders处理他们，最后打包为一个浏览器可以识别的js文件。</p>
<p>流程细节<br>Webpack的构建流程可以分为以下三个阶段：</p>
<ol>
<li>初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier.</li>
<li>编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。</li>
<li>输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。<br> 如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下：<br> <img src="http://hghqz.vip/webpack/%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.jpg" alt="打包流程" title="打包流程"></li>
</ol>
<h2 id="4-webpack的优缺点？"><a href="#4-webpack的优缺点？" class="headerlink" title="4. webpack的优缺点？"></a>4. webpack的优缺点？</h2><p>优点：<br>（1） webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。<br>（2）能被模块化的不仅仅是 JS 了。<br>（3） 开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。<br>（4）扩展性强，插件机制完善<br>缺点：<br>● 配置复杂<br>● 不分包bundle.js体积庞大<br>● 只能用于采用模块化开发的项目<br>● 打包慢<br>● ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译</p>
<h2 id="5-基本配置"><a href="#5-基本配置" class="headerlink" title="5. 基本配置"></a>5. 基本配置</h2><p>要在项目中使用webpack，需要首先安装nodejs，它是webpack的运行环境。nodejs安装成功后，就可以通过npm install webpack -g来全局安装webpack。这样就可以在你的项目中使用webpack了。</p>
<p>在项目中使用webpack的核心是编写配置文件。配置文件通常命名为webpack.config.js，是一个符合commonjs规范的js文件。该文件通过module.exports暴露出一个js对象，我们称这个对象为webpack的配置对象（options）。webpack会根据这个配置对象来决定如何打包项目。</p>
<p>配置对象中包含四个核心参数：</p>
<p>入口（entry）Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图<br>出口（output）output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名<br>加载器（loader）Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript)<br>插件（plugin） plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等<br>插件（mode） mode:模式指示webpack使用相应模式的配置</p>
<h3 id="1-入口（entry）"><a href="#1-入口（entry）" class="headerlink" title="1. 入口（entry）"></a>1. 入口（entry）</h3><p>顾名思义，它定义了webpack的打包入口，也就是webpack从哪个js开始打包。</p>
<p>一个应用程序可以有一个或多个入口，由entry属性指定，通常是一个对象。如果这个对象内只包含了一个入口，也可以简写为一个字符串（或字符串数组）。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &quot;./src/main.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以简写为:</span><br><span class="line">  entry: &quot;./src/main.js&quot;</span><br></pre></td></tr></table></figure>
<p>上述配置定义src目录下的main.js为打包入口，webpack将从这个文件开始，构建整个项目的依赖关系图。</p>
<p>一个应用程序可以有多个打包入口，常见的场景如多页应用，独立打包第三方库等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  app: &#x27;./src/app.js&#x27;,</span><br><span class="line">  vendors: &#x27;./src/vendors.js&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置，要求webpack分别以app.js和vendors.js为打包入口，独立构建依赖关系图。最终，项目代码和第三方代码将被独立打包出来。构建多页应用时，也是分别为每个页面提供一个入口文件，独立构建依赖图。</p>
<p>此外，入口参数允许传入字符串数组。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: [&quot;./src/main1.js&quot;, &quot;./src/main2.js&quot;]</span><br></pre></td></tr></table></figure>
<p>这两个文件都是应用的主入口，它们会被打包生成到同一个chunk文件中。当主入口文件过于庞大，需要拆分成多个，但希望它们输出到同一个打包文件时可以使用。</p>
<h3 id="2-出口（output）"><a href="#2-出口（output）" class="headerlink" title="2. 出口（output）"></a>2. 出口（output）</h3><p>也就是webpack的输出，由output属性定义。</p>
<p>与入口不同的是，一个应用程序只能有一个出口。出口是一个对象，包含两个属性：filename和path，分别定义打包结果的文件名和输出位置。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &quot;./src/main.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname + &#x27;/dist&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上配置定义main.js为应用的入口文件，最终输出的文件名为bundle.js，输出位置是当前路径下的dist文件夹。</p>
<p>当应用程序由多个打包入口时，产生的输出结果也会有很多个，一一为每个文件指定文件名非常不灵活。为此，webpack允许使用占位符来定义文件名。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#x27;./src/app.js&#x27;,</span><br><span class="line">    search: &#x27;./src/search.js&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname + &#x27;/dist&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打包将输出app.js和search.js两个文件</span><br></pre></td></tr></table></figure>
<p>这里filename的值中[name]就是使用了占位符，webpack会将其替换成入口文件的文件名。因此，app.js和search.js这两个入口文件在打包后会在dist文件夹下生成两个同名文件。</p>
<p>当然，我们几乎从来不会这样定义filename，因为固定的文件名无法用于热更新（HMR，Hot Module Replacement，直译为模块热替换）。热更新的实现机制如下：</p>
<p>在一份清单文件（manifest文件）中列举所有依赖的模块，每个模块对应的文件名中带有一个版本号，如chunk.1.0.0.js。<br>当某个模块发生修改，就重新打包该模块，并修改对应文件名中的版本号，如chunk.1.0.1.js。此时文件名就发生了变化。<br>热更新机制检测到清单文件中的文件名发生变化，就会重新下载和更新该模块，文件名没有变化的模块不会被重新下载。这样应用就得到了更新。<br>由于webpack不需要对每次的代码修改都进行版本管理，所以它只需要向文件名中插入一个随机的hash值即可。这个hash值每次重新打包都会变化，以保证热更新机制可以正确更新。假如某次打包后的文件名为app.23j3j2366842h76ewhd.js，随后我们对该模块进行了修改，重新打包后webpack插入了一个新的hash值，得到app.er234hh9hydyt586.js。热更新模块检测到文件名变化，就会自动下载这个新的js文件，来更新应用的状态。</p>
<p>此时的出口一般写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#x27;./src/app.js&#x27;,</span><br><span class="line">    search: &#x27;./src/search.js&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].[hash].js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname + &#x27;/dist&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会输出两个类似于app.57bjs8k8rfht7.js和search.su774fju83jur.js的打包结果，它们会被添加到一份清单文件。每当修改模块的内容，webpack都会重新打包，生成新的hash值，并更新清单文件，这样热更新机制就可以生效了。</p>
<p>注意，使用splitChunk进行代码分割时，被分割出来的代码默认命名为chunk.[hash].js。</p>
<h3 id="3-加载器（loader）"><a href="#3-加载器（loader）" class="headerlink" title="3. 加载器（loader）"></a>3. 加载器（loader）</h3><p>在介绍加载器之前，我们先来看webpack打包时会遇到的一个问题。</p>
<p>在概述中我们已经讲到，webpack的运行环境是nodejs，因此它只能识别JavaScript。但是我们的项目中可能存在大量的非JavaScript文件，如HTML、CSS、Typescript、txt，甚至图片文件等。</p>
<p>有人可能会说，webpack又不需要执行这些文件，直接输出到dist目录下不就行了吗？</p>
<p>如果这些非JavaScript文件只被js文件引用，而他们之间互相没有依赖关系，webpack确实没必要解析他们。但当它们存在依赖关系时，问题就不这么简单了，如：<br>index.css</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;./color.css&quot;</span><br></pre></td></tr></table></figure>
<p>这里index.css中引入了color.css。我们假设index.css是在js中引入的，那么webpack在解析js时自然会把index.css添加到依赖关系图中。</p>
<p>可是webpack运行在nodejs环境下，它无法解析index.css的内容，因此它不知道index.css内部还依赖了color.css。这样，color.css就无法被添加到依赖关系图中，而不在依赖关系图中的文件在打包时将被舍弃。也即是说，webpack最终打包出的代码中不会包含color.css。</p>
<p>这显然是错误的，我们需要color.css。</p>
<p>为了解决这个问题，我们需要一些额外的代码帮助webpack识别css文件中的依赖。我们会编写一个函数，它将index.css读取为一个字符串，然后转化成js（注意，转化成js只是为了让webpack解析依赖关系，因此转化出的js与原css并不等价）输出出来，这样webpack就可以解析了。而这个用于转换的函数，就称为一个loader。</p>
<p>所以，一个加载器（loader）实际上就是一个将特定的字符串转化成JavaScript代码的函数。换个角度来说，一个loader就是一个字符串处理函数。</p>
<p>通常，为了保证loader便于测试和复用，每个loader不会写的很复杂，实现的功能也有限。所以一个文件通常需要多个loader来处理。比如对于一个css文件，我们至少需要两个loader：css-loader和style-loader。前者用于解析css文件，后者用于将css注入到HTML文件中。style-loader会把css添加为页内样式（即直接把样式放在head中的<style>标签内），如果你希望打包出单独的css文件，需要使用extract-loader。</p>
<p>如果你希望为css文件定义loader，可以这样写（当然你需要使用npm先安装这些loader）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; </span><br><span class="line">        test: /\.css$/, </span><br><span class="line">        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] </span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它的含义是，对.css结尾的文件，使用’css-loader’和’style-loader’这两个loader。webpack将依次从后向前执行每个loader。比如在解析到index.css时，它将经历以下步骤：</p>
<p>使用nodejs的fs模块读取index.css，将读取到的字符串交给css-loader。<br>执行css-loader。它是一个函数，将原始字符串进行一定的处理，输出一个新的字符串。<br>将上一步输出的字符串交给style-loader，进行第二步处理，最终仍然输出一个字符串。<br>由webpack解析最终的处理结果。<br>因为webpack采用的是流式处理，所以loader的书写顺序非常重要，最先需要执行的loader必须放在数组的最后。</p>
<p>基于这个原理，我们也可以自行手写loader，来满足特定的需求。比如官方没有关于.txt文本文件的loader，所以webpack不能解析文本文件中所包含的依赖（因为文本文件没有任何格式约定，所以无法定义一个普适的loader）。如果你的项目中有需要解析的文本文件，并且它们有严格的格式要求，那么你就可以自行实现一个loader，实现对这类资源的打包。具体实现方法见webpack中文网 - 编写一个 loader。</p>
<h3 id="4-插件（plugin）"><a href="#4-插件（plugin）" class="headerlink" title="4. 插件（plugin）"></a>4. 插件（plugin）</h3><p>一个插件就是一个对webpack功能的定制或扩展。</p>
<p>loader的使用场景是有限的，它只能用来帮助webpack加载非js文件。如果我们想在webpack打包的任何一个过程中添加某些特定的功能，就需要借助插件来实现。它是webpack灵活性的一大体现，也是webpack的支柱功能，因为webpack自身就是构建于插件系统之上的。</p>
<p>比如，我们想要在webpack开始构建时执行某些操作，就可以定义一个像下面的插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const pluginName = &#x27;ConsoleLogOnBuildWebpackPlugin&#x27;;</span><br><span class="line"></span><br><span class="line">class ConsoleLogOnBuildWebpackPlugin &#123;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        compiler.hooks.run.tap(pluginName, compilation =&gt; &#123;</span><br><span class="line">            console.log(&quot;webpack 构建过程开始！&quot;);</span><br><span class="line">            console.log(&quot;当前时间：&quot; + new Date());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在webpack配置文件中这样使用插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ConsoleLogOnBuildWebpackPlugin = require(&#x27;ConsoleLogOnBuildWebpackPlugin&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new ConsoleLogOnBuildWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，webpack在开始构建时，就会执行我们的console.log方法。当然，你可以定制的功能远不止这些，这里只是向你展示插件的基本用法。</p>
<p>我们看到，一个插件就是一个带有apply原型方法的类（也可以是一个构造函数，并且它的原型对象上有apply方法，两者是等价的）。在配置文件中使用new关键字会创建一个插件实例，webpack将所有插件定义的回调函数注册到对应的生命周期钩子上。当webpack执行到对应的阶段时，就会调用这些钩子函数，实现插件定制的功能。</p>
<p>插件可以传入一个配置对象，用于构造插件实例。而插件上的原型方法apply会被webpack所调用，webpack会将编译器对象compiler传入apply方法。该对象在整个编译过程中都是可用的。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function HelloWorldPlugin(options) &#123;</span><br><span class="line">  // 使用 options 设置插件实例</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloWorldPlugin.prototype.apply = function(compiler) &#123;</span><br><span class="line">  compiler.plugin(&#x27;done&#x27;, function(compilation) &#123;</span><br><span class="line">    console.log(&#x27;Hello World!&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = HelloWorldPlugin;</span><br></pre></td></tr></table></figure>
<p>我们在配置文件中传入的配置对象options会被构造函数接收，用于构造插件实例，在apply方法中可以通过this获得。</p>
<p>然后我们在插件的原型上定义了一个apply方法，webpack解析配置文件时会执行它，并传入webpack的编译器对象。我们通过语句compiler.plugin(‘done’,function(compilation){…}为webpack的编译器对象注册了一个done阶段（即打包完成）的回调函数。当webpack打包完成时，会调用这个函数，并传入当前webpack的编译器状态对象：compilation。</p>
<p>我们可以借助compiler和compilation这两个对象，在任何一个阶段执行我们想执行的操作。前者是编译器对象，后者是当前状态对象。具体编写插件的方法请参考webpack中文网 - 编写一个插件。</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/11/14/webpack/webpack%E6%A6%82%E5%BF%B5/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-vue-组件化">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/11/11/Vue/vue-%E7%BB%84%E4%BB%B6%E5%8C%96/">vue-组件化</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-11-11
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/vue/" class="cube-excerpt-tag-link">#vue</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><blockquote>
<p>vue组件系统提供了一种抽象，让我们可以使用独立可复用的组件来构建大型应用，任意类型的应用界 面都可以抽象为一个组件树。组件化能提高开发效率，方便重复使用，简化调试步骤，提升项目可维护 性，便于多人协同开发。</p>
</blockquote>
<p><img src="https://blog.poetries.top/img/static/images/20210313133919.png" alt="img"></p>
<h2 id="组件通信常用方式"><a href="#组件通信常用方式" class="headerlink" title="组件通信常用方式"></a>组件通信常用方式</h2><h3 id="1-props"><a href="#1-props" class="headerlink" title="1. props"></a><strong>1. props</strong></h3><blockquote>
<p>父给子传值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// child</span><br><span class="line">props: &#123; msg: String &#125;</span><br><span class="line">// parent</span><br><span class="line">&lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-自定义事件"><a href="#2-自定义事件" class="headerlink" title="2. 自定义事件"></a>2. 自定义事件</h3><blockquote>
<p>子给父传值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// child this.$emit(&#x27;add&#x27;, good)</span><br><span class="line">// parent</span><br><span class="line">&lt;Cart @add=&quot;cartAdd($event)&quot;&gt;&lt;/Cart&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-事件总线"><a href="#3-事件总线" class="headerlink" title="3. 事件总线"></a>3. 事件总线</h3><blockquote>
<p>任意两个组件之间传值常用事件总线 或 vuex的方式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  // Bus:事件派发、监听和回调管理 class Bus &#123;</span><br><span class="line">constructor()&#123; this.callbacks = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  $on(name, fn)&#123;</span><br><span class="line">this.callbacks[name] = this.callbacks[name] || []</span><br><span class="line">this.callbacks[name].push(fn) &#125;</span><br><span class="line">$emit(name, args)&#123; if(this.callbacks[name])&#123;</span><br><span class="line">this.callbacks[name].forEach(cb =&gt; cb(args)) &#125;</span><br><span class="line">&#125; &#125;</span><br><span class="line">// main.js</span><br><span class="line">Vue.prototype.$bus = new Bus()</span><br><span class="line">// child1</span><br><span class="line">this.$bus.$on(&#x27;foo&#x27;, handle) // child2 this.$bus.$emit(&#x27;foo&#x27;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实践中通常用Vue代替Bus，因为Vue已经实现了相应接口</p>
</blockquote>
<h3 id="4-vuex"><a href="#4-vuex" class="headerlink" title="4. vuex"></a><strong>4. vuex</strong></h3><blockquote>
<p>创建唯一的全局数据管理者store，通过它管理数据并通知组件状态变更。</p>
</blockquote>
<h3 id="5-parent-x2F-root"><a href="#5-parent-x2F-root" class="headerlink" title="5. $parent&#x2F;$root"></a>5. <strong>$parent&#x2F;$root</strong></h3><blockquote>
<p>兄弟组件之间通信可通过共同祖辈搭桥，<code>$parent</code>或<code>$root</code>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// brother1</span><br><span class="line">this.$parent.$on(&#x27;foo&#x27;, handle)</span><br><span class="line">// brother2 </span><br><span class="line">this.$parent.$emit(&#x27;foo&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="6-children"><a href="#6-children" class="headerlink" title="6. $children"></a>6. <strong>$children</strong></h3><blockquote>
<p>父组件可以通过<code>$children</code>访问子组件实现父子通信。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// parent </span><br><span class="line">this.$children[0].xx = &#x27;xxx&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="7-attrs-x2F-listeners"><a href="#7-attrs-x2F-listeners" class="headerlink" title="7. $attrs&#x2F;$listeners"></a>7. <strong>$attrs&#x2F;$listeners</strong></h3><blockquote>
<p>包含了父作用域中不作为 <strong>prop</strong> 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。当一个组件没有 声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外)，并且可以通过 <code>v- bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// child:并未在props中声明foo </span><br><span class="line">&lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;/p&gt;</span><br><span class="line">// parent</span><br><span class="line">&lt;HelloWorld foo=&quot;foo&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-refs"><a href="#8-refs" class="headerlink" title="8. refs"></a>8. <strong>refs</strong></h3><blockquote>
<p>获取子节点引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// parent</span><br><span class="line">&lt;HelloWorld ref=&quot;hw&quot;/&gt;</span><br><span class="line">mounted() &#123; </span><br><span class="line">  this.$refs.hw.xx = &#x27;xxx&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-provide-x2F-inject"><a href="#9-provide-x2F-inject" class="headerlink" title="9. provide&#x2F;inject"></a>9. <strong>provide&#x2F;inject</strong></h3><blockquote>
<p>能够实现祖先和后代之间传值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ancestor</span><br><span class="line">provide() &#123;</span><br><span class="line">  return &#123;foo: &#x27;foo&#x27;&#125;</span><br><span class="line">&#125;</span><br><span class="line">// descendant</span><br><span class="line">inject: [&#x27;foo&#x27;]</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">// index.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;组件通信&lt;/h2&gt;</span><br><span class="line">    &lt;!-- props, 自定义事件 --&gt;</span><br><span class="line">    &lt;Child1 msg=&quot;some msg from parent&quot; @some-event=&quot;onSomeEvent&quot;&gt;&lt;/Child1&gt;</span><br><span class="line">    &lt;!-- 事件总线 --&gt;</span><br><span class="line">    &lt;Child2 msg=&quot;other msg&quot;&gt;&lt;/Child2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Child1 from &#x27;@/components/communication/Child1.vue&#x27;</span><br><span class="line">  import Child2 from &#x27;@/components/communication/Child2.vue&#x27;</span><br><span class="line">  </span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      Child1, Child2,</span><br><span class="line">      // Child3: () =&gt; import(&#x27;./Child3.vue&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onSomeEvent(msg) &#123;</span><br><span class="line">        console.log(&#x27;Communition:&#x27;, msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      // $children持有所有自定义组件</span><br><span class="line">      // 它不保证顺序</span><br><span class="line">      console.log(this.$children);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">// child1.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click=&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from child1&#x27;)&quot;&gt;</span><br><span class="line">    &lt;h3&gt;child1&lt;/h3&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      msg: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#x27;&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      // this.$bus.$on(&#x27;event-from-child2&#x27;, msg =&gt; &#123;</span><br><span class="line">      //   console.log(&#x27;Child1:&#x27;, msg);</span><br><span class="line">      // &#125;);</span><br><span class="line">      this.$parent.$on(&#x27;event-from-child2&#x27;, msg =&gt; &#123;</span><br><span class="line">        console.log(&#x27;Child1:&#x27;, msg);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">// child2.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 展开$attrs对象 --&gt;</span><br><span class="line">    &lt;h3 v-bind=&quot;$attrs&quot;&gt;child2&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;sendToChild1&quot;&gt;给child1发送消息&lt;/button&gt;</span><br><span class="line">    &lt;!-- $attrs --&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;$attrs.msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;!-- inject --&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;foo&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    inheritAttrs: false,</span><br><span class="line">    inject: [&#x27;foo&#x27;],</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendToChild1() &#123;</span><br><span class="line">        // 利用事件总线发送事件</span><br><span class="line">        // this.$bus.$emit(&#x27;event-from-child2&#x27;, &#x27;some msg from child2&#x27;)</span><br><span class="line">        this.$parent.$emit(&#x27;event-from-child2&#x27;, &#x27;some msg from child2&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><blockquote>
<p>插槽语法是Vue 实现的内容分发 API，用于复合组件开发。该技术在通用组件库开发中有大量应用</p>
</blockquote>
<h3 id="1-匿名插槽"><a href="#1-匿名插槽" class="headerlink" title="1. 匿名插槽"></a>1. 匿名插槽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// comp1</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// parent</span><br><span class="line">&lt;comp&gt;hello&lt;/comp&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2. 具名插槽"></a>2. 具名插槽</h3><blockquote>
<p>将内容分发到子组件指定位置</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// comp2</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">&lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// parent</span><br><span class="line">&lt;Comp2&gt;</span><br><span class="line">&lt;!-- 默认插槽用default做参数 --&gt;</span><br><span class="line">&lt;template v-slot:default&gt;具名插槽&lt;/template&gt; &lt;!-- 具名插槽用插槽名做参数 --&gt;</span><br><span class="line">&lt;template v-slot:content&gt;内容...&lt;/template&gt;</span><br><span class="line">&lt;/Comp2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3. 作用域插槽"></a>3. 作用域插槽</h3><blockquote>
<p>分发内容要用到子组件中的数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// comp3</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot :foo=&quot;foo&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// parent</span><br><span class="line">&lt;Comp3&gt;</span><br><span class="line">&lt;!-- 把v-slot的值指定为作用域上下文对象 --&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; 来自子组件数据:&#123;&#123;slotProps.foo&#125;&#125; &lt;/template&gt;</span><br><span class="line">&lt;/Comp3&gt;</span><br></pre></td></tr></table></figure>

<p>范例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// 子组件 Layout.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;body&quot;&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;footer&quot; :fc=&quot;footerContent&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        remark: [</span><br><span class="line">          &#x27;好好学习，天天向上&#x27;,</span><br><span class="line">          &#x27;学习永远不晚&#x27;,</span><br><span class="line">          &#x27;学习知识要善于思考,思考,再思考&#x27;,</span><br><span class="line">          &#x27;学习的敌人是自己的满足,要认真学习一点东西,必须从不自满开始&#x27;,</span><br><span class="line">          &#x27;构成我们学习最大障碍的是已知的东西,而不是未知的东西&#x27;,</span><br><span class="line">          &#x27;在今天和明天之间,有一段很长的时间;趁你还有精神的时候,学习迅速办事&#x27;,</span><br><span class="line">          &#x27;三人行必有我师焉；择其善者而从之，其不善者而改之&#x27;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      footerContent() &#123;</span><br><span class="line">        return this.remark[new Date().getDay() - 1] </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.header &#123;</span><br><span class="line">  background-color: rgb(252, 175, 175);</span><br><span class="line">&#125;</span><br><span class="line">.body &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  background-color: rgb(144, 250, 134);</span><br><span class="line">  min-height: 100px;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line">.footer &#123;</span><br><span class="line">  background-color: rgb(114, 116, 255);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">//父组件 index.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;插槽&lt;/h2&gt;</span><br><span class="line">    &lt;!-- 插槽 --&gt;</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;!-- 具名插槽 --&gt;</span><br><span class="line">      &lt;template v-slot:header&gt;全栈工程师&lt;/template&gt;</span><br><span class="line">      &lt;!-- 匿名插槽 --&gt;</span><br><span class="line">      &lt;template&gt;content...&lt;/template&gt;</span><br><span class="line">      &lt;!-- 作用域插槽 --&gt;</span><br><span class="line">      &lt;template v-slot:footer=&quot;&#123;fc&#125;&quot;&gt;&#123;&#123;fc&#125;&#125;&lt;/template&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Layout from &#x27;@/components/slots/Layout.vue&#x27;</span><br><span class="line">  </span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      Layout</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="组件化实战"><a href="#组件化实战" class="headerlink" title="组件化实战"></a>组件化实战</h2><h3 id="通用表单组件"><a href="#通用表单组件" class="headerlink" title="通用表单组件"></a>通用表单组件</h3><blockquote>
<p>收集数据、校验数据并提交。</p>
</blockquote>
<ul>
<li>实现KForm 指定数据、校验规则</li>
<li>KformItem<ul>
<li>label标签添加</li>
<li>执行校验</li>
<li>显示错误信息</li>
</ul>
</li>
<li>KInput<ul>
<li>维护数据</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-form :model=&quot;userInfo&quot; :rules=&quot;rules&quot; ref=&quot;loginForm&quot;&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;用户名&quot; prop=&quot;name&quot;&gt;</span><br><span class="line">      &lt;el-input v-model=&quot;userInfo.name&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;</span><br><span class="line">      &lt;el-input v-model=&quot;userInfo.password&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;el-form-item&gt;</span><br><span class="line">      &lt;el-button @click=&quot;login&quot;&gt;登录&lt;/el-button&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">  &lt;/el-form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      userInfo: &#123;</span><br><span class="line">        username: &quot;&quot;,</span><br><span class="line">        password: &quot;&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line">        username: [&#123; required: true, message: &quot;请输入用户名称&quot; &#125;],</span><br><span class="line">        password: [&#123; required: true, message: &quot;请输入密码&quot; &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    login() &#123;</span><br><span class="line">      this.$refs[&quot;loginForm&quot;].validate(valid =&gt; &#123;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          alert(&quot;submit&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&quot;error submit!&quot;);</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>1.</strong> KInput</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 创建components/form/KInput.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 管理数据：实现双绑 --&gt;</span><br><span class="line">    &lt;!-- :value, @input --&gt;</span><br><span class="line">    &lt;input :type=&quot;type&quot; :value=&quot;value&quot; @input=&quot;onInput&quot;</span><br><span class="line">      v-bind=&quot;$attrs&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    inheritAttrs: false , // 关闭特性继承</span><br><span class="line">    props: &#123;</span><br><span class="line">      value: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#x27;&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      type: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#x27;text&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onInput(e) &#123;</span><br><span class="line">        this.$emit(&#x27;input&#x27;, e.target.value)</span><br><span class="line"></span><br><span class="line">        // 值发生变化的时候就是需要校验的时候</span><br><span class="line">        this.$parent.$emit(&#x27;validate&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用<strong>KInput</strong></li>
</ol>
<p>创建components&#x2F;form&#x2F;index.vue，添加如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">&lt;h3&gt;KForm表单&lt;/h3&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;k-input v-model=&quot;model.username&quot;&gt;&lt;/k-input&gt;</span><br><span class="line">&lt;k-input type=&quot;password&quot; v-model=&quot;model.password&quot;&gt;&lt;/k-input&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">  KInput</span><br><span class="line">&#125;, </span><br><span class="line">  data() &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">      model: &#123; username: &quot;tom&quot;, password: &quot;&quot; &#125;,</span><br><span class="line">    &#125;; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>实现<strong>KFormItem</strong></li>
</ol>
<p>创建components&#x2F;form&#x2F;KFormItem.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- label标签 --&gt;</span><br><span class="line">    &lt;label v-if=&quot;label&quot;&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt;</span><br><span class="line">    &lt;!-- 容器，放插槽 --&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;!-- 错误信息展示 --&gt;</span><br><span class="line">    &lt;p v-if=&quot;error&quot; class=&quot;error&quot;&gt;&#123;&#123;error&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Schema from &#x27;async-validator&#x27;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    inject: [&#x27;form&#x27;],</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        error: &#x27;&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      label: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#x27;&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      prop: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#x27;&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      // 监听校验事件</span><br><span class="line">      this.$on(&#x27;validate&#x27;, () =&gt; &#123;</span><br><span class="line">        this.validate()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      validate() &#123;</span><br><span class="line">        // 执行校验</span><br><span class="line">        // 1.获取值和校验规则</span><br><span class="line">        const rules = this.form.rules[this.prop]</span><br><span class="line">        const value = this.form.model[this.prop]</span><br><span class="line"></span><br><span class="line">        // 2.执行校验：使用官方也使用的async-validator</span><br><span class="line">        // 创建描述对象</span><br><span class="line">        const descriptor = &#123;[this.prop]:rules&#125;</span><br><span class="line">        // 创建校验器</span><br><span class="line">        const validator = new Schema(descriptor)</span><br><span class="line">        // 执行校验</span><br><span class="line">        return validator.validate(&#123;[this.prop]:value&#125;, errors =&gt; &#123;</span><br><span class="line">          // 如果errors存在，则说明校验失败</span><br><span class="line">          if (errors) &#123;</span><br><span class="line">            this.error = errors[0].message</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.error = &#x27;&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.error&#123;</span><br><span class="line">  color: red</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用<strong>KFormItem</strong></li>
</ol>
<p>components&#x2F;form&#x2F;index.vue，添加基础代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">&lt;h3&gt;KForm表单&lt;/h3&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;k-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;</span><br><span class="line">&lt;k-input v-model=&quot;model.username&quot;&gt;&lt;/k-input&gt; &lt;/k-form-item&gt;</span><br><span class="line">&lt;k-form-item label=&quot;确认密码&quot; prop=&quot;password&quot;&gt;</span><br><span class="line">&lt;k-input type=&quot;password&quot; v-model=&quot;model.password&quot;&gt;&lt;/k-input&gt;</span><br><span class="line">&lt;/k-form-item&gt; &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>实现<strong>KForm</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 容器：存放所有表单项 --&gt;</span><br><span class="line">    &lt;!-- 存储值载体：保存大家数据和校验规则 --&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 我们平时写的组件是一个组件配置对象</span><br><span class="line">export default &#123;</span><br><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      // 直接把当前组件实例传递下去</span><br><span class="line">      // 传递下去的对象是响应式的则还可以响应式</span><br><span class="line">      form: this</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 数据模型</span><br><span class="line">    model: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    rules: Object</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    validate(cb) &#123;</span><br><span class="line">      // 遍历肚子里面的所有FormItem，执行他们的validate方法</span><br><span class="line">      // 全部通过才算通过</span><br><span class="line">      // tasks是校验结果的Promise组成的数组</span><br><span class="line">      const tasks = this.$children</span><br><span class="line">        .filter(item =&gt; item.prop)</span><br><span class="line">        .map(item =&gt; item.validate());</span><br><span class="line">      // 统一判断</span><br><span class="line">      Promise.all(tasks)</span><br><span class="line">        .then(() =&gt; cb(true))</span><br><span class="line">        .catch(() =&gt; cb(false));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用<strong>KForm</strong></li>
</ol>
<p>components&#x2F;form&#x2F;index.vue，添加基础代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt; template &gt; &lt;div &gt; &lt;h3 &gt; KForm表单 &lt; /h3&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;k-form :model=&quot;model&quot; :rules=&quot;rules&quot; ref=&quot;loginForm&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/k - form &gt; &lt;/div&gt;</span><br><span class="line">&lt;/template &gt; &lt;script &gt; import KForm from &quot;./KForm&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">        components:</span><br><span class="line">        &#123;</span><br><span class="line">            KForm,</span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                rules: &#123;</span><br><span class="line">                    username: [&#123;</span><br><span class="line">                        required: true,</span><br><span class="line">                        message: &quot;请输入用户名&quot;</span><br><span class="line">                    &#125;],</span><br><span class="line">                    password: [&#123;</span><br><span class="line">                        required: true,</span><br><span class="line">                        message: &quot;请输入密码&quot;</span><br><span class="line">                    &#125;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            submitForm() &#123;</span><br><span class="line">                this.$refs[&#x27;loginForm&#x27;].validate(valid = &gt;&#123;</span><br><span class="line">                    if (valid) &#123;</span><br><span class="line">                        alert(&quot;请求登录!&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        alert(&quot;校验失败!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; &lt; /script&gt;/</span><br></pre></td></tr></table></figure>

<ol>
<li>数据校验</li>
</ol>
<p>Input通知校验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onInput(e) &#123; // ...</span><br><span class="line">    // $parent指FormItem</span><br><span class="line">    this.$parent.$emit(&#x27;validate&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FormItem监听校验通知，获取规则并执行校验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">inject: [&#x27;form&#x27;],</span><br><span class="line">// 注入 mounted()&#123;// 监听校验事件</span><br><span class="line">this.$on(&#x27;validate&#x27;, () = &gt;&#123;</span><br><span class="line">    this.validate()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    validate() &#123;</span><br><span class="line">        // 获取对应FormItem校验规则 console.log(this.form.rules[this.prop]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">import Schema from &quot;async-validator&quot;;</span><br><span class="line"></span><br><span class="line">validate() &#123;</span><br><span class="line">    // 获取对应FormItem校验规则</span><br><span class="line">    const rules = this.form.rules[this.prop];</span><br><span class="line">    // 获取校验值</span><br><span class="line">    const value = this.form.model[this.prop];</span><br><span class="line">    // 校验</span><br><span class="line">    const schema = new Schema(descriptor);</span><br><span class="line">    // 返回Promise，没有触发catch就说明验证通过</span><br><span class="line">    return schema.validate(&#123; [this.prop] : value</span><br><span class="line">    &#125;,</span><br><span class="line">    errors = &gt;&#123;</span><br><span class="line">        if (errors) &#123;</span><br><span class="line">            // 将错误信息显示</span><br><span class="line">            this.error = errors[0].message;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 校验通过 this.error = &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表单全局验证，为<code>Form</code>提供<code>validate</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">validate(cb) &#123;</span><br><span class="line">    // 调用所有含有prop属性的子组件的validate方法并得到Promise数组 const tasks = this.$children</span><br><span class="line">    .filter(item = &gt;item.prop).map(item = &gt;item.validate());</span><br><span class="line">    // 所有任务必须全部成功才算校验通过，任一失败则校验失败</span><br><span class="line">    Promise.all(tasks).then(() = &gt;cb(true)).catch(() = &gt;cb(false))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现弹窗组件"><a href="#实现弹窗组件" class="headerlink" title="实现弹窗组件"></a>实现弹窗组件</h3><blockquote>
<p>弹窗这类组件的特点是它们在当前<strong>vue</strong>实例之外独立存在，通常挂载于body;它们是通过JS动态创建的，不需要在任何组件中声明。常⻅使用姿势</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$create(Notice, &#123;</span><br><span class="line">    title: &#x27;喊你来搬砖&#x27;,</span><br><span class="line">    message: &#x27;提示信息&#x27;,</span><br><span class="line">    duration: 1000</span><br><span class="line">&#125;).show();</span><br></pre></td></tr></table></figure>

<p>create函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">// 创建函数接收要创建组件定义</span><br><span class="line">function create(Component, props) &#123;</span><br><span class="line">    // 创建一个Vue新实例 const vm = new Vue(&#123;</span><br><span class="line">    render(h) &#123;</span><br><span class="line">        // render函数将传入组件配置对象转换为虚拟dom console.log(h(Component, &#123; props &#125;)); return h(Component, &#123; props &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).$mount(); //执行挂载函数，但未指定挂载目标，表示只执行初始化工作</span><br><span class="line"></span><br><span class="line">  // 将生成dom元素追加至</span><br><span class="line">  body document.body.appendChild(vm.$el);</span><br><span class="line"></span><br><span class="line">  // 给组件实例添加销毁方法</span><br><span class="line">  const comp = vm.$children[0];</span><br><span class="line">  comp.remove = () = &gt;&#123;</span><br><span class="line">      document.body.removeChild(vm.$el);</span><br><span class="line">      vm.$destroy();</span><br><span class="line">  &#125;;</span><br><span class="line">  return comp;</span><br><span class="line">&#125;</span><br><span class="line">// 暴露调用接口</span><br><span class="line">export default create</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另一种创建组件实例的方式: <code>Vue.extend(Component)</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Ctor = Vue.extend(Component) </span><br><span class="line">const comp = new Ctor(&#123;</span><br><span class="line">    propsData: props</span><br><span class="line">&#125;) </span><br><span class="line">comp.$mount();</span><br><span class="line"></span><br><span class="line">document.body.appendChild(comp.$el) </span><br><span class="line"></span><br><span class="line">comp.remove = () = &gt;&#123;</span><br><span class="line">    // 移除dom document.body.removeChild(comp.$el) // 销毁组件</span><br><span class="line">    comp.$destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通知组件"><a href="#通知组件" class="headerlink" title="通知组件"></a>通知组件</h3><p>建通知组件，Notice.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot; v-if=&quot;isShow&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;p class=&quot;box-content&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    message: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    duration: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 2000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isShow: false</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">      this.isShow = true;</span><br><span class="line">      setTimeout(this.hide, this.duration);</span><br><span class="line">    &#125;,</span><br><span class="line">    hide() &#123;</span><br><span class="line">      this.isShow = false;</span><br><span class="line">      this.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  width: 100%;</span><br><span class="line">  top: 16px;</span><br><span class="line">  left: 0;</span><br><span class="line">  text-align: center;</span><br><span class="line">  pointer-events: none;</span><br><span class="line">  background-color: #fff;</span><br><span class="line">  border: grey 3px solid;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">.box-content &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  margin: 10px auto;</span><br><span class="line">  font-size: 14px;  </span><br><span class="line">  padding: 8px 16px;</span><br><span class="line">  background: #fff;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  margin-bottom: 8px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用插件进一步封装便于使用，<code>create.js</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Notice from &#x27;@/components/Notice.vue&#x27; //...</span><br><span class="line">export default &#123;</span><br><span class="line">  install(Vue) &#123;</span><br><span class="line">      Vue.prototype.$notice = function(options) &#123;</span><br><span class="line">          return create(Notice, options)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/11/11/Vue/vue-%E7%BB%84%E4%BB%B6%E5%8C%96/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack多页面应用">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/11/09/webpack/webpack%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/">webpack多页面应用</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-11-09
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p><strong>entry配置</strong><br>在实际项目的开发中一个完整的系统不会将所有的功能都放在一个网页上，因为这样会导致网页的性能不佳，实际可以按照功能模块划分多个单页应用每个单页应用又生处一个html文件并且随着业务的发展更多的单页应用可以被逐渐的加入到这个项目里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">entry: [&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;，&#x27;node_modules里的模块 lodash&#x27;],</span><br><span class="line">entry:&#123;</span><br><span class="line">	main:[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],    //这里使用lodash  还会打包在这里打包一遍</span><br><span class="line">	lodash:&#x27;lodash&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">entry:&#123;</span><br><span class="line">	main:&#123;</span><br><span class="line">	import :[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],  //这两个文件可能依赖于lodash，而lodash单独打包了，所以dependOn这个依赖可以把公共的lodash给抽离出来            lodash  就不会在打包一遍了</span><br><span class="line">	dependOn:&#x27;lodash&#x27;,           // 做依赖  这里的lodash  是下面的对应名  可以随意起</span><br><span class="line">	&#125;,    //这里使用lodash  还会打包在这里打包一遍</span><br><span class="line">	lodash:&#x27;lodash&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。<br>描述入口的对象：<br>用于描述入口的对象。你可以使用如下属性：<br>dependOn : 当前入口所依赖的入口。它们必须在该入口被加载前被加载。<br>filename : 指定要输出的文件名称。<br>import : 启动时需加载的模块。<br>library : 指定 library 选项，为当前 entry 构建一个 library。<br>runtime : 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时<br>chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时<br>chunk。<br>publicPath : 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共<br>URL 地址。请查看 output.publicPath。<br>webpack.config.js<br>runtime 和 dependOn 不应在同一个入口上同时使用，所以如下配置无效，并且会<br>抛出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a2: &#x27;dependingfile.js&#x27;,</span><br><span class="line">  b2: &#123;</span><br><span class="line">   dependOn: &#x27;a2&#x27;,</span><br><span class="line">   import: &#x27;./src/app.js&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a2: &#x27;./a&#x27;,</span><br><span class="line">  b2: &#123;</span><br><span class="line">   runtime: &#x27;x2&#x27;,</span><br><span class="line">   dependOn: &#x27;a2&#x27;,</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>确保 runtime 不能指向已存在的入口名称，例如下面配置会抛出一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a1: &#x27;./a&#x27;,</span><br><span class="line">  b1: &#123;</span><br><span class="line">   runtime: &#x27;a1&#x27;,</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外 dependOn 不能是循环引用的，下面的例子也会出现错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a3: &#123;</span><br><span class="line">   import: &#x27;./a&#x27;,</span><br><span class="line">   dependOn: &#x27;b3&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">  b3: &#123;</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line">   dependOn: &#x27;a3&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>配置index.html模板</strong><br>要生成多个HTML文件，请在插件数组中多次声明插件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line"> 	main:&#123;</span><br><span class="line">		import :[],</span><br><span class="line">		dependOn:&#x27;lodash2&#x27;,</span><br><span class="line">		filename:&#x27;chanel1.[name].js&#x27;</span><br><span class="line">	&#125;,</span><br><span class="line">	lodash2:&#123;</span><br><span class="line">		import :&#x27;lodash&#x27;,</span><br><span class="line">		filename:&#x27;common/[name].js&#x27;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(), // Generates default index.html</span><br><span class="line">  new HtmlWebpackPlugin(&#123;  // Also generate a test.html</span><br><span class="line">   title:   &#x27;ejs&#x27;,     //在页面可以使用ejs模板语法获取数据</span><br><span class="line">   filename: &#x27;chanel1/test.html&#x27;,                      //执行打包后的页面文件     输出的文件名</span><br><span class="line">   template: &#x27;src/assets/test.html&#x27;       //指定模板的路径</span><br><span class="line">   inject:&#x27;body/head&#x27;,                       // 定义当前所生成的script标签的位置</span><br><span class="line">   chunks:[&#x27;自定义那个入口  如：main.js&#x27;]，              //规定当前页面到底打包那些chunk   如何实现多个页面去载入不同的chunk   chunk就是我们在路口配置的项    每一项就是一个chunk  默认会把所有chunk都放进去</span><br><span class="line">   publicPash:&#x27;http://www.a.com/&#x27;        //包的前缀</span><br><span class="line"> &#125;)</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title  %&gt;&lt;/title&gt;  options.就是我们在HtmlWebpackPlugin定制的选项</span><br><span class="line">index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;/&gt;</span><br><span class="line">  &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>多页面应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  pageOne: &#x27;./src/pageOne/index.js&#x27;,</span><br><span class="line">  pageTwo: &#x27;./src/pageTwo/index.js&#x27;,</span><br><span class="line">  pageThree: &#x27;./src/pageThree/index.js&#x27;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是什么？ 我们告诉 webpack 需要三个独立分离的依赖图（如上面的示例）</p>
<p>为什么？ 在多页面应用程序中，server 会拉取一个新的 HTML 文档给你的客户端。<br>页面重新加载此新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很<br>多事，例如使用 optimization.splitChunks 为页面间共享的应用程序代码创建<br>bundle。由于入口起点数量的增多，多页应用能够复用多个入口起点之间的大量代<br>码&#x2F;模块，从而可以极大地从这些技术中受益。</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/11/09/webpack/webpack%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-vue-修饰符">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/11/02/Vue/vue-%E4%BF%AE%E9%A5%B0%E7%AC%A6/">vue-修饰符</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-11-02
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/vue/" class="cube-excerpt-tag-link">#vue</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、修饰符是什么"><a href="#一、修饰符是什么" class="headerlink" title="一、修饰符是什么"></a>一、修饰符是什么</h2><p>在程序世界里，修饰符是用于限定类型以及类型成员的声明的一种符号</p>
<p>在<code>Vue</code>中，修饰符处理了许多<code>DOM</code>事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理</p>
<p><code>vue</code>中修饰符分为以下五种：</p>
<ul>
<li>表单修饰符</li>
<li>事件修饰符</li>
<li>鼠标按键修饰符</li>
<li>键值修饰符</li>
<li>v-bind修饰符</li>
</ul>
<h2 id="二、修饰符的作用"><a href="#二、修饰符的作用" class="headerlink" title="二、修饰符的作用"></a>二、修饰符的作用</h2><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><p>在我们填写表单的时候用得最多的是<code>input</code>标签，指令用得最多的是<code>v-model</code></p>
<p>关于表单的修饰符有如下：</p>
<ul>
<li>lazy</li>
<li>trim</li>
<li>number</li>
</ul>
<h4 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h4><p>在我们填完信息，光标离开标签的时候，才会将值赋予给<code>value</code>，也就是在<code>change</code>事件之后再进行信息同步</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">lazy</span>=<span class="string">&quot;value&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h4><p>自动过滤用户输入的首空格字符，而中间的空格不会过滤</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">trim</span>=<span class="string">&quot;value&quot;</span>&gt;</span><br></pre></td></tr></table></figure>



<h4 id="number"><a href="#number" class="headerlink" title="number"></a>number</h4><p>自动将用户的输入值转为数值类型，但如果这个值无法被<code>parseFloat</code>解析，则会返回原来的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.<span class="property">number</span>=<span class="string">&quot;age&quot;</span> type=<span class="string">&quot;number&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符：</p>
<ul>
<li>stop</li>
<li>prevent</li>
<li>self</li>
<li>once</li>
<li>capture</li>
<li>passive</li>
<li>native</li>
</ul>
<h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><p>阻止了事件冒泡，相当于调用了<code>event.stopPropagation</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=<span class="string">&quot;shout(2)&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">//只输出1</span></span><br></pre></td></tr></table></figure>

<h4 id="prevent"><a href="#prevent" class="headerlink" title="prevent"></a>prevent</h4><p>阻止了事件的默认行为，相当于调用了<code>event.preventDefault</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-<span class="attr">on</span>:submit.<span class="property">prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h4 id="self"><a href="#self" class="headerlink" title="self"></a>self</h4><p>只当在 <code>event.target</code> 是当前元素自身时触发处理函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="attr">on</span>:click.<span class="property">self</span>=<span class="string">&quot;doThat&quot;</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code>会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击</p>
</blockquote>
<h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><p>绑定了事件以后只能触发一次，第二次就不会触发</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click.<span class="property">once</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;ok&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h4 id="capture"><a href="#capture" class="headerlink" title="capture"></a>capture</h4><p>使事件触发从包含这个元素的顶层开始往下触发</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click.<span class="property">capture</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span><br><span class="line">    obj1</span><br><span class="line">&lt;div @click.<span class="property">capture</span>=<span class="string">&quot;shout(2)&quot;</span>&gt;</span><br><span class="line">    obj2</span><br><span class="line">&lt;div @click=<span class="string">&quot;shout(3)&quot;</span>&gt;</span><br><span class="line">    obj3</span><br><span class="line">&lt;div @click=<span class="string">&quot;shout(4)&quot;</span>&gt;</span><br><span class="line">    obj4</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 输出结构: 1 2 4 3 </span></span><br></pre></td></tr></table></figure>

<h4 id="passive"><a href="#passive" class="headerlink" title="passive"></a>passive</h4><p>在移动端，当我们在监听元素滚动事件的时候，会一直触发<code>onscroll</code>事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给<code>onscroll</code>事件整了一个<code>.lazy</code>修饰符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;!-- 而不会等待 <span class="string">`onScroll`</span> 完成  --&gt;</span><br><span class="line">&lt;!-- 这其中包含 <span class="string">`event.preventDefault()`</span> 的情况 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用,因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。</p>
<p><code>passive</code> 会告诉浏览器你不想阻止事件的默认行为</p>
</blockquote>
<h4 id="native"><a href="#native" class="headerlink" title="native"></a>native</h4><p>让组件变成像<code>html</code>内置标签那样监听根元素的原生事件，否则组件上使用 <code>v-on</code> 只会监听自定义事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-<span class="attr">on</span>:click.<span class="property">native</span>=<span class="string">&quot;doSomething&quot;</span>&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用.native修饰符来操作普通HTML标签是会令事件失效的</p>
</blockquote>
<h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><p>鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：</p>
<ul>
<li>left 左键点击</li>
<li>right 右键点击</li>
<li>middle 中键点击</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click.<span class="property">left</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;ok&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.right</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.middle</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="键盘修饰符"><a href="#键盘修饰符" class="headerlink" title="键盘修饰符"></a>键盘修饰符</h3><p>键盘修饰符是用来修饰键盘事件（<code>onkeyup</code>，<code>onkeydown</code>）的，有如下：</p>
<p><code>keyCode</code>存在很多，但<code>vue</code>为我们提供了别名，分为以下两种：</p>
<ul>
<li>普通键（enter、tab、delete、space、esc、up…）</li>
<li>系统修饰键（ctrl、alt、meta、shift…）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有按键为keyCode的时候才触发</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> @keyup.<span class="property">keyCode</span>=<span class="string">&quot;shout()&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>还可以通过以下方式自定义一些全局的键盘码别名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">keyCodes</span>.<span class="property">f2</span> = <span class="number">113</span></span><br></pre></td></tr></table></figure>

<h3 id="v-bind修饰符"><a href="#v-bind修饰符" class="headerlink" title="v-bind修饰符"></a>v-bind修饰符</h3><p>v-bind修饰符主要是为属性进行操作，用来分别有如下：</p>
<ul>
<li>async</li>
<li>prop</li>
<li>camel</li>
</ul>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>能对<code>props</code>进行一个双向绑定</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;comp :myMessage.<span class="property">sync</span>=<span class="string">&quot;bar&quot;</span>&gt;&lt;/comp&gt; </span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:myMessage&#x27;</span>,params);</span><br></pre></td></tr></table></figure>

<p>以上这种方法相当于以下的简写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父亲组件</span></span><br><span class="line">&lt;comp :myMessage=<span class="string">&quot;bar&quot;</span> @<span class="attr">update</span>:myMessage=<span class="string">&quot;func&quot;</span>&gt;&lt;/comp&gt;</span><br><span class="line"><span class="title function_">func</span>(<span class="params">e</span>)&#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">bar</span> = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子组件js</span></span><br><span class="line"><span class="title function_">func2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:myMessage&#x27;</span>,params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>async</code>需要注意以下两点：</p>
<ul>
<li>使用<code>sync</code>的时候，子组件传递的事件名格式必须为<code>update:value</code>，其中<code>value</code>必须与子组件中<code>props</code>中声明的名称完全一致</li>
<li>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用</li>
<li>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”&#123; title: doc.title &#125;”</code>，是无法正常工作的</li>
</ul>
<h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>设置自定义标签属性，避免暴露数据，防止污染HTML结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;uid&quot;</span> title=<span class="string">&quot;title1&quot;</span> value=<span class="string">&quot;1&quot;</span> :index.<span class="property">prop</span>=<span class="string">&quot;index&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="camel"><a href="#camel" class="headerlink" title="camel"></a>camel</h4><p>将命名变为驼峰命名法，如将<code>view-Box</code>属性名转换为 <code>viewBox</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg :viewBox=<span class="string">&quot;viewBox&quot;</span>&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景：</p>
<ul>
<li>.stop：阻止事件冒泡</li>
<li>.native：绑定原生事件</li>
<li>.once：事件只执行一次</li>
<li>.self ：将事件绑定在自身身上，相当于阻止事件冒泡</li>
<li>.prevent：阻止默认事件</li>
<li>.caption：用于事件捕获</li>
<li>.once：只触发一次</li>
<li>.keyCode：监听特定键盘按下</li>
<li>.right：右键</li>
</ul>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/11/02/Vue/vue-%E4%BF%AE%E9%A5%B0%E7%AC%A6/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack的理解">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/11/01/webpack/webpack%E7%9A%84%E7%90%86%E8%A7%A3/">webpack的理解</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-11-01
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p><code>Webpack</code> 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源</p>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的<code>JS</code> 文件中</p>
<p>约定每个文件是一个独立的模块，然后再将这些<code>js</code>文件引入到页面，一个<code>script</code>标签对应一个模块，然后调用模块化的成员</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;module-a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;module-b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题</p>
<p>项目一旦变大，上述问题会尤其明显</p>
<p>随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">moduleA</span> = &#123;</span><br><span class="line">  <span class="attr">method1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;moduleA#method1&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式也并没有解决第一种方式的依赖等问题</p>
<p>再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module-a.js</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">$</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;module-a&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">method1</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name + <span class="string">&#x27;#method1&#x27;</span>)</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">animate</span>(&#123; <span class="attr">margin</span>: <span class="string">&#x27;200px&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">moduleA</span> = &#123;</span><br><span class="line">    <span class="attr">method1</span>: method1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(jQuery)</span><br></pre></td></tr></table></figure>

<p>上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过<code>script</code>标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦</p>
<p>理想的解决方式是，在页面中引入一个<code>JS</code>入口文件，其余用到的模块可以通过代码控制，按需加载进来</p>
<p>除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是<code>CommonJS</code>、<code>ES Modules</code></p>
<h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><p>从后端渲染的<code>JSP</code>、<code>PHP</code>，到前端原生<code>JavaScript</code>，再到<code>jQuery</code>开发，再到目前的三大框架<code>Vue</code>、<code>React</code>、<code>Angular</code></p>
<p>开发方式，也从<code>javascript</code>到后面的<code>es5</code>、<code>es6、7、8、9、10</code>，再到<code>typescript</code>，包括编写<code>CSS</code>的预处理器<code>less</code>、<code>scss</code>等</p>
<p>现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：</p>
<ul>
<li>需要通过模块化的方式来开发</li>
<li>使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码</li>
<li>监听文件的变化来并且反映到浏览器上，提高开发的效率</li>
<li>JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题</li>
<li>开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化</li>
</ul>
<p>而<code>webpack</code>恰巧可以解决以上问题</p>
<h2 id="三、是什么"><a href="#三、是什么" class="headerlink" title="三、是什么"></a>三、是什么</h2><p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的静态模块打包工具</p>
<ul>
<li>静态模块</li>
</ul>
<p>这里的静态模块指的是开发阶段，可以被 <code>webpack</code> 直接引用的资源（可以直接被获取打包进<code>bundle.js</code>的资源）</p>
<p>当 <code>webpack</code>处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限<code>js</code>文件），并生成一个或多个 <code>bundle</code></p>
<p><img src="https://static.vue-js.com/9ce194a0-a578-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<h4 id="webpack的能力："><a href="#webpack的能力：" class="headerlink" title="webpack的能力："></a><code>webpack</code>的能力：</h4><p><strong>编译代码能力</strong>，提高效率，解决浏览器兼容问题 <img src="https://static.vue-js.com/c5c2d360-a592-11eb-ab90-d9ae814b240d.png" alt="img"><strong>模块整合能力</strong>，提高性能，可维护性，解决浏览器频繁请求文件的问题 <img src="https://static.vue-js.com/d306d260-a592-11eb-ab90-d9ae814b240d.png" alt="img"><strong>万物皆可模块能力</strong>，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制 <img src="https://static.vue-js.com/e3c5a040-a592-11eb-ab90-d9ae814b240d.png" alt="img"></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/11/01/webpack/webpack%E7%9A%84%E7%90%86%E8%A7%A3/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack创建library">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/10/31/webpack/webpack%E5%88%9B%E5%BB%BAlibrary/">webpack创建library</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-10-31
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>除了打包应用程序，webpack 还可以用于打包 JavaScript library。<br>例如：当我们想要自己开发一个组件库工具或者框架的时候也就是说我们自己造一个轮子给别人用的时候我们免不了要开发很多的模块，最终都可以请webpack来帮我们打包。</p>
<p><strong>创建一个 library</strong><br>假设我们正在编写一个名为 webpack-numbers 的小的 library，可以将数字 1 到 5转换为文本表示，反之亦然，例如将 2 转换为 ‘two’。<br>使用 npm 初始化项目，然后安装 webpack ， webpack-cli 和 lodash ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli lodash -D</span><br></pre></td></tr></table></figure>
<p>我们将 lodash 安装为 devDependencies 而不是 dependencies ，因为我们不需要将其打包到我们的库中，否则我们的库体积很容易变大。</p>
<p>src&#x2F;ref.json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 1,</span><br><span class="line">  &quot;word&quot;: &quot;One&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 2,</span><br><span class="line">  &quot;word&quot;: &quot;Two&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 3,</span><br><span class="line">  &quot;word&quot;: &quot;Three&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 4,</span><br><span class="line">  &quot;word&quot;: &quot;Four&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 5,</span><br><span class="line">  &quot;word&quot;: &quot;Five&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 0,</span><br><span class="line">  &quot;word&quot;: &quot;Zero&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import _ from &#x27;lodash&#x27;;</span><br><span class="line">import numRef from &#x27;./ref.json&#x27;;</span><br><span class="line">export function numToWord(num) &#123;</span><br><span class="line"> return _.reduce(</span><br><span class="line">  numRef,</span><br><span class="line"> (accum, ref) =&gt; &#123;</span><br><span class="line">   return ref.num === num ? ref.word : accum;</span><br><span class="line"> &#125;,</span><br><span class="line">  &#x27;&#x27;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">export function wordToNum(word) &#123;</span><br><span class="line"> return _.reduce(</span><br><span class="line">  numRef,</span><br><span class="line"> (accum, ref) =&gt; &#123;</span><br><span class="line">   return ref.word === word &amp;&amp; word.toLowerCase() ? ref.num :</span><br><span class="line">accum;</span><br><span class="line"> &#125;,</span><br><span class="line">  -1</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode:&#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  filename: &#x27;webpack-numbers.js&#x27;,</span><br><span class="line">  library:&#123;</span><br><span class="line">    name:&#x27;webpackNumbers&#x27;,</span><br><span class="line">	type&#x27;umd&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  globalObject:&#x27;globalThis&#x27;</span><br><span class="line">&#125;,</span><br><span class="line"> externals:&#123;</span><br><span class="line"> 	lodash:&#123;   lodash  引入包的名字</span><br><span class="line">		commonjs:&#x27;lodash&#x27;,   //  兼容引入形式</span><br><span class="line">		commonjs2:&#x27;lodash&#x27;,</span><br><span class="line">		amd:&#x27;lodash&#x27;,</span><br><span class="line">		root:&#x27;_&#x27;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>发布到线上</strong><br>拥有npm账号<br>npm config get registry   &#x2F;&#x2F; 一定要保证本地的registry的地址是<a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a>    因为这样的话才是真正的连接到npm官网的地址上   有些人可能是淘宝  那么就访问不上去了<br>npm adduser  &#x2F;&#x2F;添加用户   输入用户名密码<br>包的名字必须是全球唯一的。   npm publish    上传时package.json中的main入口必须对应：dist&#x2F;文件名   因为别人通过 require去载入包的时候  会读取 这个main这是的暴露的包的名字<br>npm install 包名就可以下载了</p>
<p><strong>Webpack 配置</strong></p>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">	path:&#x27;&#x27;,</span><br><span class="line">	filname:&#x27;&#x27;,</span><br><span class="line">	library:&#x27;&#x27;,    //我们只是定义了导出 并且没有使用它  所以webpack认为这个代码是没有用的。   如何让他作为一个library来进行一个对外的打包   让代码不被 Webpack Tree shaking   配置 library:&#x27;包的名字&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，一切都应该与打包应用程序一样，这里是不同的部分 - 我们需要通过output.library 配置项暴露从入口导出的内容。<br>我们暴露了 webpackNumbers ，以便用户可以通过 script 标签使用。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> window.webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然而它只能通过被 script 标签引用而发挥作用，它不能运行在 CommonJS、AMD、Node.js 等环境中。<br>作为一个库作者，我们希望它能够兼容不同的环境，也就是说，用户应该能够通过以下方式使用打包后的库：<br>CommonJS module require:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const webpackNumbers = require(&#x27;webpack-numbers&#x27;);</span><br><span class="line">// ...</span><br><span class="line">webpackNumbers.wordToNum(&#x27;Two&#x27;);</span><br></pre></td></tr></table></figure>
<p>AMD module require:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require([&#x27;webpackNumbers&#x27;], function (webpackNumbers) &#123;</span><br><span class="line"> // ...</span><br><span class="line"> webpackNumbers.wordToNum(&#x27;Two&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>script tag:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line"> &lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">  // ...</span><br><span class="line">  // Global variable</span><br><span class="line">  webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">  // Property in the window object</span><br><span class="line">  window.webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">  // ...</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>我们更新 output.library 配置项，将其 type 设置为 ‘umd’ ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  filename: &#x27;webpack-numbers.js&#x27;,</span><br><span class="line">  library: &#123;</span><br><span class="line">   name: &#x27;webpackNumbers&#x27;,</span><br><span class="line">   type: &#x27;umd&#x27;,   //  window&#x27;(es module)   &#x27;commonjs&#x27;   &#x27;module&#x27; 它在experiments:&#123;outputModule:true&#125;才能使用，他是一个实验性的功能，就不需要这个name了。&lt;script type=&quot;module&quot;&gt;    &#x27;umd&#x27;支持所有的类型。  esmodule 有问题</span><br><span class="line">  &#125;,</span><br><span class="line">  globalObject:&#x27;globalThis&#x27;    //需要全局的this来去  代替self   否则浏览器会self  undefined报错</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在 webpack 将打包一个库，其可以与 CommonJS、AMD 以及 script 标签使用</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/10/31/webpack/webpack%E5%88%9B%E5%BB%BAlibrary/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack proxy工作原理">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/10/26/webpack/webpack-proxy%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">webpack proxy工作原理</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-10-26
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务</p>
<p>基本行为就是接收客户端发送的请求后转发给其他服务器</p>
<p>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）</p>
<p>想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p>
<h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p><code>webpack-dev-server</code>是 <code>webpack</code> 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起</p>
<p>目的是为了提高开发者日常的开发效率，<strong>只适用在开发阶段</strong></p>
<p>关于配置方面，在<code>webpack</code>配置对象属性中通过<code>devServer</code>属性提供，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;https://api.github.com&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>devServetr</code>里面<code>proxy</code>则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配</p>
<p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为<code>/api</code>，值为对应的代理匹配规则，对应如下：</p>
<ul>
<li>target：表示的是代理到的目标地址</li>
<li>pathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite</li>
<li>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false</li>
<li>changeOrigin：它表示是否更新代理后请求的 headers 中host地址</li>
</ul>
<h2 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h2><p><code>proxy</code>工作原理实质上是利用<code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器</p>
<p>举个例子：</p>
<p>在开发阶段，本地地址为<code>http://localhost:3000</code>，该浏览器发送一个前缀带有<code>/api</code>标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="title function_">proxy</span>(&#123;<span class="attr">target</span>: <span class="string">&#x27;http://www.example.org&#x27;</span>, <span class="attr">changeOrigin</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar</span></span><br></pre></td></tr></table></figure>

<h2 id="三、跨域"><a href="#三、跨域" class="headerlink" title="三、跨域"></a>三、跨域</h2><p>在开发阶段， <code>webpack-dev-server</code> 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 <code>localhost</code>的一个端口上，而后端服务又是运行在另外一个地址上</p>
<p>所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题</p>
<p>通过设置<code>webpack proxy</code>实现代理请求后，相当于浏览器与服务端中添加一个代理者</p>
<p>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p>
<p><img src="https://static.vue-js.com/65b5e5c0-ace5-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据</p>
<p>注意：<strong>服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</strong></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/10/26/webpack/webpack-proxy%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">Read More</a>
    </footer>
</div>



<ul class="cube-pagination cube-pagination-9">
    
    <li class="cube-pagination-prev">
        <a href="/page/4/">« Prev</a>
    </li>
    
    
        
                <li class="cube-pagination-index">
                    <a href="/">1</a>
                </li>
                <li class="cube-pagination-ellipses">
                    <span>...</span>
                </li>
            
                
                <li class="cube-pagination-index">
                    <a href="/page/4">4</a>
                </li>
                
            
                
                <li class="cube-pagination-index disabled">
                    <span>5</span>
                </li>
                
            
                
                <li class="cube-pagination-index">
                    <a href="/page/6">6</a>
                </li>
                
            
                <li class="cube-pagination-ellipses">
                    <span>...</span>
                </li>
                <li class="cube-pagination-index">
                    <a href="/page/19">19</a>
                </li>
        
    

    
    <li class="cube-pagination-next">
        <a href="/page/6/">Next »</a>
    </li>
    
</ul>

<!--其他组件后续添加-->
        </div>
        <div class="cube-right">
            

<div class="cube-search cube-sidebar" id="cube-search">
    <div class="search-container">
        <input type="text" placeholder="Search" class="cube-search-input" id="cube-search-input">
        <i class="cube-icon cube-icon-search cube-search-submit" aria-hidden="true"></i>
    </div>
    <!-- TODO 通过给window赋一个全局变量，通过脚本赋值 -->
</div>
<script>
    (function (window) {
        'use strict';
        window.searchModule = {}
        window.searchModule.JSONUrl = '/content.json'
        window.searchModule.rootUrl = '/'
    })(window)
</script>
<div class="cube-search-form">
    <div class="cube-search-control">
        <input type="text" placeholder="Search" class="search-input">
        <a class="close-button">
            <i class="cube-icon cube-close" aria-hidden="true"></i>
        </a>
    </div>
    <div class="cube-search-result"></div>
</div>


<div class="cube-author cube-sidebar" id="cube-author">
    
    
    <span>John Doe</span>
    
    
    <div class="count">
        <a class="count articles"><span>186</span>Article</a>
        <a class="count tags"><span>35</span>Tags</a>
        <a class="count categories"><span>23</span>Categories</a>
    </div>
</div>



<div class="cube-music cube-sidebar" id="cube-music">
    <div class="cube-player aplayer" id="cube-player"></div>
</div>
<script>
    (function (window) {
        window.musicModule = {}
        window.musicModule.musicConfig = '{"narrow":false,"autoplay":false,"showlrc":3,"theme":"#b7daff","mutex":true,"mode":"circulation","preload":"auto","listmaxheight":"513px","music":[{"title":"Dear friends","author":"TRIPLANE","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/TRIPLANE - Dear friends.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Dear friends - TRIPLANE.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/TRIPLANE - Dear friends.jpg"},{"title":"Butter-Fly","author":"和田光司","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/和田光司 - Butter-Fly (ピアノヴァージョン).mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Butter-Fly (ピアノヴァージョン) - 和田光司.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/和田光司 - Butter-Fly (ピアノヴァージョン).jpg"},{"title":"宵闇花火","author":"葉月ゆら","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/葉月ゆら - 宵闇花火.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/宵闇花火 - 葉月ゆら.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/葉月ゆら - 宵闇花火.jpg"}]}'
        window.musicModule.lrcConfig = {
            open: 'Open Lyrics',
            close: 'Close Lyrics'
        }
    })(window)
</script>



<div class="cube-recent-posts cube-sidebar" id="cube-recent-posts">
    <div class="title">
        <a>Recent Posts</a>
    </div>
    <ul class="list">
        
        
        <li>
            <!-- TODO 如果文章要显示图片，那么在front-matter上添加preview属性(url or path) -->
            
            <div class="normal">
                <p class="index first">
                    <span>1</span>
                </p>
                <p class="title">
                    <a href="/2022/08/25/Js%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="变量类型">变量类型</a>
                </p>
            </div>
            
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>2</span>
                </p>
                <p class="title">
                    <a href="/2022/06/09/html+css+js+ts/3-js%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/" title="js-常用代码操作实例">js-常用代码操作实例</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>3</span>
                </p>
                <p class="title">
                    <a href="/2022/05/28/html+css+js+ts/1-%E9%9F%B3%E8%A7%86%E9%A2%91/" title="html-原生音视频">html-原生音视频</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>4</span>
                </p>
                <p class="title">
                    <a href="/2022/04/25/http/DNS%E5%8D%8F%E8%AE%AE/" title="DNS协议">DNS协议</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>5</span>
                </p>
                <p class="title">
                    <a href="/2022/04/17/html+css+js+ts/4-%E8%A3%85%E9%A5%B0%E5%99%A8/" title="ES6 装饰器">ES6 装饰器</a>
                </p>
            </div>
        </li>
        
        
    </ul>
</div>



<div class="cube-categories cube-sidebar" id="cube-categories">
    <div class="title">
        <a href="/categories">Categories</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/categories/http/">#http</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/React/">#React</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">#数据可视化</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">#架构模式</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/">#前端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">#移动端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E9%9F%B3%E8%A7%86%E9%A2%91/">#音视频</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/javascript/">#javascript</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">#问题</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/">#后端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">#小程序</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">#前端工程化</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%B7%A5%E5%85%B7/">#工具</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">#正则表达式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">#前端性能优化</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">#数据库</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/liunx/">#liunx</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a>
        </div>
        
    </div>
</div>



<div class="cube-tagcloud cube-sidebar" id="cube-tagcloud">
    <div class="title">
        <a href="/tags">Tagcloud</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box-bg ">
            <a href="/tags/http/">#http</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/vue/">#vue</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/React/">#React</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Redux/">#Redux</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/echart/">#echart</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/vue3/">#vue3</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/react/">#react</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/html/">#html</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/xml/">#xml</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">#移动端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/css/">#css</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/javascript/">#javascript</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Promise/">#Promise</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/es6/">#es6</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/typescript/">#typescript</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/async-await/">#async/await</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/nodejs/">#nodejs</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">#小程序</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/python/">#python</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/glup/">#glup</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/webpack/">#webpack</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/git/">#git</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Mock/">#Mock</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/eslint/">#eslint</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/RESTful/">#RESTful</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/hexo/">#hexo</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/vs-code/">#vs code</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">#正则表达式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E4%BC%98%E5%8C%96/">#优化</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/mongodb/">#mongodb</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/mysql/">#mysql</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/nginx/">#nginx</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a>
        </div>
        
    </div>
</div>



<div class="cube-links cube-sidebar" id="cube-links">
    <div class="title">
        <a>Links</a>
    </div>
    <ul class="list">
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/GitHub.png">
            
            <a href="https://github.com/ZEROKISEKI" target="_blank">GitHub</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/Coding.png">
            
            <a href="https://coding.net/u/SORA1" target="_blank">Coding</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/SF.png">
            
            <a href="https://segmentfault.com/u/aonosora" target="_blank">SF社区</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/开发者头条.png">
            
            <a href="https://toutiao.io/u/148070" target="_blank">开发者头条</a>
        </li>
        
    </ul>
</div>



<div class="cube-friend-links cube-sidebar" id="cube-friend-links">
    <div class="title">
        <a>Friend Links</a>
    </div>
    <ul class="list">
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/micblo.png">
            <a href="https://blog.micblo.com/" target="_blank">罗大佬</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/DIYgod.jpg">
            <a href="https://www.anotherhome.net/" target="_blank">DIYgod</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="/images/friend_links.jpg ">
            <a href="https://aonosora.com/" target="_blank">咪西西の部落格</a>
        </li>
        
    </ul>
</div>


        </div>
    </div>
</div>
<footer class="cube-footer">
    
© 2017 John Doe

<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.&nbsp;Theme by <a href="https://github.com/ZEROKISEKI" target="_blank">AONOSORA</a>
</footer>
<!-- inject:script -->
<script src="/js/script.js"></script>
<!-- endinject -->
<div class="cube-loading out"></div>
</body>
</html>