<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="John Doe">
    
    
    
    
    
    
    <title>Hexo</title>
    <!-- inject:style -->
    <link href="/css/style.css" rel="stylesheet" type="text/css">
    <!-- endinject -->
    <style>
        .cube-loading {
            top: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('/images/lg/loading.gif') no-repeat center center;
            background-color: rgba(0,0,0,.7);
        }

        .cube-loading.out {
            display: none;
        }

        .cube-loading:before {
            display: block;
            content: 'Loading';
            position: relative;
            width: 100%;
            top: 50%;
            right: -50%;
            color: #fff;
        }

        @media(max-width: 768px) {
            .cube-loading:before {
                font-size: 1.2em;
                transform: translate(-24px,20px);
                -webkit-transform: translate(-24px,20px);
                -o-transform: translate(-24px,20px);
                -ms-transform: translate(-24px,20px);
            }
        }

        @media(min-width: 768px) {
            .cube-loading:before {

            }
        }
    </style>
    
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
<div class="cube-body">
    <nav id="cube-top-memu" class="cube-menu">
    <ul class="cube-menu-collapse">
        
        <li>
            <i class="cube-icon cube-icon-home" aria-hidden="true"></i>
            <a href="/">首页</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-archive" aria-hidden="true"></i>
            <a href="/archives">归档</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-categories" aria-hidden="true"></i>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-tags" aria-hidden="true"></i>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-about" aria-hidden="true"></i>
            <a href="/about-me">关于我</a>
        </li>
        
    </ul>
</nav>
<nav class="cube-side-menu" id="cube-side-menu">
    <ul class="cube-menu-list">
        
        <li>
            <a class="lrc-control">Open Lyrics</a>
        </li>
        
        <li>
            <a class="scroll-to-top">Top</a>
        </li>
    </ul>
</nav>
    <header class="cube-header" id="cube-header">
    <img src=" https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201502%2F28%2F20150228220759_zaP3N.png&amp;refer=http%3A%2F%2Fb-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664943562&amp;t=f546331d7d5aee27ceb7af09c60899f2 " alt="头部背景图片">
    
    <div class="cube-type">
        <span class="cube-typed-title">🍍的个人博客 ^_^</span>
        <span class="cube-typed-cursor">|</span>
    </div>
    
</header>

    <style>
        nav.cube-menu:before {
            content: '';
            visibility: hidden;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 44px;
        
            filter: blur(5px);
            -webkit-filter: blur(5px);
        
            z-index: -1;
            background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201502%2F28%2F20150228220759_zaP3N.png&amp;refer=http%3A%2F%2Fb-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664943562&amp;t=f546331d7d5aee27ceb7af09c60899f2');
            background-repeat: no-repeat;
            background-position: center -356px;
            background-size: cover;
            background-color: transparent;
        }

        header.cube-background.cube-header-background {
            visibility: hidden;
            background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201502%2F28%2F20150228220759_zaP3N.png&amp;refer=http%3A%2F%2Fb-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664943562&amp;t=f546331d7d5aee27ceb7af09c60899f2');
            background-position: center -400px;
        }
    </style>
    <header class="cube-background cube-header-background">
        
        <div class="cube-type">
            <span class="cube-typed-title">🍍的个人博客 ^_^</span>
            <span class="cube-typed-cursor">|</span>
        </div>
        
    </header>
    <div class="load-header-background"></div>
    <script>
        (function (window) {

            window.headerModule = {}
            window.headerModule.image = {
                width: '2000',
                height: '1414'
            }

        })(window)
    </script>
    
    <div class="cube-content">
        <div class="cube-left">
            
<div class="cube-excerpt" id="cube-excerpt-前端性能优化-Performance以及动画帧数">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/16/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8BPerformance%E4%BB%A5%E5%8F%8A%E5%8A%A8%E7%94%BB%E5%B8%A7%E7%8E%87(FPS)/">前端性能优化-Performance以及动画帧数</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-16
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/%E4%BC%98%E5%8C%96/" class="cube-excerpt-tag-link">#优化</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <blockquote>
<p><code>Performance</code>是一个做前端性能监控离不开的<code>API</code>，最好在页面完全加载完成之后再使用，因为很多值必须在页面完全加载之后才能得到。最简单的办法是在<code>window.onload</code>事件中读取各种数据。</p>
</blockquote>
<h2 id="一、回顾页面加载过程"><a href="#一、回顾页面加载过程" class="headerlink" title="一、回顾页面加载过程"></a>一、回顾页面加载过程</h2><blockquote>
<p>要学习这套<code>API</code>的使用，先简单介绍下前端的基础知识</p>
</blockquote>
<h3 id="1-1-页面加载"><a href="#1-1-页面加载" class="headerlink" title="1.1 页面加载"></a>1.1 页面加载</h3><blockquote>
<p>一个页面的请求到响应再到显示出来，需要经过下面一些重要过程，当我们在浏览器输入一个<code>URL</code>或者说点击一个<code>URL</code>开始，会出现如下流程</p>
</blockquote>
<ul>
<li>页面准备</li>
<li>重定向：在<code>header</code>定义了重定向才会有这个过程，如果没有重定向，不会产生这个过程。</li>
<li><code>app cache</code>：会先检查这个域名是否有缓存，如果有缓存就不需要DNS解析域名。这里的<code>app</code>是值应用程序<code>application</code>，不指手机<code>app</code>。</li>
<li><code>DNS</code>解析：把域名解析成<code>IP</code>，如果直接用<code>ip</code>地址访问，不产生这个过程。</li>
<li><code>TCP</code>连接：<code>http</code>协议是经过<code>TCP</code>来传输的，所以产生一个<code>http</code>请求就会有<code>TCP connect</code>，但是依赖于长连接，不会产生这个过程。</li>
<li><code>request header</code>：请求头信息。</li>
<li><code>request body</code>：请求体信息，比如<code>get</code>请求是没有请求体信息的，所以没有这个过程，这就是为什么把头跟体分开写的原因。</li>
<li><code>response header</code>：响应头信息。</li>
<li><code>response body</code>：响应体信息。</li>
<li>解析<code>HTML</code>结构</li>
<li>加载外部脚本和样式表文件：正常来说<code>JS</code>、<code>css</code>都是外部加载的，当然有不正常的人啊，比如我。</li>
<li>解析并执行脚本代码</li>
<li>构建与解析<code>HTML DOM</code>树：这个过程可以去了解下<code>DOM</code>树是怎样的就明白啦。</li>
<li>加载外部图片</li>
<li>页面加载完成，显示出来啦</li>
</ul>
<h3 id="1-2-重定向分析"><a href="#1-2-重定向分析" class="headerlink" title="1.2 重定向分析"></a>1.2 重定向分析</h3><ul>
<li><code>app cach</code></li>
<li><code>DNS</code>解析</li>
<li><code>TCP</code>连接</li>
<li><code>request header</code></li>
<li>重定向</li>
<li><code>app cach</code></li>
<li><code>DNS</code>解析</li>
<li><code>TCP</code>连接</li>
<li><code>request header</code></li>
</ul>
<h2 id="二、performance"><a href="#二、performance" class="headerlink" title="二、performance"></a>二、performance</h2><h3 id="2-1-performance-timing"><a href="#2-1-performance-timing" class="headerlink" title="2.1 performance.timing"></a>2.1 performance.timing</h3><blockquote>
<p>这个API能帮我们得到整个页面请求的时间，如下图，在<code>Chrome</code>的<code>Console</code>是可以直接运行的</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20170316140524418" alt="img"></p>
<p>先解释下这些时间都是代表什么</p>
<p><strong>timing 对象里边的数据比较多，梳理如下几个关键性的节点</strong></p>
<ul>
<li><code>fetchStart</code>：发起获取当前文档的时间点，我的理解是浏览器收到发起页面请求的时间点；</li>
<li><code>domainLookupStart</code>：返回浏览器开始<code>DNS</code>查询的时间，如果此请求没有<code>DNS</code>查询过程，如长连接、资源<code>cache</code>、甚至是本地资源等，那么就返回<code>fetchStart</code>的值；</li>
<li><code>domainLookupEnd</code>：返回浏览器结束<code>DNS</code>查询的时间，如果没有<code>DNS</code>查询过程，同上；</li>
<li><code>connectStart</code>：浏览器向服务器请求文档，开始建立连接的时间，如果此连接是一个长连接，或者无需与服务器连接（命中缓存），则返回<code>domainLookupEnd</code>的值；</li>
<li><code>connectEnd</code>：浏览器向服务器请求文档，建立连接成功的时间；</li>
<li><code>requestStart</code>：开始请求文档的时间（注意没有<code>requestEnd</code>）;</li>
<li><code>responseStart</code>：浏览器开始接收第一个字节数据的时间，数据可能来自于服务器、缓存、或本地资源；</li>
<li><code>unloadEventStart</code>：卸载上一个文档开始的时间；</li>
<li><code>unloadEventEnd</code>：卸载上一个文档结束的时间；</li>
<li><code>domLoading</code>：浏览器把<code>document.readyState</code>设置为<code>“loading”</code>的时间点，开始构建<code>dom</code>树的时间点；</li>
<li><code>responseEnd</code>：浏览器接收最后一个字节数据的时间，或连接被关闭的时间；</li>
<li><code>domInteractive</code>：浏览器把<code>document.readyState设</code>置为<code>“interactive”</code>的时间点，<code>DOM</code>树创建结束；</li>
<li><code>domContentLoadedEventStart</code>：文档发生<code>DOMContentLoaded</code>事件的时间；</li>
<li><code>domContentLoadedEventEnd</code>：文档的<code>DOMContentLoaded</code>事件结束的时间；</li>
<li><code>domComplete</code>：浏览器把<code>document.readyState</code>设置为<code>“complete”</code>的时间点；</li>
<li><code>loadEventStart</code>：文档触发<code>load</code>事件的时间；</li>
<li><code>loadEventEnd</code>：文档出发<code>load</code>事件结束后的时间</li>
</ul>
<blockquote>
<p>再来一张图，表示各阶段的开始与结束对应的时间</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/8554143/33872196-d6c35844-df50-11e7-8bcc-1fdcac66ce64.png" alt="img"></p>
<blockquote>
<p>从以上的分析，我们就可以得到一些时间的计算</p>
</blockquote>
<ul>
<li>准备新页面耗时：<code>fetchStart - navigationStart</code></li>
<li>重定向时间：<code>redirectEnd - redirectStart</code></li>
<li><code>App Cache</code>时间：<code>domainLookupStart - fetchStart</code></li>
<li><code>DNS</code>解析时间：<code>domainLookupEnd -domainLookupStart</code></li>
<li><code>TCP</code>连接时间：<code>connectEnd - connectStart</code></li>
<li><code>request</code>时间：<code>responseEnd - requestStart</code>这个计算是代表请求响应加起来的时间</li>
<li>请求完毕到<code>DOM</code>树加载：<code>domInteractive -responseEnd</code></li>
<li>构建与解析<code>DOM</code>树，加载资源时间：<code>domCompleter -domInteractive</code></li>
<li><code>load</code>时间：<code>loadEventEnd - loadEventStart</code></li>
<li>整个页面加载时间：<code>loadEventEnd -navigationStart</code></li>
<li>白屏时间：<code>responseStart-navigationStart</code></li>
</ul>
<h3 id="2-2-performance-getEntries"><a href="#2-2-performance-getEntries" class="headerlink" title="2.2 performance.getEntries()"></a>2.2 performance.getEntries()</h3><blockquote>
<p>这个API能帮我们获得资源的请求时间，包括JS、CSS、图片等</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20170316155201356" alt="img"></p>
<blockquote>
<p>如上图可以看到这个API请求返回的是一个数组，这个数组包括整个页面所有的资源加载，上图打开了一个其中一个资源，可以看到如下信息</p>
</blockquote>
<ul>
<li><code>entryType</code>：类型为<code>resource</code></li>
<li><code>name</code>：资源的<code>url</code></li>
<li><code>initiatorType</code>：资源是<code>link</code></li>
<li>资源时间：<code>duration</code>的值，是<code>responseEnd - startTime</code>得到的</li>
</ul>
<h3 id="2-3-performance-memory"><a href="#2-3-performance-memory" class="headerlink" title="2.3 performance.memory"></a>2.3 performance.memory</h3><blockquote>
<p>这个API主要是得到浏览器内存情况</p>
</blockquote>
<ul>
<li><code>jsHeapSizeLimit</code>：内存大小限制</li>
<li><code>totalJSHeapSize</code>：可使用的内容</li>
<li><code>userdJSHeapSize</code>：已使用的内容</li>
</ul>
<blockquote>
<p><code>userdJSHeapSize</code>表示所有被使用的JS堆栈内存，<code>totalJSHeapSize</code>可使用的JS堆栈内存，如果<code>userdJSHeapSize</code>的值大于<code>totalJSHeapSize</code>，就可能出现内存泄漏</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20170316155226893" alt="img"></p>
<h2 id="三、动画帧率FPS"><a href="#三、动画帧率FPS" class="headerlink" title="三、动画帧率FPS"></a>三、动画帧率FPS</h2><h3 id="3-1-流畅动画的标准"><a href="#3-1-流畅动画的标准" class="headerlink" title="3.1 流畅动画的标准"></a>3.1 流畅动画的标准</h3><blockquote>
<p><code>FPS</code> 表示的是每秒钟画面更新次数。我们平时所看到的连续画面都是由一幅幅静止画面组成的，每幅画面称为一帧，<code>FPS</code> 是描述“帧”变化速度的物理量</p>
</blockquote>
<ul>
<li>理论上说，<code>FPS</code> 越高，动画会越流畅，目前大多数设备的屏幕刷新率为 <code>60</code> 次&#x2F;秒，所以通常来讲 <code>FPS</code> 为 <code>60 frame/s</code> 时动画效果最好，也就是每帧的消耗时间为 <code>16.6</code>7ms</li>
</ul>
<p><strong>不同帧率的体验</strong></p>
<ul>
<li>帧率能够达到 <code>50 ～ 60 FPS</code> 的动画将会相当流畅，让人倍感舒适；</li>
<li>帧率在 <code>30 ～ 50 FPS</code> 之间的动画，因各人敏感程度不同，舒适度因人而异；</li>
<li>帧率在 <code>30 FPS</code> 以下的动画，让人感觉到明显的卡顿和不适感；</li>
<li>帧率波动很大的动画，亦会使人感觉到卡顿</li>
</ul>
<h3 id="3-2-获取我们页面动画当前的-FPS-值"><a href="#3-2-获取我们页面动画当前的-FPS-值" class="headerlink" title="3.2 获取我们页面动画当前的 FPS 值"></a>3.2 获取我们页面动画当前的 FPS 值</h3><blockquote>
<p>那么我们该如何准确的获取我们页面动画当前的 FPS 值呢？</p>
</blockquote>
<h4 id="3-2-1-方法一-借助-Chrome-开发者工具"><a href="#3-2-1-方法一-借助-Chrome-开发者工具" class="headerlink" title="3.2.1 方法一 借助 Chrome 开发者工具"></a>3.2.1 方法一 借助 Chrome 开发者工具</h4><blockquote>
<p><code>Chrome</code> 提供给开发者的功能十分强大，在开发者工具中，我们进行如下选择调出 <code>FPS meter</code> 选项：</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/8554143/33823997-e25d42dc-de97-11e7-92e3-8521ede019df.png" alt="img"></p>
<blockquote>
<p>通过这个按钮，可以开启页面实时 <code>Frame Rate</code> (帧率) 观测及页面 <code>GPU</code> 使用率</p>
</blockquote>
<p><strong>但是这个方法缺点太多了</strong></p>
<ul>
<li>这个只能一次观测一到几个页面，而且需要人工实时观测</li>
<li>数据只能是主观感受，并没有一个十分精确的数据不断上报或者被收集</li>
<li>因此，我们需要更加智能的方法。</li>
</ul>
<h4 id="3-2-2-方法二-借助-Frame-Timing-API"><a href="#3-2-2-方法二-借助-Frame-Timing-API" class="headerlink" title="3.2.2 方法二 借助 Frame Timing API"></a>3.2.2 方法二 借助 Frame Timing API</h4><blockquote>
<p>Blink 内核早期架构</p>
</blockquote>
<ul>
<li>以 <code>Chrome</code> 浏览器内核 <code>Blink</code> 渲染页面为例。对早期的 <code>Chrome</code> 浏览器而言，每个页面 <code>Tab</code> 对应一个独立的 <code>renderer</code> 进程，<code>Renderer</code>进程中包含了主线程和合成线程。早期 <code>Chrome</code> 内核架构</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/8554143/33830985-4ab23108-deb1-11e7-89ed-6b9f60dcb2fd.jpg" alt="img"></p>
<p><strong>其中，主线程主要负责</strong>：</p>
<ul>
<li><code>Javascript</code> 的计算与执行</li>
<li><code>CSS</code> 样式计算</li>
<li><code>Layout</code> 计算</li>
<li>将页面元素绘制成位图（<code>paint</code>），也就是光栅化（<code>Raster</code>）</li>
<li>将位图给合成线程</li>
</ul>
<p><strong>合成线程则主要负责</strong>：</p>
<ul>
<li>将位图(<code>GraphicsLayer</code> 层)以纹理(<code>texture</code>)的形式上传给 <code>GPU</code></li>
<li>计算页面的可见部分和即将可见部分（滚动）</li>
<li><code>CSS</code> 动画处理</li>
<li>通知 GPU 绘制位图到屏幕上</li>
</ul>
<blockquote>
<p>其实知道了这两个线程之后，下一个概念是厘清 <code>CSS</code> 动画与 <code>JS</code> 动画的细微区别（当然它们都是 Web 动画）</p>
</blockquote>
<p><strong>JS 动画与 CSS 动画的细微区别</strong></p>
<ul>
<li>对于 <code>JS</code>动画而言，它们运行时的帧率即是主线程和合成线程加起来消耗的时间。对于流畅动画而言，我们希望它们每一帧的耗时保持在 <code>16.67ms</code> 之内;</li>
<li>而对于 <code>CSS</code> 动画而言，由于其流程不受主线程的影响，所以希望能得到合成线程的消耗的时间，而合成线程的绘制频率也反映了滚动和 CSS 动画的流程性。</li>
</ul>
<blockquote>
<p>上面主要想得出的一个结论是。如果我们能够知道主线程和合成线程每一帧消耗的时间，那么我们就能大致得出对应的 Web 动画的帧率。那么上面说到的 <code>Frame Timing API</code> 是否可以帮助我们拿到这个时间点呢</p>
</blockquote>
<p><strong>什么是 Frame Timing API ？</strong></p>
<blockquote>
<p><code>Frame Timing API</code> 是 <code>Web Performance Timing API</code> 标准中的其中一位成员。<code>Web Performance Timing API</code> 是 W3C 推出的一套性能 API 标准，用于帮助开发者对网站各方面的性能进行精确的分析与控制，提升 Web 网站性能</p>
</blockquote>
<p>它包含许多子类 API，完成不同的功能，大致如下</p>
<p><img src="https://user-images.githubusercontent.com/8554143/33871575-0799a66a-df4e-11e7-85fd-9b40d43161da.png" alt="img"></p>
<p>怎么使用呢？以 <code>Navigation Timing</code>, <code>Performance Timeline</code>, <code>Resource Timing</code> 为例子，对于兼容它的浏览器，它以只读属性的形式对外暴露挂载在 <code>window.performance</code> 上。</p>
<p>我们再来回顾这张图</p>
<p><img src="https://user-images.githubusercontent.com/8554143/33872196-d6c35844-df50-11e7-8bcc-1fdcac66ce64.png" alt="img"></p>
<blockquote>
<p>通过这张图以及上面的 <code>window.performance.timing</code>，我们就可以轻松的统计出页面每个重要节点的耗时，这就是 <code>Web Performance Timing API</code> 的强大之处，感兴趣的可以详细去研究研究，使用在页面统计上</p>
</blockquote>
<p><strong>Frame Timing API 示意</strong></p>
<blockquote>
<p>终于可以回归正题，借助 <code>Web Performance Timing API</code> 中的<code>Frame Timing API</code>，可以轻松的拿到每一帧中，主线程以及合成线程的时间。或者更加容易，直接拿到每一帧的耗时</p>
</blockquote>
<p>获取 <code>Render</code> 主线程和合成线程的记录，每条记录包含的信息基本如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var rendererEvents = window.performance.getEntriesByType(&quot;renderer&quot;);</span><br><span class="line">var compositeThreadEvents = window.performance.getEntriesByType(&quot;composite&quot;);</span><br></pre></td></tr></table></figure>

<p>或者是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ar observer = new PerformanceObserver(function(list) &#123;</span><br><span class="line">    var perfEntries = list.getEntries();</span><br><span class="line">    for (var i = 0; i &lt; perfEntries.length; i++) &#123;</span><br><span class="line">        console.log(&quot;frame: &quot;, perfEntries[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">// subscribe to Frame Timing</span><br><span class="line">observer.observe(&#123;entryTypes: [&#x27;frame&#x27;]&#125;);</span><br></pre></td></tr></table></figure>

<p>每条记录包含的信息基本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  sourceFrameNumber: 120,</span><br><span class="line">  startTime: 1342.549374253</span><br><span class="line">  cpuTime: 6.454313323</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个记录都包括唯一的 <code>Frame Number</code>、<code>Frame</code> 开始时间以及 <code>cpuTime</code> 时间。通过计算每一条记录的 <code>startTime</code> ，我们就可以算出每两帧间的间隔，从而得到动画的帧率是否能够达到 <code>60 FPS</code></p>
</blockquote>
<p><strong>看看 Web Performance Timing API 整体的兼容性</strong></p>
<p><img src="https://user-images.githubusercontent.com/8554143/33873788-4ad802e2-df57-11e7-9174-13913bcaa9b5.png" alt="img"></p>
<blockquote>
<p><code>Frame Timing API</code> 虽好，但是，现在 <code>Frame Timing API</code> 的兼容性不算很友好，额，不友好到什么程度呢。还没有任何浏览器支持，处于实验性阶段，属于面向未来编程</p>
</blockquote>
<h4 id="3-2-3-方法三-借助-requestAnimationFrame-API"><a href="#3-2-3-方法三-借助-requestAnimationFrame-API" class="headerlink" title="3.2.3 方法三 借助 requestAnimationFrame API"></a>3.2.3 方法三 借助 requestAnimationFrame API</h4><blockquote>
<p>从上面的介绍，我们得知，如果我们可以到得到每一帧中的固定一个时间点，那么两者相减，也能够近似得到一帧所消耗的时间</p>
</blockquote>
<p>这次，我们借助兼容性不错的 <code>requestAnimationFrame API</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 语法</span><br><span class="line">window.requestAnimationFrame(callback);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>requestAnimationFrame</code> 大家应该都不陌生，方法告诉浏览器您希望执行动画并请求浏览器调用指定的函数在下一次重绘之前更新动画。</li>
<li>当你准备好更新屏幕画面时你就应用此方法。这会要求你的动画函数在浏览器下次重绘前执行。回调的次数常是每秒 <code>60</code> 次，大多数浏览器通常匹配 <code>W3C</code> 所建议的刷新率</li>
</ul>
<p><strong>使用 requestAnimationFrame 计算 FPS 原理</strong></p>
<blockquote>
<p>原理是，正常而言 <code>requestAnimationFrame</code> 这个方法在一秒内会执行 <code>60</code> 次，也就是不掉帧的情况下。假设动画在时间 <code>A</code> 开始执行，在时间 <code>B</code> 结束，耗时 <code>x ms</code>。而中间 <code>requestAnimationFrame</code> 一共执行了 <code>n</code> 次，则此段动画的帧率大致为：<code>n / (B - A)</code></p>
</blockquote>
<p>核心代码如下，能近似计算每秒页面帧率，以及我们额外记录一个 <code>allFrameCount</code>，用于记录 <code>rAF</code> 的执行次数，用于计算每次动画的帧率 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var rAF = function () &#123;</span><br><span class="line">    return (</span><br><span class="line">        window.requestAnimationFrame ||</span><br><span class="line">        window.webkitRequestAnimationFrame ||</span><br><span class="line">        function (callback) &#123;</span><br><span class="line">            window.setTimeout(callback, 1000 / 60);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;();</span><br><span class="line">  </span><br><span class="line">var frame = 0;</span><br><span class="line">var allFrameCount = 0;</span><br><span class="line">var lastTime = Date.now();</span><br><span class="line">var lastFameTime = Date.now();</span><br><span class="line">  </span><br><span class="line">var loop = function () &#123;</span><br><span class="line">    var now = Date.now();</span><br><span class="line">    var fs = (now - lastFameTime);</span><br><span class="line">    var fps = Math.round(1000 / fs);</span><br><span class="line">  </span><br><span class="line">    lastFameTime = now;</span><br><span class="line">    // 不置 0，在动画的开头及结尾记录此值的差值算出 FPS</span><br><span class="line">    allFrameCount++;</span><br><span class="line">    frame++;</span><br><span class="line">  </span><br><span class="line">    if (now &gt; 1000 + lastTime) &#123;</span><br><span class="line">        var fps = Math.round((frame * 1000) / (now - lastTime));</span><br><span class="line">        console.log(`$&#123;new Date()&#125; 1S内 FPS：`, fps);</span><br><span class="line">        frame = 0;</span><br><span class="line">        lastTime = now;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    rAF(loop);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">loop();</span><br></pre></td></tr></table></figure>

<p>寻找一个有动画不断运行的页面进行测试，可以看到代码运行如下：</p>
<p><img src="https://user-images.githubusercontent.com/8554143/33877304-eae6fddc-df62-11e7-8d5f-8674dba3d1f9.png" alt="img"></p>
<ul>
<li>使用了我之前制作的一个页面进行了测试，使用<code>Chrome</code> 同时调出页面的 <code>FPS meter</code>，对比两边的实时 <code>FPS</code>值，基本吻合。</li>
<li>测试页面，<code>Solar System</code>。你可以将上面的代码贴到这个页面的 <code>console</code> 中，测试一下数据</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/8554143/33877626-ed17f3c6-df63-11e7-8bae-40b9512c2645.gif" alt="img"></p>
<ul>
<li>对比右上角的 <code>Frame Rate</code>，帧率基本一致。在大部分情况下，这种方法可以很好的得出 Web 动画的帧率。</li>
<li>如果我们需要统计某个特定动画过程的帧率，只需要在动画开始和结尾两处分别记录 <code>allFrameCount</code> 这个数值大小，再除以中间消耗的时间，也可以得出特定动画过程的 <code>FPS</code> 值。</li>
<li>值得注意的是，这个方法计算的结果和真实的帧率肯定是存在误差的，因为它是将每两次主线程执行 <code>javascript</code>的时间间隔当成一帧，而非上面说的主线程加合成线程所消耗的时间为一帧。但是对于现阶段而言，算是一种可取的方法</li>
</ul>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/16/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8BPerformance%E4%BB%A5%E5%8F%8A%E5%8A%A8%E7%94%BB%E5%B8%A7%E7%8E%87(FPS)/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-vue-事件">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/15/Vue/vue-%E4%BA%8B%E4%BB%B6/">vue-事件</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-15
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/vue/" class="cube-excerpt-tag-link">#vue</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、方法传参"><a href="#一、方法传参" class="headerlink" title="一、方法传参"></a>一、方法传参</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;test&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;sayHi(&#x27;你好&#x27;)&quot;&gt;说你好&lt;/button&gt; &lt;!--这里使用@--&gt;</span><br><span class="line">    &lt;button @click=&quot;sayHi(&#x27;我被点击了&#x27;)&quot;&gt;说我被点击了&lt;/button&gt; &lt;!--这里使用@--&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var myVue = new Vue(&#123;</span><br><span class="line">        el: &#x27;#test&#x27;,</span><br><span class="line">        methods: &#123;      //这里使用methods</span><br><span class="line">            sayHi: function (message) &#123;</span><br><span class="line">                alert(message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="二、vue访问原生-DOM-事件"><a href="#二、vue访问原生-DOM-事件" class="headerlink" title="二、vue访问原生 DOM 事件"></a>二、vue访问原生 DOM 事件</h2><blockquote>
<p>用<code>$event</code>获取</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;changeColor(&#x27;你好&#x27;,$event)&quot;&gt;点击我&lt;/button&gt; &lt;!--这里使用@--&gt;</span><br><span class="line">&lt;div style=&quot;height: 100px;width: 100px;background-color: red;&quot; @mouseover=&quot;over(&#x27;鼠标从我上面滑过&#x27;,$event)&quot;&gt;</span><br><span class="line">    鼠标从我上面滑过试试</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var myVue = new Vue(&#123;</span><br><span class="line">        el: &#x27;#test&#x27;,</span><br><span class="line">        methods: &#123;      //这里使用methods</span><br><span class="line">            changeColor: function (message, event) &#123;</span><br><span class="line">                alert(message+event);    //弹出我被点击了,事件是[object MouseEvent]</span><br><span class="line">            &#125;,</span><br><span class="line">            over :function (message, event) &#123;</span><br><span class="line">                alert(message+event);   //弹出鼠标从我上面滑过,事件是[object MouseEvent]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、事件修饰符"><a href="#三、事件修饰符" class="headerlink" title="三、事件修饰符"></a>三、事件修饰符</h2><blockquote>
<p>事件修饰符有基本的6种</p>
</blockquote>
<p><strong>.stop阻止事件冒泡</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><strong>.prevent阻止默认事件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p><strong>.capture时间捕获（从上到下）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>.self只在元素自身回调</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>.once只触发一次</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 [<code>@click.prevent.self](mailto:</code>@click.prevent.self)<code>会阻止所有的点击，而</code>@click.self.prevent&#96; 只会阻止元素上的点击</p>
</blockquote>
<h2 id="四、键值修饰符"><a href="#四、键值修饰符" class="headerlink" title="四、键值修饰符"></a>四、键值修饰符</h2><blockquote>
<p>在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-on:keydown=&quot;ke&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            msg:&quot;事件处理&quot;,</span><br><span class="line">            counter:0</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            ke:function(e)&#123;</span><br><span class="line">                if(e.keyCode == 13)&#123;</span><br><span class="line">                    this.msg = e.target.value;</span><br><span class="line">                    e.target.value = &quot;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>enter</code>(回车)</li>
<li><code>tab</code>（tab切换）</li>
<li><code>delete</code> (捕获 “删除” 和 “退格” 键)</li>
<li><code>esc</code>（esc键）</li>
<li><code>space</code>（退档键）</li>
<li><code>up</code>（上键）</li>
<li><code>down</code>（下键）</li>
<li><code>left</code>（左键）</li>
<li><code>right</code>（右键）</li>
</ul>
<blockquote>
<p>我们也可以通过全局<code>config.keyCodes</code> 对象自定义键值修饰符别名</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/15/Vue/vue-%E4%BA%8B%E4%BB%B6/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-jQurty总结">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/12/html+css+js+ts/jQuery%E6%80%BB%E7%BB%93/">jQurty总结</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-12
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/javascript/" class="cube-excerpt-tag-link">#javascript</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h4 id="第一节-jQuery初步认知"><a href="#第一节-jQuery初步认知" class="headerlink" title="第一节 jQuery初步认知"></a>第一节 jQuery初步认知</h4><hr>
<h5 id="jQuery概述"><a href="#jQuery概述" class="headerlink" title="jQuery概述"></a>jQuery概述</h5><hr>
<ul>
<li><p><strong><code>JQuery</code>概念</strong></p>
<ul>
<li><p>&#96;&#96;&#96;<br>javascript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  概念</span><br><span class="line"></span><br><span class="line">  - 基于`Js`语言的`API`和语法组织逻辑，通过内置`window`和`document`对象，来操作内存中的`DOM`元素</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  JQuery</span><br></pre></td></tr></table></figure>

<p>概念</p>
<ul>
<li>基于<code>javascript</code>的，同上，提高了代码的效率</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>jQuery</code>是什么:</strong></p>
<ul>
<li>是一个<code>javascript</code>代码仓库，我们称之为<code>javascript</code>框架。</li>
<li>是一个快速的简洁的<code>javascript</code>框架，可以简化查询<code>DOM</code>对象、处理事件、制作动画、处理<code>Ajax</code>交互过程。</li>
<li>它可以帮我们做什么(有什么优势)<ul>
<li>轻量级、体积小，使用灵巧(只需引入一个<code>js</code>文件)</li>
<li>强大的选择器</li>
<li>出色的<code>DOM</code>操作的封装</li>
<li>出色的浏览器兼容性</li>
<li>可靠的事件处理机制</li>
<li>完善的<code>Ajax</code></li>
<li>链式操作、隐式迭代</li>
<li>方便的选择页面元素(模仿<code>CSS</code>选择器更精确、灵活)</li>
<li>动态更改页面样式&#x2F;页面内容(操作<code>DOM</code>，动态添加、移除样式)</li>
<li>控制响应事件(动态添加响应事件)</li>
<li>提供基本网页特效(提供已封装的网页特效方法)</li>
<li>快速实现通信(<code>ajax</code>)</li>
<li>易扩展、插件丰富</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>如何引入<code>JQuery</code>包</strong></p>
<ul>
<li>引入本地的<code>JQuery</code></li>
<li>引入<code>Google</code>在线提供的库文件（稳定可靠高速）</li>
<li>使用<code>Google</code>提供的<code>API</code>导入 &#96;&#96;</li>
<li>写第一个<code>JQUery</code>案例<ul>
<li>解释:在<code>JQuery</code>库中，<code>$</code>是<code>JQuery</code>的别名，<code>$()</code>等效于就<code>jQuery()</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=“text/javascript”&gt;</span><br><span class="line">	$(function()&#123;</span><br><span class="line">		alert(“jQuery 你好!”);</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>讲解<code>$(function()&#123;&#125;)</code>;</strong></p>
<ul>
<li><p><code>$</code>是<code>jQuery</code>别名。如<code>$()</code>也可<code>jQuery()</code>这样写,相当于页面初始化函数，当页面加载完毕，会执行<code>jQuery()</code>。</p>
</li>
<li><p>希望在做所有事情之前，<code>JQuery</code>操作<code>DOM</code>文档。必须确保在<code>DOM</code>载入完毕后开始执行，应该用<code>ready</code>事件做处理<code>HTML</code>文档的开始</p>
</li>
<li><pre><code>$(document).ready(function()&#123;&#125;)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    - 类似于`js`的`window.onload`事件函数，但是`ready`事件要先于`onload`事件执行</span><br><span class="line">    - `window.onload = function()&#123;&#125;`;</span><br><span class="line"></span><br><span class="line">  - 为方便开发，`jQuery`简化这样的方法，直接用`$()`表示</span><br><span class="line"></span><br><span class="line">  - `JQuery`的`ready`事件不等于`Js`的`load`：</span><br><span class="line"></span><br><span class="line">    - 执行时机不同：`load`需要等外部图片和视频等全部加载才执行。`ready`是`DOM`绘制完毕后执行，先与外部文件</span><br><span class="line">    - 用法不同：`load`只可写一次，`ready`可以多次</span><br><span class="line"></span><br><span class="line">- **`window.onload`与`$(document).ready()`对比**</span><br><span class="line"></span><br><span class="line">|          | window.onload                            | $(document).ready()                                          |</span><br><span class="line">| :------- | :--------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">| 执行时机 | 必须等网页中所有内容加载完后(图片)才执行 | 网页中的`DOM`结构绘制完后就执行,可能`DOM`元素相关的东西并没有加载完 |</span><br><span class="line">| 编写个数 | 不能同时执行多个                         | 能同时执行多个                                               |</span><br><span class="line">| 简化写法 | 无                                       | `$(document).ready(function()&#123; //.. &#125;);`  推荐写法：`$(function()&#123; &#125;);` |</span><br><span class="line"></span><br><span class="line">- **`jQuery`有哪些功能(`API`)**：</span><br><span class="line">  - 选择器</span><br><span class="line">  - 过滤器</span><br><span class="line">  - 事件</span><br><span class="line">  - 效果</span><br><span class="line">  - `ajax`</span><br><span class="line">- **简单的`JQuery`选择器**：</span><br><span class="line">  - `JQuery`基本选择器（`ID`选择器，标签选择器，类选择器，通配选择器和组选择器`5`种）</span><br><span class="line">  - `ID`选择器：`document.getElementById(id)`与`$(&quot;#id&quot;)`对比(改变文字大小)—`id`唯一，返回单个元素</span><br><span class="line">  - 标签选择器：`document.getElementsByTagName(tagName)`与`$(&quot;tagname&quot;)`对比—多个标签，返回数组</span><br><span class="line">  - 类选择器:`$(&quot;.className&quot;)`–多个`classname`（改变背景图片）</span><br><span class="line">  - 通配选择器：`document.getElementsByTagName(&quot;*&quot;)`与`$(&quot;*&quot;)`对比—指范围内的所有标签元素</span><br><span class="line">  - 组选择器：`$(&quot;seletor1,seletor2,seletor3&quot;)`—-无数量限制，用逗号分割</span><br><span class="line"></span><br><span class="line">##### 初步了解`JQuery`</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- `JQuery`是什么</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    javascript</span><br></pre></td></tr></table></figure>

用来干什么的：

- 操作`DOM`对象
- 动态操作样式`css`
- 数据访问
- 控制响应事件等
</code></pre>
</li>
<li><p><code>jQuery</code>作用一样，只是更加快速简洁</p>
</li>
</ul>
</li>
<li><p><strong>如何引用<code>JQuery</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">写第一个JQUery案例</span><br><span class="line">&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=“text/javascript”&gt;</span><br><span class="line">	$(function()&#123;</span><br><span class="line">		alert(“jQuery 你好!”);</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>$()讲解</code></strong></p>
<ul>
<li><code>$</code>在<code>JQuery</code>库中，<code>$</code>是<code>JQuery</code>的别名，<code>$()</code>等效于就<code>jQuery()</code>.</li>
<li><code>$()</code>是<code>JQuery</code>方法,赞可看作是<code>JQuery</code>的选择器，与<code>css</code>选择器相似（可做对比）</li>
<li><code>var jQuery==$ =function()&#123;&#125;</code> <code>$()</code>本质就是一个函数也就是 <code>jQuery</code>的核心函数</li>
<li>只要是<code>jQuery</code>的对象都这样变量加上一个<code>符号$</code>方便识别：<code>var $div = $(&quot;#&quot;)</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function　$(id)&#123;</span><br><span class="line">		return document.getElementById(id);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>$()</code>和<code>document</code>是相等的吗</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;a&quot; class=&quot;aa&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;b&quot; class=&quot;aa&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;c&quot; class=&quot;aa&quot;&gt;&lt;/div&gt;</span><br><span class="line">alert(document.getElementById(&quot;id&quot;) == $(&quot;#aa&quot;));//返回结果为false</span><br><span class="line">alert(document.getElementById(&quot;id&quot;) == $(&quot;#aa&quot;).get(0));//返回true</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>代理对象<code>$()</code></strong></p>
<ul>
<li><p><code>jQuery</code>中返回的是代理对象本身</p>
</li>
<li><p><code>jQuery</code>的核心原理是通过选择器找到对应的代理对象</p>
</li>
<li><p><code>jQuery</code>全都是通过方法操作</p>
</li>
<li><p>样式选择器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.className&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$(&quot;.aa&quot;).css(&quot;color&quot;,&quot;green&quot;);</code></li>
</ul>
</li>
<li><p>id选择器(“”)</p>
<ul>
<li><code>$(&quot;#a&quot;).css(&quot;background-color&quot;,&quot;#ff0066&quot;);</code></li>
</ul>
</li>
<li><p>标签选择器</p>
<ul>
<li><code>$(&quot;p&quot;).css(&quot;color&quot;,&quot;#cc3366&quot;);</code></li>
</ul>
</li>
<li><p>组选择器</p>
<ul>
<li><code>$(&quot;#b ul li&quot;).size();</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对象转换(<code>$(element)</code>)</strong></p>
<ul>
<li>原生<code>dom</code>对象和<code>jquery</code>代理对象的相互转换</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(传入的原生对象);</span><br><span class="line">//原生对象转化成jQuery对象</span><br><span class="line">var nav = document.getElementById(&quot;nav&quot;);</span><br><span class="line">var $nav = $(nav);</span><br><span class="line">alert($nav.get(0) == nav);//true</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>检索范围的限制（<code>$(&#39;字符串&#39;,element)</code>）</strong></p>
<ul>
<li><strong>总结：三种写法对比：</strong><ul>
<li>方式一：不推荐 搜索速度最慢<ul>
<li><code>$(&quot;#nav&quot;).css();</code></li>
<li><code>$(&quot;#nav li&quot;).css();</code></li>
</ul>
</li>
<li>方式二：搜索速度最快 链式操作<ul>
<li><code>$(&quot;#nav&quot;).css().children().css();</code></li>
</ul>
</li>
<li>方式三：也常用 速度第二快<ul>
<li><code>var $nav = $(&quot;#nav&quot;).css()</code>;</li>
<li><code>$(&quot;li&quot;,$nav).css()</code>; <code>$nav</code>限制了搜索范围 速度快</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>总结： <code>$()</code> <code>jquery</code>核心方法的作用和使用场景</strong></p>
<ul>
<li>如果是一个字符串参数并且没有标签对（选择器）<code>$(ul.nav&quot;)</code></li>
<li>如果是一个字符串参数并且有标签对（创建<code>html</code>标签）<code>$(&quot;&quot;)</code> –最终加到<code>DOM</code>树中 <code>$xx.append(&quot;&quot;)</code>;</li>
<li>如果是传入一个<code>element dom</code>对象，直接包装为<code>proxy</code>对象返回 <code>$(DOM对象)</code></li>
<li>如果第一个参数是字符串，第二个是<code>element</code> <code>dom</code>对象的话，那么就是在<code>element</code>这个<code>dom</code>对象里面寻找选择器对应的元素并且代理 <code>$(&quot;li&quot;,$DOM对象)</code></li>
</ul>
</li>
<li><p><strong>代理模式以及代理内存结构</strong></p>
</li>
</ul>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/jquery2.png" alt="代理内存结构1"></p>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/jquery3.png" alt="代理内存结构2"></p>
<h4 id="第二节-选择器"><a href="#第二节-选择器" class="headerlink" title="第二节 选择器"></a>第二节 选择器</h4><hr>
<ul>
<li><strong>来回顾一下<code>CSS</code>常用的选择器</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">语法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">标签选择器</td>
<td align="left"><code>E&#123;css规则&#125;</code></td>
<td align="left">以文档元素作为选择符</td>
</tr>
<tr>
<td align="left"><code>ID</code>选择器</td>
<td align="left"><code>#ID&#123;css规则&#125;</code></td>
<td align="left"><code>ID</code>作为选择符</td>
</tr>
<tr>
<td align="left">类选择器</td>
<td align="left"><code>E.className&#123;css规则&#125;</code></td>
<td align="left"><code>class</code>作为选择符</td>
</tr>
<tr>
<td align="left">群组选择器</td>
<td align="left"><code>E1,E2,E3&#123;css规则&#125;</code></td>
<td align="left">多个选择符应用同样的样式</td>
</tr>
<tr>
<td align="left">后代选择器</td>
<td align="left"><code>E F&#123;css规则&#125;</code></td>
<td align="left">元素<code>E</code>的任意后代元素<code>F</code></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>选择器引擎规则(<code>$(&#39;字符串&#39;)</code>)</strong></p>
<ul>
<li>&#96;&#96;&#96;<br>css<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    选择器的规则</span><br><span class="line"></span><br><span class="line">    - 标签选择器</span><br><span class="line">    - `id`选择器</span><br><span class="line">    - 类选择器</span><br><span class="line">    - 混合选择器</span><br><span class="line"></span><br><span class="line">  - `css3`的选择器规则</span><br><span class="line"></span><br><span class="line">  - 状态和伪类（`:even` `:odd` `:first` `:last` `:eq(index)`）</span><br><span class="line"></span><br><span class="line">  - 属性（`[attr=value]`）</span><br><span class="line"></span><br><span class="line">- 层级选择器:通过`DOM`的嵌套关系匹配元素</span><br><span class="line">  - `jQuery`层级选择器—-包含选择器、子选择器、相邻选择器、兄弟选择器4种</span><br><span class="line">  - a.包含选择器：`$(&quot;a b&quot;)`在给定的祖先元素下匹配所有后代元素。(不受层级限制)</span><br><span class="line">  - b.子选择器：`$(&quot;parent &gt; child&quot;)`在给定的父元素下匹配所有子元素。</span><br><span class="line">  - c.相邻选择器：`$(&quot;prev + next&quot;)` 匹配所有紧接在`prev`元素后的`next`元素。</span><br><span class="line">  - d.兄弟选择器：`$(&quot;prev ~ siblings&quot;)` 匹配prev元素之后的所有`sibling`元素。</span><br><span class="line"></span><br><span class="line">##### 过滤选择器</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **基本过滤选择**</span><br><span class="line"></span><br><span class="line">| 选择器       | 说明                           | 返回     |</span><br><span class="line">| :----------- | :----------------------------- | :------- |</span><br><span class="line">| `:first`     | 匹配找到的第1个元素            | 单个元素 |</span><br><span class="line">| `:last`      | 匹配找到的最后一个元素         | 单个元素 |</span><br><span class="line">| `:eq`        | 匹配一个给定索引值的元素       | 单个元素 |</span><br><span class="line">| `:even`      | 匹配所有索引值为偶数的元素     | 集合元素 |</span><br><span class="line">| `: odd`      | 匹配所有索引值为奇数的元素     | 集合元素 |</span><br><span class="line">| `:gt(index)` | 匹配所有大于给定索引值的元素   | 集合元素 |</span><br><span class="line">| `:lt(index)` | 匹配所有小于给定索引值的元素   | 集合元素 |</span><br><span class="line">| `:not`       | 去除所有与给定选择器匹配的元素 | 集合元素 |</span><br><span class="line">| `:animated`  | 选取当前正在执行动画的所有元素 | 集合元素 |</span><br><span class="line">| `focus`      | 选取当前正在获取焦点的元素     | 集合元素 |</span><br><span class="line"></span><br><span class="line">- **内容过滤选择器**</span><br><span class="line"></span><br><span class="line">| 选择器            | 描述                             | 返回     |</span><br><span class="line">| :---------------- | :------------------------------- | :------- |</span><br><span class="line">| `:contains(text)` | 选取含有文本内容为text的元素     | 集合元素 |</span><br><span class="line">| `:empty`          | 选取不包含子元素获取文本的空元素 | 集合元素 |</span><br><span class="line">| `:has(selector)`  | 选择含有选择器所匹配的元素的元素 | 集合元素 |</span><br><span class="line">| `:parent`         | 选取含有子元素或者文本的元素     | 集合元素 |</span><br><span class="line"></span><br><span class="line">- **可见过滤选择器**</span><br><span class="line"></span><br><span class="line">| 选择器     | 描述                 | 返回     |</span><br><span class="line">| :--------- | :------------------- | :------- |</span><br><span class="line">| `:hidden`  | 选择所有不可见的元素 | 集合元素 |</span><br><span class="line">| `:visible` | 选取所有可见的元素   | 集合元素 |</span><br><span class="line"></span><br><span class="line">- **属性过滤选择器**</span><br><span class="line"></span><br><span class="line">| 选择器              | 说明                            | 返回     |</span><br><span class="line">| :------------------ | :------------------------------ | :------- |</span><br><span class="line">| `[attribute]`       | 选取拥有此属性的元素            | 集合元素 |</span><br><span class="line">| `[attribute=value]` | 选取属性值为`value`值的元素     | 集合元素 |</span><br><span class="line">| `[attribue^=value]` | 选取属性的值以`value`开始的元素 | 集合元素 |</span><br><span class="line">| `[attribue$=value]` | 选取属性的值以`value`结束的元素 | 集合元素 |</span><br><span class="line"></span><br><span class="line">- **子元素过滤选择器**</span><br><span class="line"></span><br><span class="line">| 选择器                       | 说明                                                         | 返回     |</span><br><span class="line">| :--------------------------- | :----------------------------------------------------------- | :------- |</span><br><span class="line">| `:nth-child(index/even/odd)` | 选取每个父元素下的第index个子元素或者奇偶元素（`index`从`1`算起） | 集合元素 |</span><br><span class="line">| `:first-child`               | 选取每个元素的第一个子元素                                   | 集合元素 |</span><br><span class="line">| `:last-child`                | 选取每个元素的最后一个子元素                                 | 集合元素 |</span><br><span class="line"></span><br><span class="line">- `:nth-child()`选择器是很常用的子元素过滤选择器，如下</span><br><span class="line">  - `:nth-child(even)`选择每个父元素下的索引值是偶数的元素</span><br><span class="line">  - `:nth-child(odd)`选择每个父元素下的索引值是奇数的元素</span><br><span class="line">  - `:nth-child(2)`选择每个父元素下的索引值是`2`的元素</span><br><span class="line">  - `:nth-child(3n)`选择每个父元素下的索引值是3的倍数的元素 (`n`从`1`开始)</span><br><span class="line">- **表单对象属性过滤选择器**</span><br><span class="line"></span><br><span class="line">| 选择器      | 说明                                   | 返回     |</span><br><span class="line">| :---------- | :------------------------------------- | :------- |</span><br><span class="line">| `:enabled`  | 选取所有可用元素                       | 集合元素 |</span><br><span class="line">| `:disabled` | 选取所有不可用元素                     | 集合元素 |</span><br><span class="line">| `:checked`  | 选取所有被选中的元素（单选框、复选框） | 集合元素 |</span><br><span class="line">| `:selected` | 选取所有被选中的元素（下拉列表）       | 集合元素 |</span><br><span class="line"></span><br><span class="line">- **表单选择器**</span><br><span class="line"></span><br><span class="line">| 选择器      | 说明                                             |</span><br><span class="line">| :---------- | :----------------------------------------------- |</span><br><span class="line">| `:input`    | 选取所有`input` `textarea` `select` `button`元素 |</span><br><span class="line">| `:text`     | 选取所有单行文本框                               |</span><br><span class="line">| `:password` | 选取所有密码框                                   |</span><br><span class="line">| `:radio`    | 选取所有单选框                                   |</span><br><span class="line">| `:checkbox` | 选取所有多选框                                   |</span><br><span class="line">| `:submit`   | 选取所有的提交按钮                               |</span><br><span class="line">| `:image`    | 选取所有的图像按钮                               |</span><br><span class="line">| `:reset`    | 选取所有的重置按钮                               |</span><br><span class="line">| `:button`   | 选取所有的按钮                                   |</span><br><span class="line">| `:file`     | 选取所有的上传域                                 |</span><br><span class="line">| `:hidden`   | 选取所有的不可见元素                             |</span><br><span class="line"></span><br><span class="line">- **特定位置选择器**</span><br><span class="line">  - `:first`</span><br><span class="line">  - `:last`</span><br><span class="line">  - `:eq(index)`</span><br><span class="line">- **指定范围选择器**</span><br><span class="line">  - `:even`</span><br><span class="line">  - `:odd`</span><br><span class="line">  - `:gt(index)`</span><br><span class="line">  - `:lt(index)`</span><br><span class="line">- **排除选择器**</span><br><span class="line">  - `:not` 非</span><br><span class="line"></span><br><span class="line">#### 第三节 选择器优化</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 使用合适的选择器表达式可以提高性能、增强语义并简化逻辑。常用的选择器中，`ID`选择器速度最快，其次是类型选择器。</span><br><span class="line">  - a. 多用`ID`选择器</span><br><span class="line">  - b. 少直接使用`class`选择器</span><br><span class="line">  - c. 多用父子关系，少用嵌套关系</span><br><span class="line">  - d. 缓存`jQuery`对象</span><br><span class="line">- **使用过滤器**</span><br><span class="line">  - `jQuery`提供了`2`种选择文档元素的方式：选择器和过滤器</span><br><span class="line">  - a. 类过虑器：根据元素的类属性来进行过滤操作。</span><br><span class="line">    - `hasClass(className)`：判断当前`jQuery`对象中的某个元素是否包含指定类名，包含返回`true`，不包含返回`false`</span><br><span class="line">  - b. 下标过滤器：精确选出指定下标元素</span><br><span class="line">    - `eq(index)`：获取第`N`个元素。`index`是整数值，下标从`0`开始</span><br><span class="line">  - c. 表达式过滤器</span><br><span class="line">    - `filter(expr)/(fn)`：筛选出与指定表达式/函数匹配的元素集合。</span><br><span class="line">    - 功能最强大的表达式过滤器，可接收函数参数，也可以是简单的选择器表达式</span><br><span class="line">  - d. 映射 `map(callback)`：将一组元素转换成其他数组</span><br><span class="line">  - e. 清洗 `not(expr)`：删除与指定表达式匹配的元素</span><br><span class="line">  - f. 截取 `slice(start,end)`：选取一个匹配的子集</span><br><span class="line">- **查找**</span><br><span class="line">  - 向下查找后代元素</span><br><span class="line">    - `children()`:取得所有元素的所有子元素集合（子元素）</span><br><span class="line">    - `find()`:搜索所有与指定表达式匹配的元素(所有后代元素中查找)</span><br><span class="line">  - 查找兄弟元素 `siblings()`查找当前元素的兄弟</span><br><span class="line"></span><br><span class="line">#### 第四节 代理对象属性和样式操作</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **代理对象属性和样式操作**</span><br><span class="line">  - `attr`</span><br><span class="line">  - `prop`(一般属性值是`boolean`的值或者不用设置属性值，一般使用)</span><br><span class="line">  - `css`(最好不用，一般我用来做测试)</span><br><span class="line">  - `addClass` / `removeClass`</span><br><span class="line">- 操作原生`DOM`的时候用的方式：一次只能操作一个</span><br><span class="line">  - 操作属性：`setAttribute` / `getAttribute`</span><br><span class="line">  - 操作样式：`style.xx = value`</span><br><span class="line">  - 操作类样式：`className=&#x27;&#x27;`</span><br><span class="line">  - 获取`DOM`的子元素`children`属性</span><br><span class="line">  - `DOM`里面添加一个子元素`appendChild()`</span><br><span class="line">- 操作`jQuery`代理对象的时候：批量操作`DOM`对象(全都是通过方法操作)</span><br><span class="line">- 操作属性：`attr()`、`prop()`</span><br><span class="line">  - `attr`和`prop`区别：如果属性的值是布尔类型的值 用`prop`操作 反之`attr`</span><br><span class="line">- 操作样式：`css()`</span><br><span class="line">- 操作类样式：`addClass()` `removeClass()`</span><br><span class="line">- 操作`DOM`子元素：`children()`</span><br><span class="line">- 添加子元素：`append()`</span><br><span class="line"></span><br><span class="line">#### 第五节 jQuery中DOM操作</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- `DOM`是一种与浏览器、平台|语言无关的接口，使用该接口可以轻松的访问 页面中的所有的标准组件</span><br><span class="line"></span><br><span class="line">- **`DOM`操作的分类**</span><br><span class="line"></span><br><span class="line">  - **`DOM Core`**</span><br><span class="line"></span><br><span class="line">    - `DOM core`并不专属于`JavaScript`，任何支持`DOM`的程序都可以使用</span><br><span class="line">    - `JavaScript` 中的`getElementByID()` `getElementsByTagName()` `getAttribute()` `setAttribute()`等方法都是`DOM Core`的组成部分</span><br><span class="line"></span><br><span class="line">  - **`HTML-DOM`**</span><br><span class="line"></span><br><span class="line">    - `HTML -DOM`的出现比`DOM-Core`还要早，它提供一些更简明的标志来描述`HTML`元素的属性</span><br><span class="line"></span><br><span class="line">    - 比如：使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  HTML-DOM  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">来获取某元素的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  src  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      属性的方法</span><br><span class="line"></span><br><span class="line">      - `element.src`</span><br><span class="line"></span><br><span class="line">  - **`CSS-DOM`**</span><br><span class="line"></span><br><span class="line">    - 针对`CSS`的操作。在`JavaScript`中，主要用于获取和设置`style`对象的各种属性，通过改变`style`对象的属性，使网页呈现不同的效果</span><br><span class="line"></span><br><span class="line">- **查找节点**</span><br><span class="line"></span><br><span class="line">  - 查找属性节点 `attr()` 可以获取各属性的值</span><br><span class="line"></span><br><span class="line">- 创建节点</span><br><span class="line"></span><br><span class="line">  - `$(html)`：根据传递的标记字符串，创建`DOM`对象</span><br><span class="line"></span><br><span class="line">- **插入节点**</span><br><span class="line"></span><br><span class="line">| 方法             | 说明                             |</span><br><span class="line">| :--------------- | :------------------------------- |</span><br><span class="line">| `append()`       | 向每个匹配元素内部追加内容       |</span><br><span class="line">| `appendTo()`     | 颠倒`append()`的操作             |</span><br><span class="line">| `prepend()`      | 向每个匹配元素的内容内部前置内容 |</span><br><span class="line">| `prependTo()`    | 颠倒`prepend()`的操作            |</span><br><span class="line">| `after()`        | 向每个匹配元素之后插入内容       |</span><br><span class="line">| `insertAfter()`  | 颠倒`after()`的操作              |</span><br><span class="line">| `before()`       | 在每个匹配元素之前插入内容       |</span><br><span class="line">| `insertBefore()` | 颠倒`before()`的操作             |</span><br><span class="line"></span><br><span class="line">- **删除节点**</span><br><span class="line"></span><br><span class="line">  - jQuery提供了三种删除节点的方法 `remove()` `detach()` `empty()`</span><br><span class="line">  - `remove()方法`</span><br><span class="line">    - 当某个节点用此方法删除后，该节点所包含的所有后代节点将同时被删除，用`remove()`方法删除后，还是可以继续使用删除后的引用</span><br><span class="line">  - `detach()`</span><br><span class="line">    - 和`remove()`方法一样，也是从`DOM`中去掉所有匹配的元素，与`remove()`不同的是，所有绑定的事件、附加的数据等，都会被保留下来</span><br><span class="line">  - `empty()`</span><br><span class="line">    - `empty()`方法并不是删除节点，而是清空节点，它能清空元素中所有后代节点</span><br><span class="line"></span><br><span class="line">- **复制节点**</span><br><span class="line"></span><br><span class="line">  - 使用`clone()`方法来完成</span><br><span class="line">  - 在`clone()`方法中传递一个参数`true`，同时复制元素中所绑定的事件</span><br><span class="line"></span><br><span class="line">- **替换节点**</span><br><span class="line"></span><br><span class="line">  - `jQuery`提供相应的方法 `replaceWidth()`</span><br><span class="line"></span><br><span class="line">- **样式操作**</span><br><span class="line"></span><br><span class="line">  - 获取样式和设置样式 `attr()`</span><br><span class="line">  - 追加样式 `addClass()`</span><br><span class="line">  - 移除样式 `removeClass()`</span><br><span class="line">  - 切换样式</span><br><span class="line">    - `toggle()`方法只要是控制行为上的重复切换（如果元素是显示的，则隐藏；如果元素原来是隐藏的，则显示）</span><br><span class="line">    - `toggleClass()`方法控制样式上的重复切换（如何类名存在，则删除它，如果类名不存在，则添加它）</span><br><span class="line">  - 判断是否含有某个样式</span><br><span class="line">    - `hasClass()`可以用来判断元素是否含有某个`class`,如有返回`true` 该方法等价于`is()`</span><br><span class="line"></span><br><span class="line">- **设置和获取HTML、文本和值**</span><br><span class="line"></span><br><span class="line">  - `html()`</span><br><span class="line"></span><br><span class="line">    - 此方法类似`JavaScript`中`innerHTML`属性，可以用来读取和设置某个元素中的`HTML`内容</span><br><span class="line"></span><br><span class="line">  - `text()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 此方法类型`JavaScript`中`innerHTML`，用来读取和设置某个元素中的文本内容</span><br><span class="line"></span><br><span class="line">  - `val()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 此方法类似`JavaScript`中的`value`属性，用来设置获取元素的值。无论是文本框、下拉列表还是单选框，都可以返回元素的值，如果元素多选，返回一个包含所有选择的值的数组</span><br><span class="line"></span><br><span class="line">- **遍历节点**</span><br><span class="line"></span><br><span class="line">  - `children()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 该方法用来取得匹配元素的子元素集合</span><br><span class="line">    - `childre()`方法只考虑子元素而不考虑其他后代元素</span><br><span class="line"></span><br><span class="line">  - `next()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 该方法用于取得匹配元素后面紧邻的同辈元素</span><br><span class="line"></span><br><span class="line">  - `prev()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 用于匹配元素前面紧邻的同辈元素</span><br><span class="line"></span><br><span class="line">  - `siblings()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 用于匹配元素前后所有的同辈元素</span><br><span class="line"></span><br><span class="line">  - `parent()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 获得集合中每个 元素的父级元素</span><br><span class="line"></span><br><span class="line">  - `parents()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 获得集合中每个元素的祖先元素</span><br><span class="line"></span><br><span class="line">##### CSS DOM操作</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- `CSS DOM`技术简单的来说就是读取和设置`style`对象的各种属性</span><br><span class="line"></span><br><span class="line">- 用`css()`方法获取元素的样式属性，可以同时设置多个样式属性</span><br><span class="line"></span><br><span class="line">- `CSS DOM`中关于元素定位有几个常用的方法</span><br><span class="line"></span><br><span class="line">  - `offset()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 它的作用是获取元素在当前视窗的相对偏移其中返回的对象包含两个属性，即`top`和`left`，他只对可见元素有效</span><br><span class="line"></span><br><span class="line">  - `position()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 获取相对于最近的一个`position()`样式属性设置为`relative`或者`absolute`的祖父节点的相对偏移，与`offset()`一样，他返回的对象也包括两个属性，即`top`和`left`</span><br><span class="line"></span><br><span class="line">  - `scrollTop()`</span><br><span class="line"></span><br><span class="line">    方法和</span><br><span class="line"></span><br><span class="line">    `scrollLeft`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 这两个方法的作用分别是获取元素的滚动条距顶端的距离和距左侧的距离</span><br><span class="line"></span><br><span class="line">  - **一张图总结以上的位置关系(项目中很常用-必须要弄清楚)**</span><br><span class="line"></span><br><span class="line">![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery4.jpg)</span><br><span class="line">![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery5.jpg)</span><br><span class="line">![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery6.jpg)</span><br><span class="line">![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery7.jpg)</span><br><span class="line">![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery7.jpg)</span><br><span class="line"></span><br><span class="line">#### 第六节 jQuery动画</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">##### 回顾上节</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 操作DOM</span><br><span class="line">  - a.什么是`DOM`：`Document Object Model`缩写，文档对象模型</span><br><span class="line">  - b.理解页面的树形结构</span><br><span class="line">  - c.什么是节点：是DOM结构中最小单元，包括元素、属性、文本、文档等。</span><br><span class="line"></span><br><span class="line">###### 一、创建节点</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 1.创建元素</span><br><span class="line">  - 语法：`document.createElement(name)`;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>var div &#x3D; document.createElement(“div”);<br>document.body.appendChild(div);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `$(html)`：根据传递的标记字符串，创建DOM对象</span><br><span class="line">- 2.创建文本</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var div &#x3D; document.createElement(“div”);<br>var txt &#x3D; document.createTextNode(“DOM”);<br>div.appendChild(txt);<br>document.body.appendChild(div);</p>
<p>var $div &#x3D; &#x3D; $(“<div>DOM</div>“);<br>$(body).append($div);<br>​&#96;&#96;&#96;		</p>
<ul>
<li>3.设置属性<ul>
<li>语法：<code>e.setAttrbute(name,value)</code></li>
</ul>
</li>
</ul>
<p>​&#96;&#96;&#96;javascript<br>var div &#x3D; document.createElement(“div”);<br>var txt &#x3D; document.createTextNode(“DOM”);<br>div.appendChild(txt);<br>document.body.appendChild(div);<br>div.setAttribute(“title”,”盒子”);</p>
<p>var $div &#x3D; &#x3D; $(“<div title='盒子'>DOM</div>“);<br>$(body).append($div);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### 二、插入内容</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 内部插入</span><br><span class="line">  - 向元素最后面插入节点：</span><br><span class="line">    - `append()`:向每个匹配的元素内部追加内容</span><br><span class="line">    - `appendTo()`:把所有匹配的元素追加到指定元素集合中，`$(&quot;A&quot;).append(&quot;B&quot;)`等效 `$(&quot;B&quot;).appendTo(&quot;A&quot;)`</span><br><span class="line">  - 向元素最前面插入节点：</span><br><span class="line">    - `prepend（）`：把每个匹配的元素内部前置内容</span><br><span class="line">    - `prependTo（）`：把所有匹配的元素前置到另一个指定的元素集合中,`$(&quot;A&quot;).prepend(&quot;B&quot;)` 等效 `$(&quot;B&quot;).prependTo(&quot;A&quot;)`</span><br><span class="line">- 外部插入</span><br><span class="line">  - `after()`:在每个匹配的元素之后插入内容</span><br><span class="line">  - `before()`：在每个匹配想元素之前插入内容</span><br><span class="line">  - `insertAfter()`：将所有匹配的元素插入到另一个指定的元素集合后面，`$A.insert($B)` 等效`$B.insertAfter($A);`</span><br><span class="line">  - `insertBefore()`：将所有匹配的元素插入到另一个指定的元素集合前面 `$A.before($B)` 等效 `$B.insertBefore($A)`;</span><br><span class="line"></span><br><span class="line">###### 三、删除内容</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 移除</span><br><span class="line">  - `remove()`:从`DOM`中删除所有匹配元素</span><br><span class="line">- 清空</span><br><span class="line">  - `empty()`:删除匹配的元素集合中所有子节点内容</span><br><span class="line"></span><br><span class="line">###### 四、克隆内容：创建指定节点副本</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  clone()</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：若<code>clone（true）</code>则是包括克隆元素的属性，事件等</li>
</ul>
<h6 id="五、替换内容"><a href="#五、替换内容" class="headerlink" title="五、替换内容"></a>五、替换内容</h6><hr>
<ul>
<li><p><code>replaceWith()</code>:将所有匹配的元素替换成指定的元素</p>
</li>
<li><p><code>replaceAll()</code>:用匹配的元素替换掉指定元素</p>
</li>
<li><p>注意：两者效果一致，只是语法不同 <code>$A.replaceAll($B)</code>等效于 <code>$B.replaceWhith($A)</code>;</p>
</li>
</ul>
<h5 id="本节新知识"><a href="#本节新知识" class="headerlink" title="本节新知识"></a>本节新知识</h5><hr>
<ul>
<li><code>JavaScrip</code>t语言本身不支持动画设计，必须通过改变<code>CSS</code>来实现动画效果</li>
</ul>
<p><strong>显隐动画</strong></p>
<ul>
<li><p><code>show()</code>:显示 <code>hide()</code>:隐藏</p>
<ul>
<li><p>原理：<code>hide()</code>通过改变元素的高度宽度和不透明度，直到这三个属性值到<code>0</code></p>
</li>
<li><p><code>show()</code>从上到下增加元素的高度，从左到右增加元素宽度，从<code>0</code>到<code>1</code>增加透明度，直至内容完全可见</p>
</li>
<li><p>参数：</p>
<ul>
<li>&#96;&#96;&#96;<br>show(speed,callback)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - `speed`: 字符串或数字，表示动画将运行多久（`slow=0.6`/`normal=0.4`/`fast=0.2`）</span><br><span class="line">      - `callback`: 动画完成时执行的方法</span><br><span class="line"></span><br><span class="line">- 显示和隐藏式一对密不可分的动画形式</span><br><span class="line"></span><br><span class="line">- **显隐切换**</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    toggle()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>:切换元素的可见状态</p>
<ul>
<li><p>原理：匹配元素的宽度、高度以及不透明度，同时进行动画，隐藏动画后将<code>display</code>设置为<code>none</code></p>
</li>
<li><p>参数：</p>
<ul>
<li><p><code>toggle(speed)</code></p>
</li>
<li><p><code>toggle(speed,callback)</code></p>
</li>
<li><p>&#96;&#96;&#96;<br>toggle(boolean)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        - `speed`: 字符串或数字，表示动画将运行多久（`slow=0.6`/`normal=0.4`/`fast=0.2`）</span><br><span class="line">        - `easing`： 使用哪个缓冲函数来过渡的字符串(`linear`/`swing`)</span><br><span class="line">        - `callback`： 动画完成时执行的方法</span><br><span class="line">        - `boolean`:`true`为显示 `false`为隐藏</span><br><span class="line"></span><br><span class="line">**滑动**</span><br><span class="line"></span><br><span class="line">- **显隐滑动效果**</span><br><span class="line">  - `slideDown()`:滑动隐藏</span><br><span class="line">  - `slidUp()`:滑动显示</span><br><span class="line">  - 参数:</span><br><span class="line">    - `slideDown(speed,callback)`</span><br><span class="line">    - `slidUp(speed,callback)`</span><br><span class="line">- **显隐切换滑动**</span><br><span class="line">  - `slideToggle()`:显隐滑动切换</span><br><span class="line">  - 参数:</span><br><span class="line">    - `slidUp(speed,callback)`</span><br><span class="line"></span><br><span class="line">**渐变：通过改变不透明度**</span><br><span class="line"></span><br><span class="line">- **淡入淡出**</span><br><span class="line">  - `fadeIn()`</span><br><span class="line">  - `fadeOut()`</span><br><span class="line">  - 参数：</span><br><span class="line">    - `fadeIn(speed,callback)`</span><br><span class="line">    - `fadeOut(speed,callback)`</span><br><span class="line">- **设置淡出透明效果**</span><br><span class="line">  - `fadeTo()`⁭：以渐进的方式调整到指定透明度</span><br><span class="line">  - 参数：</span><br><span class="line">    - `fadeTo(speed,opacity,callback)`</span><br><span class="line">- **渐变切换:结合`fadeIn`和`fadeOut`**</span><br><span class="line">  - `fadeToggle()`</span><br><span class="line">  - 参数:</span><br><span class="line">    - `fadeOut(speed,callback)`</span><br><span class="line"></span><br><span class="line">- 自定义动画：`animate()`</span><br><span class="line"></span><br><span class="line">  - 注意：在使用`animate`方法之前，为了影响该元素的`top` `left` `bottom` `right`样式属性，必须先把元素的`position`样式设置为`relative`或者`absolute`</span><br><span class="line"></span><br><span class="line">  - 停止元素的动画</span><br><span class="line"></span><br><span class="line">    - 很多时候需要停止匹配正在进行的动画，需要使用stop()</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      stop()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>语法结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop([clearQueue],[gotoEnd]);</span><br></pre></td></tr></table></figure>

<ul>
<li>都是可选参数，为布尔值</li>
<li>如果直接使用<code>stop()</code>方法，会立即停止当前正在进行的动画</li>
</ul>
</li>
</ul>
</li>
<li><p>判断元素是否处于动画状态</p>
<ul>
<li>如果不处于动画状态，则为元素添加新的动画，否则不添加<br><code>if(!$(element).is(&quot;:animated&quot;))&#123; //判断元素是否处于动画状态&#125;</code></li>
<li>这个方法在<code>animate</code>动画中经常被用到，需要注意</li>
</ul>
</li>
<li><p>延迟动画</p>
<ul>
<li>在动画执行过程中，如果你想对动画进行延迟操作，那么使用<code>delay()</code></li>
</ul>
</li>
</ul>
</li>
<li><p>用<code>animate</code>模拟<code>show()</code>:</p>
<ul>
<li><code>show</code>: 表示由透明到不透明</li>
<li><code>toggle</code>: 切换</li>
<li><code>hide</code>:表示由显示到隐藏</li>
</ul>
</li>
<li><p><strong>动画方法总结</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>hide()</code>和<code>show()</code></td>
<td align="left">同时修改多个样式属性即高度和宽度和不透明度</td>
</tr>
<tr>
<td align="left"><code>fadeIn()</code>和<code>fadeOut()</code></td>
<td align="left">只改变不透明度</td>
</tr>
<tr>
<td align="left"><code>slideUp()</code>和<code>slideDown()</code></td>
<td align="left">只改变高度</td>
</tr>
<tr>
<td align="left"><code>fadeTo()</code></td>
<td align="left">只改变不透明度</td>
</tr>
<tr>
<td align="left"><code>toggle()</code></td>
<td align="left">用来代替<code>show()</code>和<code>hide()</code>方法，所以会同时修改多个属性即高度、宽度和不透明度</td>
</tr>
<tr>
<td align="left"><code>slideToggle()</code></td>
<td align="left">用来代替<code>slideUp</code>和<code>slideDown()</code>方法，所以只能改变高度</td>
</tr>
<tr>
<td align="left"><code>fadeToggle()</code></td>
<td align="left">用来代替<code>fadeIn()</code>和<code>fadeOut</code>方法，只能改变不透明度</td>
</tr>
<tr>
<td align="left"><code>animate()</code></td>
<td align="left">属于自定义动画，以上各种动画方法都是调用了<code>animate</code>方法。此外，用<code>animate</code>方法还能自定义其他的样式属性，例如：<code>left``marginLeft ``scrollTop</code>等</td>
</tr>
</tbody></table>
<h4 id="第七节-jQuery中的事件"><a href="#第七节-jQuery中的事件" class="headerlink" title="第七节 jQuery中的事件"></a>第七节 jQuery中的事件</h4><hr>
<ul>
<li><p><strong>事件对象的属性</strong></p>
<ul>
<li><code>event.type</code>：获取事件的类型</li>
<li><code>event.target</code>:获取到触发事件的元素</li>
<li><code>event.preventDefault</code>方法 阻止默认事件行为</li>
<li><code>event.stopPropagation()</code>阻止事件的冒泡</li>
<li><code>keyCode</code>：只针对于<code>keypress</code>事件，获取键盘键数字 按下回车，<code>13</code></li>
<li><code>event.pageX / event.pageY</code> 获取到光标相对于页面的<code>x</code>坐标和<code>y</code>坐标<ul>
<li>如果没有<code>jQuery</code>，在IE浏览器中用<code>event.x</code> &#x2F; <code>event.y</code>;在<code>Firefox</code>浏览器中用<code>event.pageX</code> &#x2F; <code>event.pageY</code>。如果页面上有滚动条还要加上滚动条的宽度和高度</li>
</ul>
</li>
<li><code>event.clientX</code>：光标对于浏览器窗口的水平坐标 浏览器</li>
<li><code>event.clientY</code>：光标对于浏览器窗口的垂直坐标</li>
<li><code>event.screenX</code>：光标对于电脑屏幕的水平坐标 电脑屏幕</li>
<li><code>event.screenY</code>：光标对于电脑屏幕的水平坐标</li>
<li><code>event.which</code> 该方法的作用是在鼠标单击事件中获取到鼠标的左、中、右键，在键盘事件中的按键 <code>1</code>代表左键 <code>2</code>代表中键 <code>3</code>代表右键</li>
</ul>
</li>
<li><p><strong>事件冒泡</strong></p>
<ul>
<li>什么是冒泡<ul>
<li>在页面上可以有多个事件，也可以多个元素影响同一个元素</li>
<li>从里到外</li>
<li>嵌套关系</li>
<li>相同事件</li>
<li>其中的某一父类没有相同事件时,继续向上查找</li>
</ul>
</li>
<li>停止事件冒泡<ul>
<li>停止事件冒泡可以阻止事件中其他对象的事件处理函数被执行</li>
<li>在<code>jQuery</code>中提供了**<code>stopPropagation()</code>**方法</li>
</ul>
</li>
<li>阻止默认行为<ul>
<li>网页中元素有自己的默认行为，例如：单击超链接后会跳转、单击提交后表单会提交，有时需要阻止元素的默认行为</li>
<li>在<code>jQuery</code>中提供了<code>preventDefault()</code>方法来阻止元素的默认行为</li>
</ul>
</li>
<li>事件捕获<ul>
<li>事件捕获和冒泡是相反的过程，事件捕获是从最顶端往下开始触发</li>
<li>并非所有的浏览器都支持事件捕获，并且这个缺陷无法通过<code>JavaScript</code>来修复。<code>jQuery</code>不支持事件捕获，如需要用事件捕获，要用原生的<code>JavaScript</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>bind()</code>;绑定</strong></p>
<ul>
<li>为匹配元素绑定处理方法</li>
<li>需要给一个元素添加多个事件 ，事件执行一样时候</li>
<li><code>one()</code>：只执行一次</li>
</ul>
</li>
<li><p><strong>绑定特定事件类型方法</strong>：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">方法名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">页面载入</td>
<td align="left"><code>ready(fn)</code></td>
<td align="left">当<code>DOM</code>载入就绪可以绑定一个要执行的函数</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>blind(type,[data],fn)</code></td>
<td align="left">为每个匹配元素的特定事件绑定一个事件处理函数</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>unblind()</code></td>
<td align="left">解除绑定</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>on(events,[,selector[,]data],handler)</code></td>
<td align="left">在选择元素上绑定一个或者多个事件处理函数</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>off()</code></td>
<td align="left">移除<code>on</code>绑定的事件</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>delegate(selector,eventType,handler)</code></td>
<td align="left">为所有选择匹配元素附加一个或多个事件处理函数</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>undelegate()</code></td>
<td align="left">移除绑定</td>
</tr>
<tr>
<td align="left">事件动态</td>
<td align="left"><code>live(type,fn)</code></td>
<td align="left">对动态生成的元素进行事件绑定</td>
</tr>
<tr>
<td align="left">事件动态</td>
<td align="left"><code>die(type,fn)</code></td>
<td align="left">移除<code>live()</code>绑定的事件</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>hover()</code></td>
<td align="left">鼠标移入移出</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>toggle(fn1,fn2,[fn3],[fn4])</code></td>
<td align="left">每单击后依次调用函数</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>blur(fn)</code></td>
<td align="left">触发每一个匹配元素的<code>blur</code>事件</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>change()</code></td>
<td align="left">触发每一个匹配元素的<code>change</code>事件</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>click()</code></td>
<td align="left">触发每一个匹配元素的<code>click</code>事件</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>focus()</code></td>
<td align="left">触发每一个匹配元素的<code>focus</code>事件</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>submit()</code></td>
<td align="left">触发每一个匹配元素的<code>submit</code>事件</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>keydown()</code></td>
<td align="left">触发每一个匹配元素的<code>keydown</code>事件</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>keypress()</code></td>
<td align="left">触发每一个匹配元素的<code>keypress</code>事件</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>keyup()</code></td>
<td align="left">触发每一个匹配元素的keyup事件</td>
</tr>
<tr>
<td align="left">鼠标事件</td>
<td align="left"><code>mousedown(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">鼠标事件</td>
<td align="left"><code>mouseenter(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>mouseleave(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>mouseout(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>mouseover(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">窗口操作</td>
<td align="left"><code>resize(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">窗口操作</td>
<td align="left"><code>scroll(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
</tbody></table>
<h4 id="第八节-jQuery与Ajax"><a href="#第八节-jQuery与Ajax" class="headerlink" title="第八节 jQuery与Ajax"></a>第八节 jQuery与Ajax</h4><hr>
<ul>
<li><p>Ajax</p>
<p>简介 :</p>
<ul>
<li><code>Asynchronous Javascript And XML</code> （异步的<br><code>JavaScript</code>和<code>XML</code>）</li>
<li>它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体</li>
</ul>
</li>
<li><p><code>Ajax</code>优势与不足</p>
<ul>
<li><p><code>Ajax</code>优势</p>
<ul>
<li><p>优秀的用户体验</p>
<ul>
<li>这是<code>Ajax</code>下最大的有点，能在不刷新整个页面前提下更新数据</li>
</ul>
</li>
<li><p>提高</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web</span><br></pre></td></tr></table></figure>

<p>程序的性能</p>
<ul>
<li>与传统模式相比，<code>Ajax</code>模式在性能上最大的区别在于传输数据的方式，在传统模式中，数据的提交时通过表单来实现的。<code>Ajax</code>模式只是通过<code>XMLHttpRequest</code>对象向服务器提交希望提交的数据，即按需发送</li>
</ul>
</li>
<li><p>减轻服务器和带宽的负担</p>
<ul>
<li><code>Ajax</code>的工作原理相当于在用户和服务器之间加了一个中间层，似用户操作与服务器响应异步化。它在客户端创建<code>Ajax</code>引擎，把传统方式下的一些服务器负担的工作转移到客户端，便于客户端资源来处理，减轻服务器和带宽的负担</li>
</ul>
</li>
</ul>
</li>
<li><p>Ajax的不足</p>
<ul>
<li>浏览器对<code>XMLHttpRequest</code>对象的支持度不足</li>
<li>破坏浏览器前进、后退按钮的正常功能</li>
<li>对搜索引擎的支持的不足</li>
<li>开发和调试工具的缺乏</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="创建一个Ajax请求"><a href="#创建一个Ajax请求" class="headerlink" title="创建一个Ajax请求"></a>创建一个Ajax请求</h5><hr>
<ul>
<li><p><code>Ajax</code>的核心是<code>XMLHttpRequest</code>对象，它是<code>Ajax</code>实现的关键，发送异步请求、接受响应以及执行回调都是通过它来完成</p>
</li>
<li><p><strong>创建<code>ajax</code>对象 <code>var xhr = new XMLHttpRequest();</code></strong></p>
</li>
<li><p><strong>准备发送请求</strong></p>
<ul>
<li><p><strong><code>get</code> &#x2F; <code>post</code></strong></p>
<ul>
<li><p><code>get</code></p>
<ul>
<li>传递的数据放在<code>URL</code>后面</li>
<li>中文编码 <code>encodeURI( &#39;&#39; )</code>;</li>
<li>缓存 在数据后面加上随机数或者日期对象或者……</li>
</ul>
</li>
<li><p><strong><code>post</code></strong></p>
<ul>
<li>传递的数据放在<code>send()</code>里面，并且一定要规定数据格式</li>
<li>没有缓存问题</li>
</ul>
</li>
<li><p><code>form</code>表单中:</p>
<ul>
<li>&#96;&#96;&#96;<br>action<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        :</span><br><span class="line"></span><br><span class="line">        - `method`: (默认是`get`)</span><br><span class="line">        - `get`: 会在`url`里面以 `name=value` , 两个数据之间用 `&amp;` 连接</span><br><span class="line"></span><br><span class="line">      - `post`:</span><br><span class="line"></span><br><span class="line">    - `enctype`: `&quot;application/x-www-form-urlencoded&quot;`</span><br><span class="line"></span><br><span class="line">  - `url`</span><br><span class="line"></span><br><span class="line">  - 是否异步</span><br><span class="line"></span><br><span class="line">    - 同步(`false`)：阻塞</span><br><span class="line">    - 异步(`true`)：非阻塞</span><br><span class="line"></span><br><span class="line">- **正式发送请求**</span><br><span class="line"></span><br><span class="line">- **`ajax`请求处理过程**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>xhr.onreadystatechange &#x3D; function(){<br>    if (xhr.readyState &#x3D;&#x3D; 4)<br>    {<br>        alert( xhr.responseText );<br>    }<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `onreadystatechange` ：当处理过程发生变化的时候执行下面的函数</span><br><span class="line">- `readyState` ：`ajax`处理过程</span><br><span class="line">  - 0：请求未初始化（还没有调用 `open()`）。</span><br><span class="line">  - 1：请求已经建立，但是还没有发送（还没有调用 `send()`）。</span><br><span class="line">  - 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。</span><br><span class="line">  - 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。</span><br><span class="line">  - 4：响应已完成；您可以获取并使用服务器的响应了。</span><br><span class="line">- `responseText` ：请求服务器返回的数据存在该属性里面</span><br><span class="line">- `status` : `http`状态码</span><br><span class="line"></span><br><span class="line">![HTTP状态码](http://7xq6al.com1.z0.glb.clouddn.com/jquery9.png)</span><br><span class="line"></span><br><span class="line">- 案例：`ajax`封装案例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;ajax请求后台数据<br>var btn &#x3D;  document.getElementsByTagName(“input”)[0];<br>btn.onclick &#x3D; function(){</p>
<pre><code>ajax(&#123;//json格式
    type:&quot;post&quot;,
    url:&quot;post.php&quot;,
    data:&quot;username=poetries&amp;pwd=123456&quot;,
    asyn:true,
    success:function(data)&#123;
        document.write(data);
    &#125;
&#125;);
</code></pre>
<p>}<br>&#x2F;&#x2F;封装ajax<br>function ajax(aJson){<br>    var ajx &#x3D; null;<br>    var type &#x3D; aJson.type || “get”;<br>    var asyn &#x3D; aJson.asyn || true;<br>    var url &#x3D; aJson.url;		&#x2F;&#x2F; url 接收 传输位置<br>    var success &#x3D; aJson.success;&#x2F;&#x2F; success 接收 传输完成后的回调函数<br>    var data &#x3D; aJson.data || ‘’;&#x2F;&#x2F; data 接收需要附带传输的数据</p>
<pre><code>if(window.XMLHttpRequest)&#123;//兼容处理
    ajx = new XMLHttpRequest();//一般浏览器
&#125;else
&#123;
    ajx = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE6+
&#125;
if (type == &quot;get&quot; &amp;&amp; data)
&#123;
    url +=&quot;/?&quot;+data+&quot;&amp;&quot;+Math.random();
&#125;

//初始化ajax请求
ajx.open( type , url , asyn );
//规定传输数据的格式
ajx.setRequestHeader(&#39;content-type&#39;,&#39;application/x-www-form-urlencoded&#39;);
//发送ajax请求（包括post数据的传输）
type == &quot;get&quot; ?ajx.send():ajx.send(aJson.data);

//处理请求
ajx.onreadystatechange = function(aJson)&#123;
    
if(ajx.readState == 4)&#123;
        
    if (ajx.status == 200 &amp;&amp; ajx.status&lt;300)//200是HTTP 请求成功的状态码
    &#123;
        //请求成功处理数据
        success &amp;&amp; success(ajx.responseText);
    &#125;else&#123;
        alert(&quot;请求出错&quot;+ajx.status);
        
    &#125;
&#125;
    
&#125;;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### jQuery中的Ajax [补充部分–来自锋利的jQuery]</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">`jquery`对`Ajax`操作进行了封装，在`jquery`中的`$.ajax()`方法属于最底层的方法，第`2`层是`load()`、`$.get()`、`$.post();`第`3`层是`$.getScript()`、`$.getJSON()`，第`2`层使用频率很高</span><br><span class="line"></span><br><span class="line">###### `load()`方法</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  load()</span><br></pre></td></tr></table></figure>

<p>  方法是</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jquery</span><br></pre></td></tr></table></figure>

<p>  中最简单和常用的</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax</span><br></pre></td></tr></table></figure>

<p>  方法，能载入远程</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br></pre></td></tr></table></figure>

<p>  代码并插入</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOM</span><br></pre></td></tr></table></figure>

<p>  中 结构为：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load(url,[data],[callback])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>url</code>参数指定选择符可以加载页面内的某些元素 <code>load</code>方法中<code>url</code>语法：<code>url selector</code> 注意：<code>url</code>和选择器之间有一个空格</p>
</li>
<li><p>传递方式</p>
<ul>
<li><code>load()</code>方法的传递方式根据参数<code>data</code>来自动指定，如果没有参数传递，则采用<code>GET</code>方式传递，反之，采用<code>POST</code></li>
</ul>
</li>
<li><p>回调参数</p>
<ul>
<li>必须在加载完成后才执行的操作，该函数有三个参数 分别代表请求返回的内容、请求状态、<code>XMLHttpRequest</code>对象</li>
<li>只要请求完成，回调函数就会被触发</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#testTest&quot;).load(&quot;test.html&quot;,function(responseText,textStatus,XMLHttpRequest)&#123;</span><br><span class="line">    //respnoseText 请求返回的内容</span><br><span class="line">    //textStatus 请求状态 ：sucess、error、notmodified、timeout</span><br><span class="line">    //XMLHttpRequest </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>load方法参数</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>url</code></td>
<td align="left"><code>String</code></td>
<td align="left">请求<code>HTML</code>页面的<code>URL</code>地址</td>
</tr>
<tr>
<td align="left"><code>data(可选)</code></td>
<td align="left"><code>Object</code></td>
<td align="left">发送至服务器的<code>key</code> &#x2F; <code>value</code>数据</td>
</tr>
<tr>
<td align="left"><code>callback(可选)</code></td>
<td align="left"><code>Function</code></td>
<td align="left">请求完成时的回调函数，无论是请求成功还是失败</td>
</tr>
</tbody></table>
<h6 id="get-和-post-方法"><a href="#get-和-post-方法" class="headerlink" title="$.get()和$.post()方法"></a>$.get()和$.post()方法</h6><hr>
<p><code>load()</code>方法通常用来从web服务器上获取静态的数据文件。在项目中需要传递一些参数给服务器中的页面，那么可以使用<code>$.get()</code>和<code>$.post()</code>或<code>$.ajax()</code>方法</p>
<ul>
<li><p>注意：<code>$.get()</code>和<code>$.post()</code>方法是<code>jquery</code>中的全局函数</p>
</li>
<li><p><strong>$.get()方法</strong></p>
<ul>
<li><p><code>$.get()</code>方法使用<code>GET</code>方式来进行异步请求</p>
</li>
<li><p>结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get(url,[data],callback,type)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果服务器返回的内容格式是<code>xml</code>文档，需要在服务器端设置<code>Content-Type</code>类型 代码如下：<code>header(&quot;Content-Type:text/xml:charset=utf-8&quot;)</code> &#x2F;&#x2F;<code>php</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>$.get()</code>方法参数解析</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>url</code></td>
<td align="left"><code>String</code></td>
<td align="left">请求<code>HTML</code>页的地址</td>
</tr>
<tr>
<td align="left"><code>data(可选)</code></td>
<td align="left"><code>Object</code></td>
<td align="left">发送至服务器的<code>key</code>&#x2F; <code>value</code> 数据会作为<code>QueryString</code>附加到请求URL中</td>
</tr>
<tr>
<td align="left"><code>callback(可选)</code></td>
<td align="left"><code>Function</code></td>
<td align="left">载入成功的回调函数（只有当<code>Response</code>的返回状态是success才调用该方法）</td>
</tr>
<tr>
<td align="left"><code>type(可选)</code></td>
<td align="left"><code>String</code></td>
<td align="left">服务器返回内容的格式，包括<code>xml</code>、<code>html</code>、<code>script</code>、<code>json</code>、<code>text</code>和<code>_default</code></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>$.post()方法</strong></p>
<ul>
<li><p>它与</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get()</span><br></pre></td></tr></table></figure>

<p>方法的结构和使用方式相同，有如下区别</p>
<ul>
<li>&#96;&#96;&#96;<br>GET<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">请求会将参数跟张乃URL后进行传递，而</span><br><span class="line"></span><br></pre></td></tr></table></figure>
POST<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">请求则是作为</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Http<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">消息的实体内容发送给web服务器，在</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ajax<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      请求中，这种区别对用户不可见</span><br><span class="line"></span><br><span class="line">      - `GET`方式对传输数据有大小限制（通常不能大于`2KB`），而使用`POST`方式传递的数据量要比`GET`方式大得多（理论不受限制）</span><br><span class="line">      - `GET`方式请求的数据会被浏览器缓存起来，因此其他人可以从浏览器的历史纪录中读取这些数据，如：账号、密码。在某种情况下，`GET`方式会带来严重的安全问题，而`POST`相对来说可以避免这些问题</span><br><span class="line">      - `GET`和`POST`方式传递的数据在服务端的获取也不相同。在`PHP`中，`GET`方式用`$_GET[]`获取；`POST`方式用`$_POST[]`获取;两种方式都可用`$_REQUEST[]`来获取</span><br><span class="line"></span><br><span class="line">- **总结**</span><br><span class="line"></span><br><span class="line">  - 使用`load()`、`$.get()`和`$.post()`方法完成了一些常规的`Ajax`程序，如果还需要复杂的`Ajax`程序，就需要用到`$.ajax()`方式</span><br><span class="line"></span><br><span class="line">###### $.ajax()方法</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- `$.ajax()`方法是`jquery`最底层的`Ajax`实现，它的结构为`$.ajax(options)`</span><br><span class="line">- 该方法只有一个参数，但在这个对象里包含了`$.ajax()`方式所需要的请求设置以及回调函等信息，参数以`key` / `value`存在，所有参数都是可选的</span><br><span class="line">- **$.ajax()方式常用参数解析**</span><br><span class="line"></span><br><span class="line">| 参数         | 类型       | 说明                                                         |</span><br><span class="line">| :----------- | :--------- | :----------------------------------------------------------- |</span><br><span class="line">| `url`        | `String`   | (默认为当前页地址)发送请求的地址                             |</span><br><span class="line">| `type`       | `String`   | 请求方式（`POST`或`GET`）默认为`GET`                         |</span><br><span class="line">| `timeout`    | `Number`   | 设置请求超时时间（毫秒）                                     |</span><br><span class="line">| `dataType`   | `String`   | 预期服务器返回的类型。可用的类型如下  **xml**:返回`XML`文档，可用`jquery`处理 **html**:返回纯文本的`HTML`信息，包含的`script`标签也会在插入`DOM`时执行 **script**：返回纯文本的`javascript`代码。不会自动缓存结果，除非设置`cache`参数。注意：在远程请求时，所有的`POST`请求都将转为`GET`请求 **json**:返回`JSON`数据 **jsonp**:`JSONP`格式，使用`jsonp`形式调用函数时，例如：`myurl?call back=?,jquery`将自动替换后一个`？`为正确的函数名，以执行回调函数 **text**:返回纯文本字符串 |</span><br><span class="line">| `beforeSend` | `Function` | 发送请求前可以修改`XMLHttpRequest`对象的函数，例如添加自定义`HTTP`头。在`beforeSend`中如果返回`false`可以取消本次`Ajax`请求。`XMLHttpRequest`对象是唯一的参数 function(XMLHttpRequest)&#123;      `this`;//调用本次`Ajax`请求时传递的`options`参数 &#125; |</span><br><span class="line">| `complete`   | `Function` | 请求完成后的回调函数（请求成功或失败时都调用） 参数：`XMLHttpRequest`对象和一个描述成功请求类型的字符串 function(XMLHttpRequest,textStatus)&#123;      `this`;//调用本次Ajax请求时传递的`options`参数 &#125; |</span><br><span class="line">| `success`    | `Function` | 请求成功后调用的回调函数，有两个参数 (1)由服务器返回，并根据`dataTyppe`参数进行处理后的数据 (2)描述状态的字符串 `function`(data,textStatus)&#123;      //`data`可能是`xmlDoc、``jsonObj`、`html`、`text`等      `this`;//调用本次`Ajax`请求时传递的`options`参数 &#125; |</span><br><span class="line">| `error`      | `Function` | 请求失败时被调用的函数                                       |</span><br><span class="line">| `global`     | `Boolean`  | 默认为`true`。表示是否触发全局`Ajax`事件，设置为`false`将不会触发。`AjaxStart`或`AjaxStop`可用于控制各种`Ajax`事件 |</span><br><span class="line"></span><br><span class="line">#### 第九节 插件</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **什么是插件**</span><br><span class="line">  - 插件(`Plugin`)也称为`jQuery`的扩展。以`jQuery`核心代码为基础编写的符合一定规范的应用程序。通过`js`文件的方式引用。</span><br><span class="line">- **插件分为哪几类**</span><br><span class="line">  - `UI`类、表单及验证类、输入类、特效类、`Ajax`类、滑动类、图形图像类、导航类、综合工具类、动画类等等</span><br><span class="line"></span><br><span class="line">- 引入插件的步骤</span><br><span class="line">  - 引入`jquery.js`文件，而且在所以插件之前引入</span><br><span class="line">  - 引入插件</span><br><span class="line">  - 引入插件相关文件，比如皮肤、中文包</span><br><span class="line"></span><br><span class="line">- **如何自定义插件**：</span><br><span class="line">  - 插件形式分为3类：</span><br><span class="line">    - 封装对象方法插件</span><br><span class="line">    - 封装全局函数插件</span><br><span class="line">    - 选择器插件(类似于.`find()`)</span><br><span class="line">- **自定义插件的规范**（解决各种插件的冲突和错误，增加成功率）</span><br><span class="line">  - 命名：`jquery.插件名.js`</span><br><span class="line">  - 所有的新方法附加在`jquery.fn`对象上面，所有新功能附加在`jquery`上</span><br><span class="line">  - 所有的方法或插件必须用分号结尾，避免出问题</span><br><span class="line">  - 插件必须返回jQuery对象，便于链式连缀</span><br><span class="line">  - 避免插件内部使用`$`，如果要使用，请传递`jQuery`(`$`并不是总等于`jQuery`，另外其他`js`框架也可能使用`$`)</span><br><span class="line">  - 插件中的`this`应该指向`jQuery`对象</span><br><span class="line">  - 使用`this.each()`迭代元素</span><br><span class="line">- **自定义插件案例**</span><br><span class="line">  - 为了方便用户创建插件，`jQuery`提供了 `jQuery.extend()` 和 `jQuery.fn.extend()`</span><br><span class="line">  - `jQuery.extend()`：创建工具函数或者是选择器</span><br><span class="line">  - `jQuery.fn.extend()`：创建`jQuery`对象命令 （`fn`相当于`prototype`的别名）</span><br><span class="line">- **`jQuery`官方提供的插件开发模板**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>;(function($){<br>    $.fn.plugin&#x3D;function(options){<br>        var defaults &#x3D; {<br>            &#x2F;&#x2F;各种参数 各种属性<br>        }<br>        var options &#x3D; $.extend(defaults,options);</p>
<pre><code>    this.each(function()&#123;
        //实现功能的代码
    &#125;);

    return this;
&#125;
</code></pre>
<p>})(jQuery);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**自定义`jQuery`函数**：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(function($){<br>    $.extend({<br>        test: function(){<br>            alert(“hello plugin”);<br>        }<br>    })<br>    })(jQuery);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**自定义`jQuery`命令**：</span><br><span class="line"></span><br><span class="line">- 形式1：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(function($){<br>    $.fn.extend({<br>        say : function(){<br>         alert(“hello plugin”);<br>    }<br>    })<br>})(jQuery);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 形式2：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(function($){<br>    $.fn.say &#x3D; function(){<br>        alert(“hello plugin”);<br>    };</p>
<p>})(jQuery);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 附录一 jQuery各个版本新增的一些常用的方法</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- `jQuery1.3`新增常用的方法</span><br><span class="line"></span><br><span class="line">| 方法         | 说明                                                         |</span><br><span class="line">| :----------- | :----------------------------------------------------------- |</span><br><span class="line">| `.closest()` | 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 |</span><br><span class="line">| `die()`      | 从元素中删除先前用`live()`方法绑定的所有的事件               |</span><br><span class="line">| `live()`     | 附加一个事件处理器到符合目前选择器的所有元素匹配             |</span><br><span class="line"></span><br><span class="line">- `jQuery1.4`新增常用的方法</span><br><span class="line"></span><br><span class="line">| 方法            | 说明                                                         |</span><br><span class="line">| :-------------- | :----------------------------------------------------------- |</span><br><span class="line">| `.first()`      | 获取集合中第一个元素                                         |</span><br><span class="line">| `last()`        | 获取集合中最后一个元素                                       |</span><br><span class="line">| `has(selector)` | 保留包含特定后代的元素，去掉那些不含有指定后代的元素         |</span><br><span class="line">| `detach()`      | 从`DOM`中去掉所有匹配的元素。`detach()`和`remov()`一样，除了`detach()`保存了所有`jquery`数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入`DOM`时，这种方法很有用 |</span><br><span class="line">| `delegate()`    | 为所有选择器匹配的元素附加一个处理一个或多个事件             |</span><br><span class="line">| `undelegate()`  | 为所有选择器匹配的元素删除一个处理一个或多个事件             |</span><br><span class="line"></span><br><span class="line">- `jQuery1.6`新增常用的方法</span><br><span class="line"></span><br><span class="line">| 方法                           | 说明                                     |</span><br><span class="line">| :----------------------------- | :--------------------------------------- |</span><br><span class="line">| `prop(proptyName)`             | 获取在匹配元素集合中的第一个元素的属性值 |</span><br><span class="line">| `removeProp(proptyName,value)` | 为匹配的元素删除设置的属性               |</span><br><span class="line">| `:focus`                       | 选择当前获取焦点的元素                   |</span><br><span class="line"></span><br><span class="line">#### 附录二 jQuery性能优化</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **性能优化**</span><br><span class="line"></span><br><span class="line">  - 使用最新版的jQuery类库</span><br><span class="line"></span><br><span class="line">  - 使用合适的选择器</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      $(#id)</span><br></pre></td></tr></table></figure>

<pre><code>  - 使用`id`来定位`DOM`元素是最佳的方式，为了提高性能，建议从最近的`ID`元素开始往下搜索

- ```
  $(&quot;p&quot;)
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
  $(&quot;div&quot;)
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
  $(&quot;input&quot;)
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 标签选择器性能也不错，它是性能优化的第二选择。因为`jQuery`将直接调用本地方法`document.getElementsByTagName()`来定位`DOM`元素</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  $(&quot;.class&quot;)</span><br></pre></td></tr></table></figure>

  - 建议有选择性的使用

- ```
  $(&quot;[attribute=value]&quot;)
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 对这个利用属性定位`DOM`元素，本地`JavaScript`并没有直接实现。这种方式性能并不是很理想。建议避免使用。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  $(&quot;:hidden&quot;)</span><br></pre></td></tr></table></figure>

  - 和上面利用属性定位`DOM`方式类似，建议尽量不要使用

- 注意的地方

  - 尽量使用`ID`选择器
  - 尽量给选择器指定上下文
</code></pre>
<ul>
<li><p>缓存对象</p>
<ul>
<li>如果你需要在其他函数中使用<code>jQuery</code>对象，你可以把他们缓存在全局环境中</li>
</ul>
</li>
<li><p>数组方式使用<code>jQuery</code>对象</p>
<ul>
<li>使用<code>jQuery</code>选择器获取的结果是一个<code>jQuery</code>对象。在性能方面，建议使用<code>for</code>或<code>while</code>循环来处理，而不是<code>$.each()</code></li>
</ul>
</li>
<li><p>事件代理</p>
<ul>
<li><p>每一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br></pre></td></tr></table></figure>

<p>事件（如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click</span><br></pre></td></tr></table></figure>

<p>、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mouseove</span><br></pre></td></tr></table></figure>

<p>r）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时这点很有用。比如，我们要为一个表单绑定这样的行为：点击td后，把背景颜色设置为红色</p>
<ul>
<li><p><code>$(&quot;#myTable td&quot;).click(function()&#123;$(this).css(&quot;background&quot;,&quot;red&quot;);&#125;);</code></p>
</li>
<li><p>假设有<code>100</code>个<code>td</code>元素，在使用以上的方式时，绑定了<code>100</code>个事件，将带来性能影响</p>
</li>
<li><p>代替这种多元素的事件监听方法是，你只需向他们的父节点绑定一次事件，然后通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.target</span><br></pre></td></tr></table></figure>

<p>获取到点击的当前元素</p>
<ul>
<li><code>$(&quot;#myTable td&quot;).click(function(&#123;$(e.target).css(&quot;background&quot;,&quot;red&quot;)&#125;);</code></li>
<li><code>e.target</code>捕捉到触发的目标</li>
</ul>
</li>
<li><p>在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery1.7</span><br></pre></td></tr></table></figure>

<p>中提供了一个新的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on()</span><br></pre></td></tr></table></figure>

<p>，来帮助你将整个事件监听封装到一个便利的方法中</p>
<ul>
<li><code>$(&quot;#myTable td&quot;).on(&quot;click&quot;,&#39;td&#39;,function()&#123;$(this).css(&quot;background&quot;,&quot;red&quot;);&#125;);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>将你的代码转化成jQuery插件</p>
<ul>
<li>它能够使你的代码有更好的重用性，并且能够有效的帮助你组织代码</li>
</ul>
</li>
<li><p><strong>使用join()方法来拼接字符串</strong></p>
<ul>
<li>也许你之前使用<code>+</code>来拼接字符串，现在可以改了。它确实有助于性能优化，尤其是长字符串处理的时候</li>
</ul>
</li>
<li><p><strong>合理使用HTML5和Data属性</strong></p>
<ul>
<li>&#96;&#96;&#96;<br>HTML5<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
data<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">属性可以帮助我们插入数据，特别是后端的数据交换。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
jQuery<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Data()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法有效利用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
HTML5<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      的属性</span><br><span class="line"></span><br><span class="line">      - 例如：``</span><br><span class="line">      - 为了读取数据，你需要使用如下代码</span><br><span class="line">        - `$(&quot;#dl&#x27;).data(&quot;role&#x27;;//page)`</span><br><span class="line">        - `$(&quot;#dl&#x27;).data(&quot;lastValue&#x27;;//43)`</span><br><span class="line">        - `$(&quot;#dl&#x27;).data(&quot;options&#x27;;//john)`</span><br><span class="line"></span><br><span class="line">  - **尽量使用原生的JavaScript方法**</span><br><span class="line"></span><br><span class="line">  - 压缩JavaScript代码</span><br><span class="line"></span><br><span class="line">    - 一方面使用`Gzip`；另一方面去除`JavaScript`文件里面的注释、空白</span><br><span class="line"></span><br><span class="line">#### 附录三 常用的jQuery代码片段</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 禁用页面的右键菜单</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>$(document).ready(functuion(){<br>    $(document).bind(“contextmenu”,function(e){<br>        return false;<br>  });<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 新窗口打开页面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    &#x2F;&#x2F;例子1：href&#x3D;”http:&#x2F;&#x2F;“的链接将会在新窗口打开链接<br>    $(‘a[href&#x3D;^&#x3D;”http:&#x2F;&#x2F;“]’).attr(“target”,”_blank”);</p>
<p>  &#x2F;&#x2F;例子2：rel&#x3D;”external”的超链接将会在新窗口打开链接<br>    $(“a[rel$&#x3D;’external’]”).click(function(){<br>      this.target &#x3D; “_blank”;<br>    });<br>});<br>&#x2F;&#x2F;use<br><a target="_blank" href="http://baidu.com" rel="external noopener">open</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 判断浏览器类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).reday(function(){<br>    &#x2F;&#x2F;Firefox2 and above<br>    if( $.browser.mozilla &amp;&amp; $.browser.version&gt;&#x3D;”1.8”){<br>      &#x2F;&#x2F;do something<br>  }</p>
<p>  &#x2F;&#x2F; Safari<br>  if($.browser.safari){<br>     &#x2F;&#x2F;do something<br>  }</p>
<p>  &#x2F;&#x2F; Chrome<br>  if($.browser.chrome){<br>     &#x2F;&#x2F;do something<br>  }</p>
<p>  &#x2F;&#x2F; Opera<br>  if($.browser.opera){<br>     &#x2F;&#x2F;do something<br>  }</p>
<p>})</p>
<p>  &#x2F;&#x2F; IE6 and blow<br>  if($.browser.msie &amp;&amp; $.browser.version&lt;&#x3D;6){<br>     &#x2F;&#x2F;do something<br>  }</p>
<p>  &#x2F;&#x2F; anything above IE6<br>  if($.browser.msie &amp;&amp; $.browser.version &gt; 6){<br>     &#x2F;&#x2F;do something<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 输入框文字获取和失去焦点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    $(“input.text1”).val(“Enter you search text here”);<br>    textFill($(‘input.text1’));<br>});</p>
<p>function textFill(input){&#x2F;&#x2F;input focus text function<br>    var originvalue &#x3D; input.val();<br>    input.focus(funtion(){<br>        if($.trim(input.val())&#x3D;&#x3D; originvalue){<br>            input.val(‘ ‘);<br>        }<br>  }).blur(function(){<br>      if($.trim(input.val()) &#x3D;&#x3D; ‘ ‘){<br>          input.val(originalvalue);<br>      }<br>  })<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 获取鼠标位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>  $(document).mousemove(function(e){<br>      $(“#XY”).html(“X:” + e.pageX+ “| Y” + e.pageY);<br>  });<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 判断元素是否存在</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    if($(“#id”).length){<br>      &#x2F;&#x2F; do some thing<br>  }<br>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 点击div也可以跳转</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(“div”).click(function(){<br>    window.location  &#x3D; $(this).find(“a”).attr(“href”);<br>})</p>
<p>&#x2F;&#x2F;use</p>
<div><a href="index.html">home</a></div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 设置div在屏幕中央</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(document).ready(function(){
    jQuery.fn.center = function(){
        this.css("position","absolute");
        this.css("top",($(window).height() - this.lenght()) / 2 +$(window).scrollTop() + "px"); 
        this.css("left",($(window).height() - this.lenght()) / 2 +$(window).scrollLeft() + "px"); 
      return this;
  }
//use 

<p> $(“#XY”).center();<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 关闭所有动画效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    jQuery.fx.off &#x3D; true;<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 检测鼠标的右键和左键</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    $(“#xy”).mousedown(function(e){<br>        alert(e.which);&#x2F;&#x2F;1 &#x3D; 鼠标左键  2&#x3D; 鼠标中间 3 &#x3D; 鼠标右键<br>  });<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 回车提交表单</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    $(“input”).keyup(function(e){<br>        if(e.which &#x3D;&#x3D; “13”){<br>            alert(“回车提交”);<br>      }<br>  })<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 设置全局的Ajax参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(“#load”).ajaxStart(function(){<br>    showLoading();&#x2F;&#x2F;显示loading<br>    disableButtons() &#x2F;&#x2F;禁用按钮<br>})<br> $(“#load”).ajaxComplete(function(){<br>    hideLoading();&#x2F;&#x2F;隐藏loading<br>    enableButtons();&#x2F;&#x2F;启用按钮<br>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 获取选中的下拉框</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(“#someElement”).find(‘option:selected’);<br>$(“#someElement option:selected”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 切换复选框</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var tog &#x3D; false;<br>$(“button”).click(function(){<br>    $(“input[type&#x3D;checkbox]’).attr(“checked”,!tog);<br>    tog &#x3D; !tog;<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 个性化链接</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>     $(“a[href$&#x3D;’pdf’]”).addClass(“pdf”);<br>     $(“a[href$&#x3D;’zip’]”).addClass(“zip”);<br>     $(“a[href$&#x3D;’psd’]”).addClass(“psd”);<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在一段时间后自动隐藏或关闭元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>setTimeOut(function(){<br>        $(“div”).fadeIn(400);<br>  },3000);</p>
<p>&#x2F;&#x2F;而在1.4之后的版本可以用delay()来实现<br>$(“div”).slideUp(300).delay(3000).fadeIn(400);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用事件代理绑定元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> &#x2F;&#x2F;为table里面的td元素绑定click事件，不管td是一直存在还是动态创建的<br> &#x2F;&#x2F;jQuery 1.4.2之前使用这种方式<br> $(“table”).each(function(){<br>    $(“td”,this).live(“click”,function(){<br>       $(this).toggleClass(“hover”);<br>    });<br>});</p>
<p>&#x2F;&#x2F;jquery 1.4.2使用的方式</p>
<p>$(“table”).delegate(“td”,”click”,function(){<br>    $(this).toggleClass(“hover”);<br>});</p>
<p>&#x2F;&#x2F;jQuery1.7.1使用的方式<br>$(“table”).on(“click”,”td”,function(){<br>    $(this).toggleClass(“hover”);<br> })</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 预加载图片</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(function($) {<br>  var cache &#x3D; [];<br>  &#x2F;&#x2F; Arguments are image paths relative to the current page.<br>  $.preLoadImages &#x3D; function() {<br>    var args_len &#x3D; arguments.length;<br>    for (var i &#x3D; args_len; i–;) {<br>      var cacheImage &#x3D; document.createElement(‘img’);<br>      cacheImage.src &#x3D; arguments[i];<br>      cache.push(cacheImage);<br>    }<br>  }<br>jQuery.preLoadImages(“image1.gif”, “&#x2F;path&#x2F;to&#x2F;image2.png”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 让页面中的每个元素都适合在移动设备上展示</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var scr &#x3D; document.createElement(‘script’);<br>scr.setAttribute(‘src’, ‘<a target="_blank" rel="noopener" href="https://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js&#39;">https://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js&#39;</a>);<br>document.body.appendChild(scr);<br>scr.onload &#x3D; function(){<br>    $(‘div’).attr(‘class’, ‘’).attr(‘id’, ‘’).css({<br>        ‘margin’ : 0,<br>        ‘padding’ : 0,<br>        ‘width’: ‘100%’,<br>        ‘clear’:’both’<br>    });<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 图像等比例缩放</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(window).bind(“load”, function() {<br>    &#x2F;&#x2F; IMAGE RESIZE<br>    $(‘#product_cat_list img’).each(function() {<br>        var maxWidth &#x3D; 120;<br>        var maxHeight &#x3D; 120;<br>        var ratio &#x3D; 0;<br>        var width &#x3D; $(this).width();<br>        var height &#x3D; $(this).height();<br>        if(width &gt; maxWidth){<br>            ratio &#x3D; maxWidth &#x2F; width;<br>            $(this).css(“width”, maxWidth);<br>            $(this).css(“height”, height * ratio);<br>            height &#x3D; height * ratio;<br>        }<br>        var width &#x3D; $(this).width();<br>        var height &#x3D; $(this).height();<br>        if(height &gt; maxHeight){<br>            ratio &#x3D; maxHeight &#x2F; height;<br>            $(this).css(“height”, maxHeight);<br>            $(this).css(“width”, width * ratio);<br>            width &#x3D; width * ratio;<br>        }<br>    });<br>    &#x2F;&#x2F;$(“#contentpage img”).show();<br>    &#x2F;&#x2F; IMAGE RESIZE<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 返回页面顶部</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; Back To Top<br>$(document).ready(function(){<br>  $(‘.top’).click(function() {<br>     $(document).scrollTo(0,500);<br>  });<br>});<br>&#x2F;&#x2F;Create a link defined with the class .top<br><a href="#" class="top">Back To Top</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用jQuery打造手风琴式的折叠效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var accordion &#x3D; {<br>     init: function(){<br>           var $container &#x3D; $(‘#accordion’);<br>           $container.find(‘li:not(:first) .details’).hide();<br>           $container.find(‘li:first’).addClass(‘active’);<br>           $container.on(‘click’,’li a’,function(e){<br>                  e.preventDefault();<br>                  var $this &#x3D; $(this).parents(‘li’);<br>                  if($this.hasClass(‘active’)){<br>                         if($(‘.details’).is(‘:visible’)) {<br>                                $this.find(‘.details’).slideUp();<br>                         } else {<br>                                $this.find(‘.details’).slideDown();<br>                         }<br>                  } else {<br>                         $container.find(‘li.active .details’).slideUp();<br>                         $container.find(‘li’).removeClass(‘active’);<br>                         $this.addClass(‘active’);<br>                         $this.find(‘.details’).slideDown();<br>                  }<br>           });<br>     }<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用jQuery和Ajax自动填充选择框</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(function(){<br>$(“select#ctlJob”).change(function(){<br>$.getJSON(“&#x2F;select.php”,{id: $(this).val(), ajax: ‘true’}, function(j){<br>var options &#x3D; ‘’;<br>for (var i &#x3D; 0; i &lt; j.length; i++) {<br>options +&#x3D; ‘<br>‘ + j[i].optionDisplay + ‘<br>‘;<br>}<br>$(“select#ctlPerson”).html(options);<br>})<br>})<br>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 自动替换丢失的图片</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; Safe Snippet<br>$(“img”).error(function () {<br>    $(this).unbind(“error”).attr(“src”, “missing_image.gif”);<br>});<br>&#x2F;&#x2F; Persistent Snipper<br>$(“img”).error(function () {<br>    $(this).attr(“src”, “missing_image.gif”);<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 预防对表单进行多次提交</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function() {<br>  $(‘form’).submit(function() {<br>    if(typeof jQuery.data(this, “disabledOnSubmit”) &#x3D;&#x3D; ‘undefined’) {<br>      jQuery.data(this, “disabledOnSubmit”, { submited: true });<br>      $(‘input[type&#x3D;submit], input[type&#x3D;button]’, this).each(function() {<br>        $(this).attr(“disabled”, “disabled”);<br>      });<br>      return true;<br>    }<br>    else<br>    {<br>      return false;<br>    }<br>  });<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 动态添加表单元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;change event on password1 field to prompt new input<br>$(‘#password1’).change(function() {<br>        &#x2F;&#x2F;dynamically create new input and insert after password1<br>        $(“#password1”).append(“”);<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在窗口滚动时自动加载内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var loading &#x3D; false;<br>$(window).scroll(function(){<br>    if((($(window).scrollTop()+$(window).height())+250)&gt;&#x3D;$(document).height()){<br>        if(loading &#x3D;&#x3D; false){<br>            loading &#x3D; true;<br>            $(‘#loadingbar’).css(“display”,”block”);<br>            $.get(“load.php?start&#x3D;”+$(‘#loaded_max’).val(), function(loaded){<br>                $(‘body’).append(loaded);<br>                $(‘#loaded_max’).val(parseInt($(‘#loaded_max’).val())+50);<br>                $(‘#loadingbar’).css(“display”,”none”);<br>                loading &#x3D; false;<br>            });<br>        }<br>    }<br>});<br>$(document).ready(function() {<br>    $(‘#loaded_max’).val(50);<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 导航菜单背景切换效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul id='nav'> 
    <li>导航一</li> 
    <li>导航二</li> 
    <li>导航三</li>
</ul>

<p>&#x2F;&#x2F;注意：代码需要修饰完善</p>
<p>$(‘#nav’).click(function(e) {<br> &#x2F;&#x2F; 要知道siblings的使用          </p>
<p>$(e.target).addClass(‘tclass’).siblings(‘.tclass’).removeClass(‘tclass’);;</p>
<p> });</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解决`jQuery`, `prototype`共存，`$`全局变量冲突问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<script src="prototype.js"></script>
<script src="http://blogbeta.blueidea.com/jquery.js"></script>
<script type="text/javascript"> jQuery.noConflict();</script> 

<p>注意：一定要先引入prototype.js 再引入jquery.js，先后顺序不可错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- jQuery 判断元素上是否绑定了事件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;jQuery event封装支持判断元素上是否绑定了事件，此方法只适用于jQuery绑定的事件<br>var $events &#x3D; $(“#foo”).data(“events”);<br>if( $events &amp;&amp; $events[“click”] ){　　<br>    &#x2F;&#x2F;your code<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如何正确地使用`toggleClass`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;切换（toggle）类允许你根据某个类的&#x2F;&#x2F;是否存在来添加或是删除该类。<br>&#x2F;&#x2F;这种情况下有些开发者使用：<br>a.hasClass(‘blueButton’) ? a.removeClass(‘blueButton’) : a.addClass(‘blueButton’);<br>&#x2F;&#x2F;toggleClass允许你使用下面的语句来很容易地做到这一点<br>a.toggleClass(‘blueButton’);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如何设置IE特有的功能</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>if ($.browser.msie) {<br>    &#x2F;&#x2F; Internet Explorer就是个虐待狂<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如何验证某个元素是否为空</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 方法一<br>if (! $(‘#keks’).html()) {<br>    &#x2F;&#x2F;什么都没有找到;<br>}<br>&#x2F;&#x2F; 方法二<br>if ($(‘#keks’).is(“:empty”)) {<br>    &#x2F;&#x2F;什么都没有找到;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 访问IFrame里的元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var iFrameDOM &#x3D; $(“iframe#someID”).contents();<br>&#x2F;&#x2F;然后，就可以通过find方法来遍历获取iFrame中的元素了<br>iFrameDOM.find(“.message”).slideUp();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 管理搜索框的值</span><br><span class="line">  - 现在各大网站都有搜索框，而搜索框通常都有默认值，当输入框获取焦点时，默认值消失。而一旦输入框失去焦点，而输入框里又没有输入新的值，输入框里的值又会恢复成默认值，如果往输入框里输入了新值，则输入框的值为新输入的值。这种特效用`JQuery`</span><br><span class="line">    很容易实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(“#searchbox”) .focus(function(){<br>      $(this).val(‘’)<br>}) .blur(function(){<br>     var $this &#x3D; $(this);<br>    &#x2F;&#x2F; ‘请搜索…’为搜索框默认值<br>    ($this.val() &#x3D;&#x3D;&#x3D; ‘’)? $this.val(‘请搜索…’) : null;<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 部分页面加载更新</span><br><span class="line">  - 为了提高`web`性能，有更新时我们通常不会加载整个页面，而只是仅仅更新部分页面内容，如图片的延迟加载等。页面部分刷新的特效在`JQuery`中也很容易实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>setInterval(function() {<br>&#x2F;&#x2F;每隔5秒钟刷新页面内容 &#x2F;&#x2F;获取的内容将增加到 id为content的元素后 </p>
<p>$(“#content”).load(url); }, 5000);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 采配置JQuery与其它库的兼容性</span><br><span class="line">  - 如果在项目中使用`JQuery`，`$` 是最常用的变量名，但`JQuery`并不是唯一一个使用`$`作为变量名的库，为了避免命名冲突，你可以按照下面方式来组织你的代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;方法一： 为JQuery重新命名为<br> $jvar $j &#x3D; jQuery.noConflict();$j(‘#id’)…. &#x2F;&#x2F;</p>
<p>方法二： 推荐使用的方式</p>
<p>(function($){ $(document).ready(function(){<br>     &#x2F;&#x2F;这儿，你可以正常的使用JQuery语法 });<br>})(jQuery);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 测试密码的强度</span><br><span class="line">  - 在某些网站注册时常常会要求设置密码，网站也会根据输入密码的字符特点给出相应的提示，如密码过短、强度差、强度中等、强度强等。这又是怎么实现的呢？看下面代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><input type="password" name="pass" id="pass" /> <span id="passstrength"></span><br>&#x2F;&#x2F;下面的正则表达式建议各位收藏哦，项目上有可能会用得着<br>$(‘#pass’).keyup(function(e) { </p>
<p>&#x2F;&#x2F;密码为八位及以上并且字母数字特殊字符三项都包括<br>var strongRegex &#x3D; new RegExp(“^(?&#x3D;.{8,})(?&#x3D;.<em>[A-Z])(?&#x3D;.</em>[a-z])(?&#x3D;.*[0-9])(?&#x3D;.<em>\W).</em>$”, “g”); </p>
<p>&#x2F;&#x2F;密码为七位及以上并且字母、数字、特殊字符三项中有两项，强度是中等<br> var mediumRegex &#x3D; new RegExp(“^(?&#x3D;.{7,})(((?&#x3D;.<em>[A-Z])(?&#x3D;.</em>[a-z]))|((?&#x3D;.<em>[A-Z])(?&#x3D;.</em>[0-9]))|((?&#x3D;.<em>[a-z])(?&#x3D;.</em>[0-9]))).<em>$”, “g”);<br>var enoughRegex &#x3D; new RegExp(“(?&#x3D;.{6,}).</em>“, “g”); </p>
<p>if (false &#x3D;&#x3D; enoughRegex.test($(this).val())) { </p>
<p>$(‘#passstrength’).html(‘More Characters’); }<br> else if (strongRegex.test($(this).val())) {<br>     $(‘#passstrength’).className &#x3D; ‘ok’;<br>     $(‘#passstrength’).html(‘Strong!’); }<br>else if (mediumRegex.test($(this).val())) {<br>    $(‘#passstrength’).className &#x3D; ‘alert’;<br>    $(‘#passstrength’).html(‘Medium!’); }<br> else {<br>    $(‘#passstrength’).className &#x3D; ‘error’;<br>    $(‘#passstrength’).html(‘Weak!’);<br>}<br>return true;</p>
<p>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 附录四 常见CND加速服务</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- [Bootstrap中文网开源项目免费 CDN 服务](http://www.bootcdn.cn/)</span><br><span class="line">- [百度静态资源公共库](http://cdn.code.baidu.com/)</span><br><span class="line">- [360网站卫士常用前端公共库CDN服务–已停止服务](http://libs.useso.com/)</span><br><span class="line">- [开放静态文件 CDN](http://staticfile.org/)</span><br><span class="line">- [微软CDN服务](http://www.asp.net/ajax/cdn)</span><br><span class="line">- [阿里云](https://bbs.aliyun.com/read/139395.html)</span><br><span class="line">- [百度开放云平台](http://developer.baidu.com/wiki/index.php?title=docs/cplat/libs)</span><br><span class="line">- [jQuery CDN](http://code.jquery.com/)</span><br><span class="line">- [jQuery cdn加速](http://www.jq22.com/cdn/)</span><br><span class="line">- [新浪CDN](http://lib.sinaapp.com/)</span><br><span class="line"></span><br><span class="line">#### 附录五 jQuery的一些资源</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 速查手册</span><br><span class="line"></span><br><span class="line">  - [jQuery API 中文文档–css88](http://www.css88.com/jqapi-1.9/)</span><br><span class="line">  - [jQuery-overapi](http://overapi.com/jquery)</span><br><span class="line">  - [在线桌面版API](http://www.sxt.cn/searchsxt/sxtapipro/index.html)</span><br><span class="line">  - [更多详情—一份实用的API参考手册集合](https://github.com/poetries/mywiki/blob/master/bookmark/实用参考手册API.md)</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  jQuery</span><br></pre></td></tr></table></figure>

<p>  插件</p>
<ul>
<li>基础常用<ul>
<li><a target="_blank" rel="noopener" href="http://caibaojian.com/scrollfix">滚动固定在某个位置</a></li>
<li><a target="_blank" rel="noopener" href="http://caibaojian.com/power-slider">jQuery图片滚动插件全能版</a></li>
<li><a target="_blank" rel="noopener" href="http://code.ciaoca.com/jquery/wookmark/?utm_source=caibaojian.com">jQuery Wookmark Load 瀑布流布局</a></li>
<li><a target="_blank" rel="noopener" href="http://code.ciaoca.com/jquery/jcrop/?utm_source=caibaojian.com">jQuery Jcrop 图像裁剪</a></li>
<li><a target="_blank" rel="noopener" href="http://code.ciaoca.com/jquery/kxbdmarquee/?utm_source=caibaojian.com">jQuery kxbdMarquee 无缝滚动</a></li>
<li><a target="_blank" rel="noopener" href="http://code.ciaoca.com/jquery/lightbox/?utm_source=caibaojian.com">jQuery lightBox 灯箱效果</a></li>
<li><a target="_blank" rel="noopener" href="http://www.appelsiini.net/projects/lazyload?utm_source=caibaojian.com">Lazy Load Plugin for jQuery</a></li>
</ul>
</li>
<li>更多插件-动效库整理<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/poetries/mywiki/blob/master/bookmark/%E6%8F%92%E4%BB%B6%E5%BA%93.md">插件动效库</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/poetries/mywiki/blob/master/bookmark/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.md">常用组件</a></li>
</ul>
</li>
</ul>
<h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><hr>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/aaronjs/p/3279314.html">jQuery源码分析系列</a></li>
</ul>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/12/html+css+js+ts/jQuery%E6%80%BB%E7%BB%93/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-前端性能优化-03">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/09/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8FAPI%EF%BC%88web%E6%8F%90%E4%BE%9B%EF%BC%8C%E5%8A%A8%E6%80%81%E6%B5%8B%E9%87%8F%EF%BC%89/">前端性能优化-03</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-09
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/%E4%BC%98%E5%8C%96/" class="cube-excerpt-tag-link">#优化</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="Web-Api"><a href="#Web-Api" class="headerlink" title="Web Api"></a>Web Api</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427135134108.png" alt="image-20220427135134108"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427135953185.png" alt="image-20220427135953185"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427135638721.png" alt="image-20220427135638721"></p>
<h2 id="页面渲染原理"><a href="#页面渲染原理" class="headerlink" title="页面渲染原理"></a>页面渲染原理</h2><p><strong><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140026412.png" alt="image-20220427140026412"></strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140215339.png" alt="image-20220427140215339"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140251251.png" alt="image-20220427140251251"></p>
<p>浏览器解释器  将他们翻译成浏览器认识的形式。</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140455463.png" alt="image-20220427140455463"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140508402.png" alt="image-20220427140508402"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140829766.png" alt="image-20220427140829766"></p>
<h2 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427141037729.png" alt="image-20220427141037729"></p>
<p>里纳西不断的回流：</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427141659895.png" alt="image-20220427141659895"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427141728695.png" alt="image-20220427141728695"></p>
<h2 id="fastdom"><a href="#fastdom" class="headerlink" title="fastdom"></a>fastdom</h2><p>批量对DOM的读写操作     先执行读操作  后执行写操作</p>
<p>强制布局：很卡顿（连续的强制读写更新） 但是使用了fastdom(读写分离)后执行就会流畅</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427144318668.png" alt="image-20220427144318668"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427144353664.png" alt="image-20220427144353664"></p>
<h2 id="复合线程与图层"><a href="#复合线程与图层" class="headerlink" title="复合线程与图层"></a>复合线程与图层</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427144903921.png" alt="image-20220427144903921"></p>
<p>在控制太我们通过frame就可以查看对应图层</p>
<p>这些不会触发布局和重绘，只会触发复合的过程给他们一个图层</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427145049336.png" alt="image-20220427145049336"></p>
<p>查看图层：</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427145130349.png" alt="image-20220427145130349"></p>
<p>查看交互点击第一个录制，然后停止就可以查看</p>
<p>第二个刷新只页面重新加载  。</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427145223610.png" alt="image-20220427145223610"></p>
<p>图层越多 开销也会越大。</p>
<h2 id="减少重绘"><a href="#减少重绘" class="headerlink" title="减少重绘"></a>减少重绘</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427150359238.png" alt="image-20220427150359238"></p>
<p>render：选中第一个它会告诉我们谁会重绘并且标问绿色</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427150050337.png" alt="image-20220427150050337"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427150133967.png" alt="image-20220427150133967"></p>
<h2 id="高频事件处理函数-防抖"><a href="#高频事件处理函数-防抖" class="headerlink" title="高频事件处理函数 防抖"></a>高频事件处理函数 防抖</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427150900593.png" alt="image-20220427150900593"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427151047338.png" alt="image-20220427151047338"></p>
<p>事件触发  js  触发视觉变换   1帧开始    raf在  之前进行布局和绘制，</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427150955637.png" alt="image-20220427150955637"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427151104506.png" alt="image-20220427151104506"></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/09/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8FAPI%EF%BC%88web%E6%8F%90%E4%BE%9B%EF%BC%8C%E5%8A%A8%E6%80%81%E6%B5%8B%E9%87%8F%EF%BC%89/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-js 异步处理">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/06/html+css+js+ts/3-js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/">js 异步处理</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-06
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/javascript/" class="cube-excerpt-tag-link">#javascript</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <blockquote>
<p>整理于互联网</p>
</blockquote>
<blockquote>
<ul>
<li>在<code>JavaScript</code>的世界中，所有代码都是单线程执行的</li>
<li>由于这个“缺陷”，导致<code>JavaScript</code>的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现</li>
<li>异步操作会在将来的某个时间点触发一个函数调用</li>
</ul>
</blockquote>
<ul>
<li>主流的异步处理方案主要有：回调函数<code>(CallBack)</code>、<code>Promise</code>、<code>Generator</code>函数、<code>async/await</code>。</li>
</ul>
<h2 id="一、回调函数-CallBack"><a href="#一、回调函数-CallBack" class="headerlink" title="一、回调函数(CallBack)"></a>一、回调函数(CallBack)</h2><hr>
<ul>
<li>这是异步编程最基本的方法</li>
<li>假设我们有一个 <code>getData</code> 方法，用于异步获取数据，第一个参数为请求的 <code>url</code> 地址，第二个参数是回调函数，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getData (url, callBack) &#123;</span><br><span class="line">    // 模拟发送网络请求</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        // 假设 res 就是返回的数据</span><br><span class="line">        var res = &#123;</span><br><span class="line">            url: url,</span><br><span class="line">            data: Math.random()</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行回调，将数据作为参数传递</span><br><span class="line">        callBack(res)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们预先设定一个场景，假设我们要请求三次服务器，每一次的请求依赖上一次请求的结果，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getData(&#x27;/page/1?param=123&#x27;, (res1) =&gt; &#123;</span><br><span class="line">    console.log(res1)</span><br><span class="line">    getData(`/page/2?param=$&#123;res1.data&#125;`, (res2) =&gt; &#123;</span><br><span class="line">        console.log(res2)</span><br><span class="line">        getData(`/page/3?param=$&#123;res2.data&#125;`, (res3) =&gt; &#123;</span><br><span class="line">            console.log(res3)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过上面的代码可以看出，第一次请求的 <code>url</code> 地址为：<code>/page/1?param=123</code>，返回结果为 <code>res1</code>。</li>
<li>第二个请求的 <code>url</code> 地址为：<code>/page/2?param=$&#123;res1.data&#125;</code>，依赖第<code>一次请求的</code>res1.data<code>，返回结果为</code>res2&#96;。</li>
<li>第三次请求的 <code>url</code>地址为：<code>/page/3?param=$&#123;res2.data&#125;</code>，依赖第二次请求的 <code>res2.data</code>，返回结果为 <code>res3</code>。</li>
<li>由于后续请求依赖前一个请求的结果，所以我们只能把下一次请求写到上一次请求的回调函数内部，这样就形成了常说的：回调地狱。</li>
</ul>
<h2 id="二、发布-x2F-订阅"><a href="#二、发布-x2F-订阅" class="headerlink" title="二、发布&#x2F;订阅"></a>二、发布&#x2F;订阅</h2><blockquote>
<p>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（<code>publish</code>）一个信号，其他任务可以向信号中心”订阅”（<code>subscribe</code>）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布&#x2F;订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）</p>
</blockquote>
<ul>
<li>这个模式有多种实现，下面采用的是Ben Alman的<a target="_blank" rel="noopener" href="https://gist.github.com/661855">Tiny Pub&#x2F;Sub</a>，这是<code>jQuery</code>的一个插件</li>
<li>首先，<code>f2</code>向”信号中心”<code>jQuery</code>订阅”<code>done</code>“信号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(&quot;done&quot;, f2);</span><br></pre></td></tr></table></figure>

<ul>
<li>f1进行如下改写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">　　　　setTimeout(function () &#123;</span><br><span class="line">　　　　　　// f1的任务代码</span><br><span class="line">　　　　　　jQuery.publish(&quot;done&quot;);</span><br><span class="line">　　　　&#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>jQuery.publish(&quot;done&quot;)</code>的意思是，<code>f1</code>执行完成后，向”信号中心<code>&quot;jQuery</code>发布<code>&quot;done&quot;</code>信号，从而引发f2的执行。 此外，f2完成执行后，也可以取消订阅（<code>unsubscribe</code>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.unsubscribe(&quot;done&quot;, f2);</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</li>
</ul>
<h2 id="三、Promise"><a href="#三、Promise" class="headerlink" title="三、Promise"></a>三、Promise</h2><hr>
<blockquote>
<ul>
<li><code>Promise</code> 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大</li>
<li>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<code>Promise</code> 提供统一的 <code>API</code>，各种异步操作都可以用同样的方法进行处理</li>
</ul>
</blockquote>
<ul>
<li>简单说，它的思想是，每一个异步任务返回一个<code>Promise</code>对象，该对象有一个<code>then</code>方法，允许指定回调函数。</li>
<li>现在我们使用 <code>Promise</code> 重新实现上面的案例，首先，我们要把异步请求数据的方法封装成 <code>Promise</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getDataAsync (url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            var res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: Math.random()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>那么请求的代码应该这样写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getDataAsync(&#x27;/page/1?param=123&#x27;)</span><br><span class="line">    .then(res1 =&gt; &#123;</span><br><span class="line">        console.log(res1)</span><br><span class="line">        return getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(res2 =&gt; &#123;</span><br><span class="line">        console.log(res2)</span><br><span class="line">        return getDataAsync(`/page/3?param=$&#123;res2.data&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(res3 =&gt; &#123;</span><br><span class="line">        console.log(res3)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>then</code> 方法返回一个新的 <code>Promise</code> 对象，<code>then</code> 方法的链式调用避免了 <code>CallBack</code> 回调地狱</li>
<li>但也并不是完美，比如我们要添加很多 <code>then</code> 语句， 每一个 <code>then</code> 还是要写一个回调。</li>
<li>如果场景再复杂一点，比如后边的每一个请求依赖前面所有请求的结果，而不仅仅依赖上一次请求的结果，那会更复杂。 为了做的更好，<code>async/await</code> 就应运而生了，来看看使用 <code>async/await</code> 要如何实现</li>
</ul>
<h2 id="四、async-x2F-await"><a href="#四、async-x2F-await" class="headerlink" title="四、async&#x2F;await"></a>四、async&#x2F;await</h2><hr>
<ul>
<li><p><code>await</code>后面必须是一个<code>Promise</code>对象</p>
</li>
<li><p><code>getDataAsync</code> 方法不变，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> function getDataAsync (url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            var res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: Math.random()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>业务代码如下</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function getData () &#123;</span><br><span class="line">    var res1 = await getDataAsync(&#x27;/page/1?param=123&#x27;)</span><br><span class="line">    console.log(res1)</span><br><span class="line">    var res2 = await getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)</span><br><span class="line">    console.log(res2)</span><br><span class="line">    var res3 = await getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)</span><br><span class="line">    console.log(res3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到使用<code>async\await</code>就像写同步代码一样</li>
<li>对比 <code>Promise</code> 感觉怎么样？是不是非常清晰，但是 <code>async/await</code> 是基于 <code>Promise</code> 的，因为使用 <code>async</code>修饰的方法最终返回一个 <code>Promise</code>， 实际上，<code>async/await</code> 可以看做是使用 <code>Generator</code> 函数处理异步的语法糖，我们来看看如何使用 <code>Generator</code> 函数处理异步</li>
</ul>
<h2 id="五、Generator"><a href="#五、Generator" class="headerlink" title="五、Generator"></a>五、Generator</h2><hr>
<ul>
<li>首先异步函数依然是</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getDataAsync (url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            var res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: Math.random()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>Generator</code> 函数可以这样写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function * getData () &#123;</span><br><span class="line">    var res1 = yield getDataAsync(&#x27;/page/1?param=123&#x27;)</span><br><span class="line">    console.log(res1)</span><br><span class="line">    var res2 = yield getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)</span><br><span class="line">    console.log(res2)</span><br><span class="line">    var res3 = yield getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)</span><br><span class="line">    console.log(res3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后我们这样逐步执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var g = getData()</span><br><span class="line">g.next().value.then(res1 =&gt; &#123;</span><br><span class="line">    g.next(res1).value.then(res2 =&gt; &#123;</span><br><span class="line">        g.next(res2).value.then(() =&gt; &#123;</span><br><span class="line">            g.next()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码，我们逐步调用遍历器的 <code>next()</code> 方法，由于每一个 <code>next()</code> 方法返回值的 <code>value</code> 属性为一个 <code>Promise</code>对象</li>
<li>所以我们为其添加 <code>then</code> 方法， 在 <code>then</code> 方法里面接着运行 <code>next</code> 方法挪移遍历器指针，直到 <code>Generator</code>函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function run (gen) &#123;</span><br><span class="line">    var g = gen()</span><br><span class="line"></span><br><span class="line">    function next (data) &#123;</span><br><span class="line">        var res = g.next(data)</span><br><span class="line">        if (res.done) return res.value</span><br><span class="line">        res.value.then((data) =&gt; &#123;</span><br><span class="line">            next(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>run 方法用来自动运行异步的 Generator 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 Generator 函数了。 有了 run 方法，我们只需要这样运行 getData 方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(getData)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样，我们就可以把异步操作封装到 <code>Generator</code> 函数内部，使用 <code>run</code> 方法作为 <code>Generator</code> 函数的自执行器，来处理异步。其实我们不难发现， <code>async/await</code> 方法相比于 <code>Generator</code> 处理异步的方式，有很多相似的地方，只不过 <code>async/await</code> 在语义化方面更加明显，同时 <code>async/await</code> 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 <code>async/await</code> 是 <code>Generator</code> 函数处理异步的语法糖了</p>
</blockquote>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/06/html+css+js+ts/3-js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-前端性能优化-02">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/02%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8BRAIL%E6%B5%8B%E9%87%8F/">前端性能优化-02</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-02
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/%E4%BC%98%E5%8C%96/" class="cube-excerpt-tag-link">#优化</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="什么是RAIL："><a href="#什么是RAIL：" class="headerlink" title="什么是RAIL："></a>什么是RAIL：</h2><p>缩写每一个字母表示一个性能指标</p>
<p>Response：响应  对用户而言用户点击有没有即使访问</p>
<p>Animation：动画 给用户的体验好。会不会出现卡顿</p>
<p>Idie：空闲 有足够的空闲时间才能够进行响应交互   不让他始终处于繁忙的时间，不然无法处理其他请求</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427100359004.png" alt="image-20220427100359004"></p>
<p>Load：加载 资源网络加载的时间</p>
<p><strong>RAIL目标</strong></p>
<p><strong>评估指标</strong></p>
<p>响应：处理时间应在50ms以内完成</p>
<p>动画：没10ms产生一帧</p>
<p>空闲：尽可能增加空闲时间</p>
<p>加载：在5s内完成内容加载并可以交互</p>
<p>逐步发现问题解决问题</p>
<p>性能测量工具</p>
<p>Chrome DevTools 开发者调试工具，性能评测</p>
<p>Lighthouse 网站整体质量评估</p>
<p>WebPageTest 多测量地点、全面行能报告（通过 它的问斩对自己的网站就行进行评估）</p>
<h2 id="WenPageTest"><a href="#WenPageTest" class="headerlink" title="WenPageTest"></a><strong>WenPageTest</strong></h2><p>webpagetest.org</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427101136898.png" alt="image-20220427101136898"></p>
<p>用户首次方位  第二次访问  （第一次对一些静态资源做缓存）</p>
<p>录视频</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427101340209.png" alt="image-20220427101340209"></p>
<p>测试结果：</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427101426225.png" alt="image-20220427101426225"></p>
<p>第一次加载，首屏渲染，</p>
<p>speed 速度指数等</p>
<p>图片并行加载  时间有加载最长时间决定</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103510108.png" alt="image-20220427103510108"></p>
<p>高亮（重定向了）  可以优化  直接去访问重定向后的位置</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103527654.png" alt="image-20220427103527654"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103716493.png" alt="image-20220427103716493"></p>
<p>前提：docker</p>
<p>docker pull webpagetest&#x2F;server</p>
<p>docker pull webpagetest&#x2F;a</p>
<p>docker run -d -p 4000:80 webpagetest&#x2F;server</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103841249.png" alt="image-20220427103841249"></p>
<p>自定义镜像</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103951183.png" alt="image-20220427103951183"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103923723.png" alt="image-20220427103923723"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103940202.png" alt="image-20220427103940202"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104025309.png" alt="image-20220427104025309"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104016148.png" alt="image-20220427104016148"></p>
<p>打包</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104104578.png" alt="image-20220427104104578"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104110269.png" alt="image-20220427104110269"></p>
<p>这样就可以本地测试了。</p>
<h2 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a>Lighthouse</h2><p>npm install -g lighthouse</p>
<p>lighthouse 测试网站地址</p>
<p>自动打开一个浏览器窗口</p>
<p>生成而是报告到本地</p>
<p>打开即可查看</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104412546.png" alt="image-20220427104412546"></p>
<p>第一个有意义的内容</p>
<p>什么时候用户可以交互了</p>
<p>用户访问过程截屏。</p>
<p>Opportunity：告诉我们还可以做些什么做到了可以提升那些多长时间</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104938078.png" alt="image-20220427104938078"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427105002256.png" alt="image-20220427105002256"></p>
<p>可以指定什么样的资源不进行加载。</p>
<h2 id="Chrome-devtool调试"><a href="#Chrome-devtool调试" class="headerlink" title="Chrome devtool调试"></a>Chrome devtool调试</h2><p>Network：</p>
<p>资源名称  大小   耗时</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427133838888.png" alt="image-20220427133838888"></p>
<p>对请求资源进行压缩在返回前端</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427134024090.png" alt="image-20220427134024090"></p>
<p>实际大小 parse  1.4MB   网络传输（index）55kb</p>
<p>Performance：</p>
<p>开始出现性能分析：可以定位出导致长任务（耗费时间长）的方法。</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427134236511.png" alt="image-20220427134236511"></p>
<p>主线程任务。</p>
<p>Disabel cache缓存。 Online：选择网络</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427134610044.png" alt="image-20220427134610044"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427134719082.png" alt="image-20220427134719082"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427134737203.png" alt="image-20220427134737203"></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/02%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8BRAIL%E6%B5%8B%E9%87%8F/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-前端性能优化-01">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/02/26/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/01%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0/">前端性能优化-01</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-02-26
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/%E4%BC%98%E5%8C%96/" class="cube-excerpt-tag-link">#优化</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p><strong>平凡程序员和大牛程序员、架构师的分水岭</strong></p>
<p><strong>怎样做出高性能的工程，达到大厂产品水平</strong></p>
<p><strong>只是储配，动手实战</strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427093826921.png" alt="image-20220427093826921"></p>
<p><strong>优化标准“</strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427093854500.png" alt="image-20220427093854500"></p>
<p><strong>学习体系</strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427093906855.png" alt="image-20220427093906855"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094119486.png" alt="image-20220427094119486"></p>
<p>一、为什么要进行性能优化</p>
<p>性能-web网站和应用的支柱</p>
<p>网站性能对用户很重要</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094359679.png" alt="image-20220427094359679"></p>
<p><strong>寻找性能瓶颈</strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094506838.png" alt="image-20220427094506838"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094612815.png" alt="image-20220427094612815"></p>
<p><strong>性能指标和性能优化</strong></p>
<p>性能指标：</p>
<p>Network  (页面清空缓存 ，重新加载，查看)</p>
<p>请求数量  资源量   Dom加载时间   混合资源加载时间</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094837633.png" alt="image-20220427094837633"></p>
<p>瀑布图：</p>
<p>请求前资源排队，dns解析，连接，SSL协商</p>
<p>发送：TTFB（用户体验和他有大多数关系）   下载（资源大小）  资源进行并行加载（不阻塞）</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094932008.png" alt="image-20220427094932008"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095003259.png" alt="image-20220427095003259"></p>
<p>右键下载查看  进行性能分析</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095231244.png" alt="image-20220427095231244"></p>
<p>性能测量工具：</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095256620.png" alt="image-20220427095256620"></p>
<p>first C …：页面出现数据的时间</p>
<p>Speed Index：速度指数（标准为4s）</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095310577.png"></p>
<p>交互性：</p>
<p>画面流畅（帧数问题）</p>
<p>查看查看帧数变化工具：最后一项</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095707388.png" alt="image-20220427095707388"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095839003.png" alt="image-20220427095839003"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095911447.png" alt="image-20220427095911447"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095937536.png" alt="image-20220427095937536"></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/02/26/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/01%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-vue-组件和插件的区别">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/01/15/Vue/vue-%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/">vue-组件和插件的区别</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-01-15
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/vue/" class="cube-excerpt-tag-link">#vue</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、组件是什么"><a href="#一、组件是什么" class="headerlink" title="一、组件是什么"></a>一、组件是什么</h2><p>回顾以前对组件的定义：</p>
<p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件</p>
<p>组件的优势</p>
<ul>
<li>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li>
<li>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li>
<li>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li>
</ul>
<h2 id="二、插件是什么"><a href="#二、插件是什么" class="headerlink" title="二、插件是什么"></a>二、插件是什么</h2><p>插件通常用来为 <code>Vue</code> 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p>
<ul>
<li>添加全局方法或者属性。如: <code>vue-custom-element</code></li>
<li>添加全局资源：指令&#x2F;过滤器&#x2F;过渡等。如 <code>vue-touch</code></li>
<li>通过全局混入来添加一些组件选项。如<code>vue-router</code></li>
<li>添加 <code>Vue</code> 实例方法，通过把它们添加到 <code>Vue.prototype</code> 上实现。</li>
<li>一个库，提供自己的 <code>API</code>，同时提供上面提到的一个或多个功能。如<code>vue-router</code></li>
</ul>
<h2 id="三、两者的区别"><a href="#三、两者的区别" class="headerlink" title="三、两者的区别"></a>三、两者的区别</h2><p>两者的区别主要表现在以下几个方面：</p>
<ul>
<li>编写形式</li>
<li>注册形式</li>
<li>使用场景</li>
</ul>
<h3 id="编写形式"><a href="#编写形式" class="headerlink" title="编写形式"></a>编写形式</h3><h4 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h4><p>编写一个组件，可以有很多方式，我们最常见的就是<code>vue</code>单文件的这种格式，每一个<code>.vue</code>文件我们都可以看成是一个组件</p>
<p><code>vue</code>文件标准格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>我们还可以通过<code>template</code>属性来编写一个组件，如果组件内容多，我们可以在外部定义<code>template</code>组件内容，如果组件内容并不多，我们可直接写在<code>template</code>属性上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=<span class="string">&quot;testComponent&quot;</span>&gt;     <span class="comment">// 组件显示的内容</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>component!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>   </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;componentA&#x27;</span>,&#123; </span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;#testComponent&#x27;</span>  </span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;component&lt;/div&gt;`</span>  <span class="comment">// 组件内容少可以通过这种形式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h4><p><code>vue</code>插件的实现应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">myGlobalMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params">methodOptions</span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册形式"><a href="#注册形式" class="headerlink" title="注册形式"></a>注册形式</h3><h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><p><code>vue</code>组件注册主要分为全局注册与局部注册</p>
<p>全局注册通过<code>Vue.component</code>方法，第一个参数为组件的名称，第二个参数为传入的配置项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>局部注册只需在用到的地方通过<code>components</code>属性注册一个组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component1 = &#123;...&#125; <span class="comment">// 定义一个组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="attr">components</span>:&#123;</span><br><span class="line">		component1   <span class="comment">// 局部注册</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插件注册"><a href="#插件注册" class="headerlink" title="插件注册"></a>插件注册</h4><p>插件的注册通过<code>Vue.use()</code>的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(插件名字,&#123; <span class="comment">/* ... */</span>&#125; )</span><br></pre></td></tr></table></figure>

<p>注意的是：</p>
<p>注册插件的时候，需要在调用 <code>new Vue()</code> 启动应用之前完成</p>
<p><code>Vue.use</code>会自动阻止多次注册相同插件，只会注册一次</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>具体的其实在插件是什么章节已经表述了，这里在总结一下</p>
<p>组件 <code>(Component)</code> 是用来构成你的 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code></p>
<p>插件 <code>(Plugin)</code> 是用来增强你的技术栈的功能模块，它的目标是 <code>Vue</code> 本身</p>
<p>简单来说，插件就是指对<code>Vue</code>的功能的增强或补充</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/01/15/Vue/vue-%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack与其他打包工具的区别">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/12/12/webpack/webpack%E4%B8%8E%E5%85%B6%E4%BB%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8C%BA%E5%88%AB/">webpack与其他打包工具的区别</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-12-12
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、模块化工具"><a href="#一、模块化工具" class="headerlink" title="一、模块化工具"></a>一、模块化工具</h2><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式</p>
<p>可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(<code>bundle</code>)</p>
<p>在前端领域中，并非只有<code>webpack</code>这一款优秀的模块打包工具，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code></p>
<p>通过这些模块打包工具，能够提高我们的开发效率，减少开发成本</p>
<p>这里没有提及<code>gulp</code>、<code>grunt</code>是因为它们只是定义为构建工具，不能类比</p>
<h3 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h3><p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup</code>要小巧的多</p>
<p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/messages.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">hi</span>: <span class="string">&#x27;Hey Guys, I am zce~&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/logger.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">log</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- INFO ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------------------------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">error</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;---------- ERROR ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;---------------------------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;./logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> messages <span class="keyword">from</span> <span class="string">&#x27;./messages&#x27;</span></span><br><span class="line"><span class="title function_">log</span>(messages.<span class="property">hi</span>)</span><br></pre></td></tr></table></figure>

<p>然后通过<code>rollup</code>进行打包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx rollup ./src/index.<span class="property">js</span> --file ./dist/bundle.<span class="property">js</span></span><br></pre></td></tr></table></figure>

<p>打包结果如下图<img src="https://static.vue-js.com/8fe07830-b143-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>可以看到，代码非常简洁，完成不像<code>webpack</code>那样存在大量引导代码和模块函数</p>
<p>并且<code>error</code>方法由于没有被使用，输出的结果中并无<code>error</code>方法，可以看到，<code>rollup</code>默认开始<code>Tree-shaking</code> 优化输出结果</p>
<p>因此，可以看到<code>Rollup</code>的优点：</p>
<ul>
<li>代码效率更简洁、效率更高</li>
<li>默认支持 Tree-shaking</li>
</ul>
<p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup</code>需要使用插件去完成</p>
<p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p>
<p>但是在用于打包<code>JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略</p>
<h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p>
<p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以任意类型文件作为打包入口，但建议使用<code>HTML</code>文件作为入口，该<code>HTML</code>文件像平时一样正常编写代码、引用资源。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ./src/index.<span class="property">html</span> --&gt;</span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Parcel Tutorials<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>main.js文件通过<code>ES Moudle</code>方法导入其他模块成员</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;./logger&#x27;</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;hello parcel&#x27;</span>)</span><br><span class="line"><span class="comment">// ./src/logger.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">log</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- INFO ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后，使用命令打包</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx parcel src/index.html</span><br></pre></td></tr></table></figure>

<p>执行命令后，<code>Parcel</code>不仅打包了应用，同时也启动了一个开发服务器，跟<code>webpack Dev Server</code>一样</p>
<p>跟<code>webpack</code>类似，也支持模块热替换，但用法更简单</p>
<p>同时，<code>Parcel</code>有个十分好用的功能：支持自动安装依赖，像<code>webpack</code>开发阶段突然使用安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程</p>
<p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code></p>
<p>打包命令如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx parcel src/index.html</span><br></pre></td></tr></table></figure>

<p>由于打包过程是多进程同时工作，构建速度会比<code>Webpack</code> 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中</p>
<p><img src="https://static.vue-js.com/ec17e7a0-b1a2-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>可以感受到，<code>Parcel</code>给开发者一种很大的自由度，只管去实现业务代码，其他事情用<code>Parcel</code>解决</p>
<h3 id="Snowpack"><a href="#Snowpack" class="headerlink" title="Snowpack"></a>Snowpack</h3><p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验</p>
<p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件</p>
<p>下图给出<code>webpack</code>与<code>snowpack</code>打包区别：</p>
<p><img src="https://static.vue-js.com/79197830-b1a3-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新</p>
<h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p>
<p>它主要由两部分组成：</p>
<ul>
<li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR</li>
<li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li>
</ul>
<p>其作用类似<code>webpack</code>+ <code>webpack-dev-server</code>，其特点如下：</p>
<ul>
<li>快速的冷启动</li>
<li>即时的模块热更新</li>
<li>真正的按需编译</li>
</ul>
<p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p>
<p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p>
<p>原理图如下所示：</p>
<p><img src="https://static.vue-js.com/9f2eed30-b143-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>相比上述的模块化工具，<code>webpack</code>大而全，很多常用的功能做到开箱即用。有两大最核心的特点：<strong>一切皆模块</strong>和<strong>按需加载</strong></p>
<p>与其他构建工具相比，有如下优势：</p>
<ul>
<li>智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容</li>
<li>万物模块：对 js、css、图片等资源文件都支持打包</li>
<li>开箱即用：HRM、Tree-shaking等功能</li>
<li>代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li>
<li>插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性</li>
<li>易于调试：支持 SourceUrls 和 SourceMaps</li>
<li>快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li>
<li>生态环境好：社区更丰富，出现的问题更容易解决</li>
</ul>
<ol>
<li>除了Webpack外，你还了解哪些模块管理工具<br> webpack:<br> 就目前而言，webpack已是最常用的打包工具，webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。<br> gulp：<br> gulp是一个前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task，第一task处理的事情（如代码压缩，合并，编译以及浏览器实时更新等）。然后定义这些执行顺序，来让glup执行这些task，从而构建项目的整个开发流程。自动化构建工具并不能把所有的模块打包到一起，也不能构建不同模块之间的依赖关系。</li>
</ol>
<p>  grunt：<br>  是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。<br>  Rollup</p>
<ol start="2">
<li>Rollup 是一款 ES Modules 打包器， 从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要小巧的多<br> 现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等<br> Parcel<br> Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序<br> Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用		HTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。<br> 模块化是一种处理复杂系统分解为更好的可管理模块的方式。可以用来分割、组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体。<br> 在前端领域中，除了Webpack外，比较流行的模块打包工具还包括Rollup、Parcel、snowpack和最近风靡的Vite。</li>
</ol>
<p>  2.1. Rollup<br>  Rollup 是一款 ES Modules 打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多。现在很多苦都使用它进行打包，比如：Vue、React和three.js等。<br>  使用之前，可以使用npm install –global rollup 命令进行安装。Rollup 可以通过命令行接口(command line interface)配合可选配置文件(optional configuration file)来调用，或者可以通过 JavaScript API来调用。运行 rollup –help 可以查看可用的选项和参数。<br>  2.2. Parcel<br>  Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序。<br>  2.3.  Vite<br>  Vite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。<br>  Vite具有以下特点： - 快速的冷启动 - 即时热模块更新（HMR，Hot Module Replacement） - 真正按需编译<br>  Vite由两部分组成： - 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR。 - 一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。<br>  Vite在开发阶段可以直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块的时候，根据需要对模块的内容进行编译，大大缩短了编译时间。工作原理如下图所示。<br>  在热模块HMR方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像Webpack那样需要把该模块的相关依赖模块全部编译一次，因此效率也更高。<br>3. webpack，rollup，parcel优劣？(了解)<br>    对比</p>
<p>  Webpack<br>  Rollup<br>  Parcel<br>  功能</p>
<p>为处理资源管理和分割代码而生，可以用来处理任何类型的文件，灵活，插件多。<br>    用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。<br>    用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。<br>配置<br>    webpack需要配config文件，指明entry, output, plugin，transformations。<br>    rollup需要配config文件，指明entry, output, plugin，transformations。rollup 有对import&#x2F;export所做的node polyfills，webpack没有。rollup支持相对路径，而webpack没有，所以得使用</p>
<pre><code>parcel则是完全开箱可用的，不用配置。
</code></pre>
<p>入口文件<br>    webpack只支持js文件作为入口文件，如果要以其他格式的文件作为入口，比如html文件为入口，如要加第三方Plugin。<br>    rollup可以用html作为入口文件，但也需要plugin，比如rollup-plugin-html-entry。<br>    parcel可以用index.html作为入口文件，而且它会通过看index.html的script tag里包含的什么自己找到要打包生成哪些js文件。<br>transformations<br>    transformations指的是把其他文件转化成js文件的过程，需要经过transformation才能够被打包。webpack使用Loaders来处理。<br>    rollup使用plugins来处理。<br>    parcel会自动去转换，当找到配置文件比如.babelrc, .postcssrc后就会自动转。<br>摇树优化<br>    摇树优化是webpack的一大特性。需要1，用import&#x2F;export语法，2，在package.json中加副作用的入口，3，加上支持去除死代码的缩小器（uglifyjsplugin）。<br>    rollup会统计引入的代码并排除掉那些没有被用到的。这使您可以在现有工具和模块的基础上构建，而无需添加额外的依赖项或膨胀项目的大小。<br>    parcel不支持摇树优化。<br>dev server<br>    webpack用webpack-dev-server。<br>rollup用rollup-plugin-serve和rollup-plugin-livereload共同作用。<br>    parcel内置的有dev server<br>热更新<br>    webpack的 wepack-dev-server支持hot模式。<br>    rollup不支持hmr。<br>    parcel有内置的hmr。<br>代码分割<br>    webpack通过在entry中手动设置，使用CommonsChunkPlugin，和模块内的内联函数动态引入来做代码分割。<br>    rollup有实验性的代码分割特性。它是用es模块在浏览器中的模块加载机制本身来分割代码的。需要把experimentalCodeSplitting 和 experimentalDynamicImport 设为true。<br>    parcel支持0配置的代码分割。主要是通过动态improt。</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/12/12/webpack/webpack%E4%B8%8E%E5%85%B6%E4%BB%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8C%BA%E5%88%AB/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack模块联邦">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/12/07/webpack/webpack%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/">webpack模块联邦</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-12-07
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。<br>这通常被称作微前端，但并不仅限于此。<br>Webpack5 模块联邦可以让 Webpack 达到了线上 Runtime 的效果，让代码直接在项目间利用 CDN 直接共享，不再需要本地安装 Npm 包、构建再发布了！<br>我们知道 Webpack 可以通过 DLL 或者 Externals 做代码共享时 Common Chunk，但不同应用和项目间这个任务就变得困难了，我们几乎无法在项目之间做到按需热插拔。</p>
<p>早期NPM方式共享模块   代码的共享是将依赖作为library安装到我们的项目里进行webpack打包并且构建上线<br>对于项目 Home 与 Search，需要共享一个模块时，最常见的办法就是将其抽成通用依赖并分别安装在各自项目中。虽然 Monorepo 可以一定程度解决重复安装和修改困难的问题，但依然需要走本地编译。</p>
<p>真正 Runtime 的方式可能是 UMD 方式共享代码模块，即将模块用 Webpack UMD模式打包，并输出到其他项目中。这是非常普遍的模块共享方式：<br>对于项目 Home 与 Search，直接利用 UMD 包复用一个模块。但这种技术方案问题也很明显，就是包体积无法达到本地编译时的优化效果，且库之间容易冲突。</p>
<p>微前端：micro-frontends (MFE) 也是最近比较火的模块共享管理方式，微前端就是要解决多项目并存问题，多项目并存的最大问题就是模块共享，模块之间是不能有冲突。  对于微前端我们还要考虑样式冲突，声明周期管理冲突等问题，我们先不考虑这些   想把问题聚焦在资源加载的方式上   微前端一般有两种打包方式：1.子应用独立打包，模块实现解耦，但这种方式无法抽取公共的依赖，2.整体应用打一个打包 很好的解决我们上面第一种方式的问题，但是打包效率速度实在是太慢了。不具备水平的扩展能力。<br>由于微前端还要考虑样式冲突、生命周期管理，所以本文只聚焦在资源加载方式上。微前端一般有两种打包方式：</p>
<ol>
<li>子应用独立打包，模块更解耦，但无法抽取公共依赖等。</li>
<li>整体应用一起打包，很好解决上面的问题，但打包速度实在是太慢了，不具备水平扩展能力。</li>
</ol>
<p>终于提到本文的主角了，模块联邦方式作为 Webpack5 内置核心特性之一的 FederatedModule：<br>这个方案是直接将一个应用的包应用于另一个应用，同时具备整体应用一起打包的公共依赖抽取能力。  比如：我们直接可以在Search应用里直接使用已经发布到线上的Home应用的组件。</p>
<p><strong>应用案例</strong><br>本案例模拟三个应用： Nav 、 Search 及 Home 。每个应用都是独立的，又通过模块邦联系到了一起。<br>比如Home需要使用Nav组件共享出来的header，Search可能要使用Header和Home组件构建出来的HomeList。<br>模块联邦将他们共享的模块暴露出来进行引用。<br>1、Nav 导航<br>src&#x2F;header.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Header = () =&gt; &#123;</span><br><span class="line"> const header = document.createElement(&#x27;h1&#x27;)</span><br><span class="line"> header.textContent = &#x27;公共头部内容&#x27;</span><br><span class="line"> return header</span><br><span class="line">&#125;</span><br><span class="line">export default Header</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Header from &#x27;./Header&#x27;</span><br><span class="line">const div = document.createElement(&#x27;div&#x27;)</span><br><span class="line">div.appendChild(Header())</span><br><span class="line">document.body.appendChild(div)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   // 模块联邦名字</span><br><span class="line">   name: &#x27;nav&#x27;,</span><br><span class="line">   // 外部访问的资源名字</span><br><span class="line">   filename: &#x27;remoteEntry.js&#x27;,</span><br><span class="line">   // 引用的外部资源列表</span><br><span class="line">   remotes: &#123;&#125;,</span><br><span class="line">   // 暴露给外部资源列表</span><br><span class="line">   exposes: &#123;</span><br><span class="line">    &#x27;./Header&#x27;: &#x27;./src/Header.js&#x27;,   // 暴露 Header组件  key：可以定义成./Header 这个./Header并不代表是我当前引用下的某个路径   而是将来在别人用的时候基于这个路径来拼接url，值是正真的我们本地项目的应用</span><br><span class="line">  &#125;,</span><br><span class="line">   // 共享模块，如lodash</span><br><span class="line">   shared: &#123;&#125;,   // 如果我们的 header模块里有共享的第三方模块比如：lodash等，我们可以把他放到这里在打包的时候可以把第三方的共享的模块打到单独的一个包里。</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3003</span><br></pre></td></tr></table></figure>

<p>2、Home 首页<br>src&#x2F;HomeList</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const HomeList = (num) =&gt; &#123;</span><br><span class="line"> let str = &#x27;&lt;ul&gt;&#x27;</span><br><span class="line"> for (let i = 0; i &lt; num; i++) &#123;</span><br><span class="line">  str += &#x27;&lt;li&gt;item &#x27; + i + &#x27;&lt;/li&gt;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"> str += &#x27;&lt;/ul&gt;&#x27;</span><br><span class="line"> return str</span><br><span class="line">&#125;</span><br><span class="line">export default HomeList</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import HomeList from &#x27;./HomeList&#x27;</span><br><span class="line">remotes: &#123;</span><br><span class="line">    nav</span><br><span class="line">	(&#x27;nav/Header&#x27;)：remotes: &#123; nav &#125;Header    exposes: &#123;./Header&#x27;:&#x27;&#x27;&#125;</span><br><span class="line">import(&#x27;nav/Header&#x27;).then((Header) =&gt; &#123;  //引用模块联邦的组件  这样导入别人组件的时候需要通过异步的方式因为 网络共享或者是模块载入 是由延迟的，所以要通过promise的方式（异步模块加载的形式）去引用它。</span><br><span class="line"> const body = document.createElement(&#x27;div&#x27;)</span><br><span class="line"> body.appendChild(Header.default())</span><br><span class="line"> document.body.appendChild(body)</span><br><span class="line"> document.body.innerHTML += HomeList(5)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   name: &quot;home&quot;,</span><br><span class="line">   filename: &quot;remoteEntry.js&quot;,</span><br><span class="line">   remotes: &#123;</span><br><span class="line">    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,    // 引用第三方或别人写好的应用的路径。远端的服务路径</span><br><span class="line">  &#125;,</span><br><span class="line">   exposes: &#123;</span><br><span class="line">    &#x27;./HomeList&#x27;: &#x27;./src/HomeList.js&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   shared: &#123;&#125;,</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3001</span><br></pre></td></tr></table></figure>

<p>3、search 搜索<br>src&#x2F;index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([import(&#x27;nav/Header&#x27;), import(&#x27;home/HomeList&#x27;)])</span><br><span class="line">.then(([&#123;</span><br><span class="line">  default: Header</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  default: HomeList</span><br><span class="line">&#125;]) =&gt; &#123;</span><br><span class="line">  document.body.appendChild(Header())</span><br><span class="line">  document.body.innerHTML += HomeList(4)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   name: &#x27;search&#x27;,</span><br><span class="line">   filename: &#x27;remoteEntry.js&#x27;,</span><br><span class="line">   remotes: &#123;</span><br><span class="line">    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,</span><br><span class="line">    home: &quot;home@http://localhost:3001/remoteEntry.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">   exposes: &#123;&#125;,</span><br><span class="line">   shared: &#123;&#125;,</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3002</span><br></pre></td></tr></table></figure>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/12/07/webpack/webpack%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/">Read More</a>
    </footer>
</div>



<ul class="cube-pagination cube-pagination-9">
    
    <li class="cube-pagination-prev">
        <a href="/page/3/">« Prev</a>
    </li>
    
    
        
                <li class="cube-pagination-index">
                    <a href="/">1</a>
                </li>
                <li class="cube-pagination-ellipses">
                    <span>...</span>
                </li>
            
                
                <li class="cube-pagination-index">
                    <a href="/page/3">3</a>
                </li>
                
            
                
                <li class="cube-pagination-index disabled">
                    <span>4</span>
                </li>
                
            
                
                <li class="cube-pagination-index">
                    <a href="/page/5">5</a>
                </li>
                
            
                <li class="cube-pagination-ellipses">
                    <span>...</span>
                </li>
                <li class="cube-pagination-index">
                    <a href="/page/19">19</a>
                </li>
        
    

    
    <li class="cube-pagination-next">
        <a href="/page/5/">Next »</a>
    </li>
    
</ul>

<!--其他组件后续添加-->
        </div>
        <div class="cube-right">
            

<div class="cube-search cube-sidebar" id="cube-search">
    <div class="search-container">
        <input type="text" placeholder="Search" class="cube-search-input" id="cube-search-input">
        <i class="cube-icon cube-icon-search cube-search-submit" aria-hidden="true"></i>
    </div>
    <!-- TODO 通过给window赋一个全局变量，通过脚本赋值 -->
</div>
<script>
    (function (window) {
        'use strict';
        window.searchModule = {}
        window.searchModule.JSONUrl = '/content.json'
        window.searchModule.rootUrl = '/'
    })(window)
</script>
<div class="cube-search-form">
    <div class="cube-search-control">
        <input type="text" placeholder="Search" class="search-input">
        <a class="close-button">
            <i class="cube-icon cube-close" aria-hidden="true"></i>
        </a>
    </div>
    <div class="cube-search-result"></div>
</div>


<div class="cube-author cube-sidebar" id="cube-author">
    
    
    <span>John Doe</span>
    
    
    <div class="count">
        <a class="count articles"><span>186</span>Article</a>
        <a class="count tags"><span>35</span>Tags</a>
        <a class="count categories"><span>23</span>Categories</a>
    </div>
</div>



<div class="cube-music cube-sidebar" id="cube-music">
    <div class="cube-player aplayer" id="cube-player"></div>
</div>
<script>
    (function (window) {
        window.musicModule = {}
        window.musicModule.musicConfig = '{"narrow":false,"autoplay":false,"showlrc":3,"theme":"#b7daff","mutex":true,"mode":"circulation","preload":"auto","listmaxheight":"513px","music":[{"title":"Dear friends","author":"TRIPLANE","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/TRIPLANE - Dear friends.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Dear friends - TRIPLANE.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/TRIPLANE - Dear friends.jpg"},{"title":"Butter-Fly","author":"和田光司","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/和田光司 - Butter-Fly (ピアノヴァージョン).mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Butter-Fly (ピアノヴァージョン) - 和田光司.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/和田光司 - Butter-Fly (ピアノヴァージョン).jpg"},{"title":"宵闇花火","author":"葉月ゆら","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/葉月ゆら - 宵闇花火.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/宵闇花火 - 葉月ゆら.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/葉月ゆら - 宵闇花火.jpg"}]}'
        window.musicModule.lrcConfig = {
            open: 'Open Lyrics',
            close: 'Close Lyrics'
        }
    })(window)
</script>



<div class="cube-recent-posts cube-sidebar" id="cube-recent-posts">
    <div class="title">
        <a>Recent Posts</a>
    </div>
    <ul class="list">
        
        
        <li>
            <!-- TODO 如果文章要显示图片，那么在front-matter上添加preview属性(url or path) -->
            
            <div class="normal">
                <p class="index first">
                    <span>1</span>
                </p>
                <p class="title">
                    <a href="/2022/08/25/Js%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="变量类型">变量类型</a>
                </p>
            </div>
            
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>2</span>
                </p>
                <p class="title">
                    <a href="/2022/07/15/bug/echarts%E5%9B%BE%E6%A0%87%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%B3%95/" title="echarts图标自适应方法">echarts图标自适应方法</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>3</span>
                </p>
                <p class="title">
                    <a href="/2022/07/15/bug/a01/" title="浏览器多进程与多线程">浏览器多进程与多线程</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>4</span>
                </p>
                <p class="title">
                    <a href="/2022/06/09/html+css+js+ts/3-js%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/" title="js-常用代码操作实例">js-常用代码操作实例</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>5</span>
                </p>
                <p class="title">
                    <a href="/2022/05/28/html+css+js+ts/1-%E9%9F%B3%E8%A7%86%E9%A2%91/" title="html-原生音视频">html-原生音视频</a>
                </p>
            </div>
        </li>
        
        
    </ul>
</div>



<div class="cube-categories cube-sidebar" id="cube-categories">
    <div class="title">
        <a href="/categories">Categories</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/categories/http/">#http</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/React/">#React</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">#数据可视化</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">#架构模式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/">#前端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">#移动端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E9%9F%B3%E8%A7%86%E9%A2%91/">#音视频</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/javascript/">#javascript</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">#问题</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/">#后端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">#小程序</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">#前端工程化</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%B7%A5%E5%85%B7/">#工具</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">#正则表达式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">#前端性能优化</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">#数据库</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/liunx/">#liunx</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a>
        </div>
        
    </div>
</div>



<div class="cube-tagcloud cube-sidebar" id="cube-tagcloud">
    <div class="title">
        <a href="/tags">Tagcloud</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/tags/http/">#http</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/vue/">#vue</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/React/">#React</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/Redux/">#Redux</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/echart/">#echart</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/vue3/">#vue3</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/react/">#react</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/html/">#html</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/xml/">#xml</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">#移动端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/css/">#css</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/javascript/">#javascript</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Promise/">#Promise</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/es6/">#es6</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/typescript/">#typescript</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/async-await/">#async/await</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/nodejs/">#nodejs</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">#小程序</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/python/">#python</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/glup/">#glup</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/webpack/">#webpack</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/git/">#git</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Mock/">#Mock</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/eslint/">#eslint</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/RESTful/">#RESTful</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/hexo/">#hexo</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/vs-code/">#vs code</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">#正则表达式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E4%BC%98%E5%8C%96/">#优化</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/mongodb/">#mongodb</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/mysql/">#mysql</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/nginx/">#nginx</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a>
        </div>
        
    </div>
</div>



<div class="cube-links cube-sidebar" id="cube-links">
    <div class="title">
        <a>Links</a>
    </div>
    <ul class="list">
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/GitHub.png">
            
            <a href="https://github.com/ZEROKISEKI" target="_blank">GitHub</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/Coding.png">
            
            <a href="https://coding.net/u/SORA1" target="_blank">Coding</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/SF.png">
            
            <a href="https://segmentfault.com/u/aonosora" target="_blank">SF社区</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/开发者头条.png">
            
            <a href="https://toutiao.io/u/148070" target="_blank">开发者头条</a>
        </li>
        
    </ul>
</div>



<div class="cube-friend-links cube-sidebar" id="cube-friend-links">
    <div class="title">
        <a>Friend Links</a>
    </div>
    <ul class="list">
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/micblo.png">
            <a href="https://blog.micblo.com/" target="_blank">罗大佬</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/DIYgod.jpg">
            <a href="https://www.anotherhome.net/" target="_blank">DIYgod</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="/images/friend_links.jpg ">
            <a href="https://aonosora.com/" target="_blank">咪西西の部落格</a>
        </li>
        
    </ul>
</div>


        </div>
    </div>
</div>
<footer class="cube-footer">
    
© 2017 John Doe

<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.&nbsp;Theme by <a href="https://github.com/ZEROKISEKI" target="_blank">AONOSORA</a>
</footer>
<!-- inject:script -->
<script src="/js/script.js"></script>
<!-- endinject -->
<div class="cube-loading out"></div>
</body>
</html>