<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="John Doe">
    
    
    
    
    
    
    <title>Hexo</title>
    <!-- inject:style -->
    <link href="/css/style.css" rel="stylesheet" type="text/css">
    <!-- endinject -->
    <style>
        .cube-loading {
            top: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('/images/lg/loading.gif') no-repeat center center;
            background-color: rgba(0,0,0,.7);
        }

        .cube-loading.out {
            display: none;
        }

        .cube-loading:before {
            display: block;
            content: 'Loading';
            position: relative;
            width: 100%;
            top: 50%;
            right: -50%;
            color: #fff;
        }

        @media(max-width: 768px) {
            .cube-loading:before {
                font-size: 1.2em;
                transform: translate(-24px,20px);
                -webkit-transform: translate(-24px,20px);
                -o-transform: translate(-24px,20px);
                -ms-transform: translate(-24px,20px);
            }
        }

        @media(min-width: 768px) {
            .cube-loading:before {

            }
        }
    </style>
    
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
<div class="cube-body">
    <nav id="cube-top-memu" class="cube-menu">
    <ul class="cube-menu-collapse">
        
        <li>
            <i class="cube-icon cube-icon-home" aria-hidden="true"></i>
            <a href="/">首页</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-archive" aria-hidden="true"></i>
            <a href="/archives">归档</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-categories" aria-hidden="true"></i>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-tags" aria-hidden="true"></i>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-about" aria-hidden="true"></i>
            <a href="/about-me">关于我</a>
        </li>
        
    </ul>
</nav>
<nav class="cube-side-menu" id="cube-side-menu">
    <ul class="cube-menu-list">
        
        <li>
            <a class="lrc-control">Open Lyrics</a>
        </li>
        
        <li>
            <a class="scroll-to-top">Top</a>
        </li>
    </ul>
</nav>
    <header class="cube-header" id="cube-header">
    <img src=" http://cube-1252774894.cosgz.myqcloud.com/background.png " alt="头部背景图片">
    
    <div class="cube-type">
        <span class="cube-typed-title">senrenbankaの部落格</span>
        <span class="cube-typed-cursor">|</span>
    </div>
    
</header>

    <style>
        nav.cube-menu:before {
            content: '';
            visibility: hidden;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 44px;
        
            filter: blur(5px);
            -webkit-filter: blur(5px);
        
            z-index: -1;
            background-image: url('http://cube-1252774894.cosgz.myqcloud.com/background.png');
            background-repeat: no-repeat;
            background-position: center -356px;
            background-size: cover;
            background-color: transparent;
        }

        header.cube-background.cube-header-background {
            visibility: hidden;
            background-image: url('http://cube-1252774894.cosgz.myqcloud.com/background.png');
            background-position: center -400px;
        }
    </style>
    <header class="cube-background cube-header-background">
        
        <div class="cube-type">
            <span class="cube-typed-title">senrenbankaの部落格</span>
            <span class="cube-typed-cursor">|</span>
        </div>
        
    </header>
    <div class="load-header-background"></div>
    <script>
        (function (window) {

            window.headerModule = {}
            window.headerModule.image = {
                width: '2000',
                height: '1414'
            }

        })(window)
    </script>
    
    <div class="cube-content">
        <div class="cube-left">
            
<div class="cube-excerpt" id="cube-excerpt-vue-事件">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/15/Vue/vue-%E4%BA%8B%E4%BB%B6/">vue-事件</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-15
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/vue/" class="cube-excerpt-tag-link">#vue</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、方法传参"><a href="#一、方法传参" class="headerlink" title="一、方法传参"></a>一、方法传参</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;test&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;sayHi(&#x27;你好&#x27;)&quot;&gt;说你好&lt;/button&gt; &lt;!--这里使用@--&gt;</span><br><span class="line">    &lt;button @click=&quot;sayHi(&#x27;我被点击了&#x27;)&quot;&gt;说我被点击了&lt;/button&gt; &lt;!--这里使用@--&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var myVue = new Vue(&#123;</span><br><span class="line">        el: &#x27;#test&#x27;,</span><br><span class="line">        methods: &#123;      //这里使用methods</span><br><span class="line">            sayHi: function (message) &#123;</span><br><span class="line">                alert(message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="二、vue访问原生-DOM-事件"><a href="#二、vue访问原生-DOM-事件" class="headerlink" title="二、vue访问原生 DOM 事件"></a>二、vue访问原生 DOM 事件</h2><blockquote>
<p>用<code>$event</code>获取</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;changeColor(&#x27;你好&#x27;,$event)&quot;&gt;点击我&lt;/button&gt; &lt;!--这里使用@--&gt;</span><br><span class="line">&lt;div style=&quot;height: 100px;width: 100px;background-color: red;&quot; @mouseover=&quot;over(&#x27;鼠标从我上面滑过&#x27;,$event)&quot;&gt;</span><br><span class="line">    鼠标从我上面滑过试试</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var myVue = new Vue(&#123;</span><br><span class="line">        el: &#x27;#test&#x27;,</span><br><span class="line">        methods: &#123;      //这里使用methods</span><br><span class="line">            changeColor: function (message, event) &#123;</span><br><span class="line">                alert(message+event);    //弹出我被点击了,事件是[object MouseEvent]</span><br><span class="line">            &#125;,</span><br><span class="line">            over :function (message, event) &#123;</span><br><span class="line">                alert(message+event);   //弹出鼠标从我上面滑过,事件是[object MouseEvent]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、事件修饰符"><a href="#三、事件修饰符" class="headerlink" title="三、事件修饰符"></a>三、事件修饰符</h2><blockquote>
<p>事件修饰符有基本的6种</p>
</blockquote>
<p><strong>.stop阻止事件冒泡</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><strong>.prevent阻止默认事件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p><strong>.capture时间捕获（从上到下）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>.self只在元素自身回调</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>.once只触发一次</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 [<code>@click.prevent.self](mailto:</code>@click.prevent.self)<code>会阻止所有的点击，而</code>@click.self.prevent&#96; 只会阻止元素上的点击</p>
</blockquote>
<h2 id="四、键值修饰符"><a href="#四、键值修饰符" class="headerlink" title="四、键值修饰符"></a>四、键值修饰符</h2><blockquote>
<p>在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-on:keydown=&quot;ke&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            msg:&quot;事件处理&quot;,</span><br><span class="line">            counter:0</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            ke:function(e)&#123;</span><br><span class="line">                if(e.keyCode == 13)&#123;</span><br><span class="line">                    this.msg = e.target.value;</span><br><span class="line">                    e.target.value = &quot;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>enter</code>(回车)</li>
<li><code>tab</code>（tab切换）</li>
<li><code>delete</code> (捕获 “删除” 和 “退格” 键)</li>
<li><code>esc</code>（esc键）</li>
<li><code>space</code>（退档键）</li>
<li><code>up</code>（上键）</li>
<li><code>down</code>（下键）</li>
<li><code>left</code>（左键）</li>
<li><code>right</code>（右键）</li>
</ul>
<blockquote>
<p>我们也可以通过全局<code>config.keyCodes</code> 对象自定义键值修饰符别名</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/15/Vue/vue-%E4%BA%8B%E4%BB%B6/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-jQurty总结">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/12/html+css+js+ts/jQuery%E6%80%BB%E7%BB%93/">jQurty总结</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-12
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/javascript/" class="cube-excerpt-tag-link">#javascript</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h4 id="第一节-jQuery初步认知"><a href="#第一节-jQuery初步认知" class="headerlink" title="第一节 jQuery初步认知"></a>第一节 jQuery初步认知</h4><hr>
<h5 id="jQuery概述"><a href="#jQuery概述" class="headerlink" title="jQuery概述"></a>jQuery概述</h5><hr>
<ul>
<li><p><strong><code>JQuery</code>概念</strong></p>
<ul>
<li><p>&#96;&#96;&#96;<br>javascript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  概念</span><br><span class="line"></span><br><span class="line">  - 基于`Js`语言的`API`和语法组织逻辑，通过内置`window`和`document`对象，来操作内存中的`DOM`元素</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  JQuery</span><br></pre></td></tr></table></figure>

<p>概念</p>
<ul>
<li>基于<code>javascript</code>的，同上，提高了代码的效率</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>jQuery</code>是什么:</strong></p>
<ul>
<li>是一个<code>javascript</code>代码仓库，我们称之为<code>javascript</code>框架。</li>
<li>是一个快速的简洁的<code>javascript</code>框架，可以简化查询<code>DOM</code>对象、处理事件、制作动画、处理<code>Ajax</code>交互过程。</li>
<li>它可以帮我们做什么(有什么优势)<ul>
<li>轻量级、体积小，使用灵巧(只需引入一个<code>js</code>文件)</li>
<li>强大的选择器</li>
<li>出色的<code>DOM</code>操作的封装</li>
<li>出色的浏览器兼容性</li>
<li>可靠的事件处理机制</li>
<li>完善的<code>Ajax</code></li>
<li>链式操作、隐式迭代</li>
<li>方便的选择页面元素(模仿<code>CSS</code>选择器更精确、灵活)</li>
<li>动态更改页面样式&#x2F;页面内容(操作<code>DOM</code>，动态添加、移除样式)</li>
<li>控制响应事件(动态添加响应事件)</li>
<li>提供基本网页特效(提供已封装的网页特效方法)</li>
<li>快速实现通信(<code>ajax</code>)</li>
<li>易扩展、插件丰富</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>如何引入<code>JQuery</code>包</strong></p>
<ul>
<li>引入本地的<code>JQuery</code></li>
<li>引入<code>Google</code>在线提供的库文件（稳定可靠高速）</li>
<li>使用<code>Google</code>提供的<code>API</code>导入 &#96;&#96;</li>
<li>写第一个<code>JQUery</code>案例<ul>
<li>解释:在<code>JQuery</code>库中，<code>$</code>是<code>JQuery</code>的别名，<code>$()</code>等效于就<code>jQuery()</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=“text/javascript”&gt;</span><br><span class="line">	$(function()&#123;</span><br><span class="line">		alert(“jQuery 你好!”);</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>讲解<code>$(function()&#123;&#125;)</code>;</strong></p>
<ul>
<li><p><code>$</code>是<code>jQuery</code>别名。如<code>$()</code>也可<code>jQuery()</code>这样写,相当于页面初始化函数，当页面加载完毕，会执行<code>jQuery()</code>。</p>
</li>
<li><p>希望在做所有事情之前，<code>JQuery</code>操作<code>DOM</code>文档。必须确保在<code>DOM</code>载入完毕后开始执行，应该用<code>ready</code>事件做处理<code>HTML</code>文档的开始</p>
</li>
<li><pre><code>$(document).ready(function()&#123;&#125;)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    - 类似于`js`的`window.onload`事件函数，但是`ready`事件要先于`onload`事件执行</span><br><span class="line">    - `window.onload = function()&#123;&#125;`;</span><br><span class="line"></span><br><span class="line">  - 为方便开发，`jQuery`简化这样的方法，直接用`$()`表示</span><br><span class="line"></span><br><span class="line">  - `JQuery`的`ready`事件不等于`Js`的`load`：</span><br><span class="line"></span><br><span class="line">    - 执行时机不同：`load`需要等外部图片和视频等全部加载才执行。`ready`是`DOM`绘制完毕后执行，先与外部文件</span><br><span class="line">    - 用法不同：`load`只可写一次，`ready`可以多次</span><br><span class="line"></span><br><span class="line">- **`window.onload`与`$(document).ready()`对比**</span><br><span class="line"></span><br><span class="line">|          | window.onload                            | $(document).ready()                                          |</span><br><span class="line">| :------- | :--------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">| 执行时机 | 必须等网页中所有内容加载完后(图片)才执行 | 网页中的`DOM`结构绘制完后就执行,可能`DOM`元素相关的东西并没有加载完 |</span><br><span class="line">| 编写个数 | 不能同时执行多个                         | 能同时执行多个                                               |</span><br><span class="line">| 简化写法 | 无                                       | `$(document).ready(function()&#123; //.. &#125;);`  推荐写法：`$(function()&#123; &#125;);` |</span><br><span class="line"></span><br><span class="line">- **`jQuery`有哪些功能(`API`)**：</span><br><span class="line">  - 选择器</span><br><span class="line">  - 过滤器</span><br><span class="line">  - 事件</span><br><span class="line">  - 效果</span><br><span class="line">  - `ajax`</span><br><span class="line">- **简单的`JQuery`选择器**：</span><br><span class="line">  - `JQuery`基本选择器（`ID`选择器，标签选择器，类选择器，通配选择器和组选择器`5`种）</span><br><span class="line">  - `ID`选择器：`document.getElementById(id)`与`$(&quot;#id&quot;)`对比(改变文字大小)—`id`唯一，返回单个元素</span><br><span class="line">  - 标签选择器：`document.getElementsByTagName(tagName)`与`$(&quot;tagname&quot;)`对比—多个标签，返回数组</span><br><span class="line">  - 类选择器:`$(&quot;.className&quot;)`–多个`classname`（改变背景图片）</span><br><span class="line">  - 通配选择器：`document.getElementsByTagName(&quot;*&quot;)`与`$(&quot;*&quot;)`对比—指范围内的所有标签元素</span><br><span class="line">  - 组选择器：`$(&quot;seletor1,seletor2,seletor3&quot;)`—-无数量限制，用逗号分割</span><br><span class="line"></span><br><span class="line">##### 初步了解`JQuery`</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- `JQuery`是什么</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    javascript</span><br></pre></td></tr></table></figure>

用来干什么的：

- 操作`DOM`对象
- 动态操作样式`css`
- 数据访问
- 控制响应事件等
</code></pre>
</li>
<li><p><code>jQuery</code>作用一样，只是更加快速简洁</p>
</li>
</ul>
</li>
<li><p><strong>如何引用<code>JQuery</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">写第一个JQUery案例</span><br><span class="line">&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=“text/javascript”&gt;</span><br><span class="line">	$(function()&#123;</span><br><span class="line">		alert(“jQuery 你好!”);</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>$()讲解</code></strong></p>
<ul>
<li><code>$</code>在<code>JQuery</code>库中，<code>$</code>是<code>JQuery</code>的别名，<code>$()</code>等效于就<code>jQuery()</code>.</li>
<li><code>$()</code>是<code>JQuery</code>方法,赞可看作是<code>JQuery</code>的选择器，与<code>css</code>选择器相似（可做对比）</li>
<li><code>var jQuery==$ =function()&#123;&#125;</code> <code>$()</code>本质就是一个函数也就是 <code>jQuery</code>的核心函数</li>
<li>只要是<code>jQuery</code>的对象都这样变量加上一个<code>符号$</code>方便识别：<code>var $div = $(&quot;#&quot;)</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function　$(id)&#123;</span><br><span class="line">		return document.getElementById(id);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>$()</code>和<code>document</code>是相等的吗</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;a&quot; class=&quot;aa&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;b&quot; class=&quot;aa&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;c&quot; class=&quot;aa&quot;&gt;&lt;/div&gt;</span><br><span class="line">alert(document.getElementById(&quot;id&quot;) == $(&quot;#aa&quot;));//返回结果为false</span><br><span class="line">alert(document.getElementById(&quot;id&quot;) == $(&quot;#aa&quot;).get(0));//返回true</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>代理对象<code>$()</code></strong></p>
<ul>
<li><p><code>jQuery</code>中返回的是代理对象本身</p>
</li>
<li><p><code>jQuery</code>的核心原理是通过选择器找到对应的代理对象</p>
</li>
<li><p><code>jQuery</code>全都是通过方法操作</p>
</li>
<li><p>样式选择器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.className&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$(&quot;.aa&quot;).css(&quot;color&quot;,&quot;green&quot;);</code></li>
</ul>
</li>
<li><p>id选择器(“”)</p>
<ul>
<li><code>$(&quot;#a&quot;).css(&quot;background-color&quot;,&quot;#ff0066&quot;);</code></li>
</ul>
</li>
<li><p>标签选择器</p>
<ul>
<li><code>$(&quot;p&quot;).css(&quot;color&quot;,&quot;#cc3366&quot;);</code></li>
</ul>
</li>
<li><p>组选择器</p>
<ul>
<li><code>$(&quot;#b ul li&quot;).size();</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对象转换(<code>$(element)</code>)</strong></p>
<ul>
<li>原生<code>dom</code>对象和<code>jquery</code>代理对象的相互转换</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(传入的原生对象);</span><br><span class="line">//原生对象转化成jQuery对象</span><br><span class="line">var nav = document.getElementById(&quot;nav&quot;);</span><br><span class="line">var $nav = $(nav);</span><br><span class="line">alert($nav.get(0) == nav);//true</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>检索范围的限制（<code>$(&#39;字符串&#39;,element)</code>）</strong></p>
<ul>
<li><strong>总结：三种写法对比：</strong><ul>
<li>方式一：不推荐 搜索速度最慢<ul>
<li><code>$(&quot;#nav&quot;).css();</code></li>
<li><code>$(&quot;#nav li&quot;).css();</code></li>
</ul>
</li>
<li>方式二：搜索速度最快 链式操作<ul>
<li><code>$(&quot;#nav&quot;).css().children().css();</code></li>
</ul>
</li>
<li>方式三：也常用 速度第二快<ul>
<li><code>var $nav = $(&quot;#nav&quot;).css()</code>;</li>
<li><code>$(&quot;li&quot;,$nav).css()</code>; <code>$nav</code>限制了搜索范围 速度快</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>总结： <code>$()</code> <code>jquery</code>核心方法的作用和使用场景</strong></p>
<ul>
<li>如果是一个字符串参数并且没有标签对（选择器）<code>$(ul.nav&quot;)</code></li>
<li>如果是一个字符串参数并且有标签对（创建<code>html</code>标签）<code>$(&quot;&quot;)</code> –最终加到<code>DOM</code>树中 <code>$xx.append(&quot;&quot;)</code>;</li>
<li>如果是传入一个<code>element dom</code>对象，直接包装为<code>proxy</code>对象返回 <code>$(DOM对象)</code></li>
<li>如果第一个参数是字符串，第二个是<code>element</code> <code>dom</code>对象的话，那么就是在<code>element</code>这个<code>dom</code>对象里面寻找选择器对应的元素并且代理 <code>$(&quot;li&quot;,$DOM对象)</code></li>
</ul>
</li>
<li><p><strong>代理模式以及代理内存结构</strong></p>
</li>
</ul>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/jquery2.png" alt="代理内存结构1"></p>
<p><img src="http://7xq6al.com1.z0.glb.clouddn.com/jquery3.png" alt="代理内存结构2"></p>
<h4 id="第二节-选择器"><a href="#第二节-选择器" class="headerlink" title="第二节 选择器"></a>第二节 选择器</h4><hr>
<ul>
<li><strong>来回顾一下<code>CSS</code>常用的选择器</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">语法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">标签选择器</td>
<td align="left"><code>E&#123;css规则&#125;</code></td>
<td align="left">以文档元素作为选择符</td>
</tr>
<tr>
<td align="left"><code>ID</code>选择器</td>
<td align="left"><code>#ID&#123;css规则&#125;</code></td>
<td align="left"><code>ID</code>作为选择符</td>
</tr>
<tr>
<td align="left">类选择器</td>
<td align="left"><code>E.className&#123;css规则&#125;</code></td>
<td align="left"><code>class</code>作为选择符</td>
</tr>
<tr>
<td align="left">群组选择器</td>
<td align="left"><code>E1,E2,E3&#123;css规则&#125;</code></td>
<td align="left">多个选择符应用同样的样式</td>
</tr>
<tr>
<td align="left">后代选择器</td>
<td align="left"><code>E F&#123;css规则&#125;</code></td>
<td align="left">元素<code>E</code>的任意后代元素<code>F</code></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>选择器引擎规则(<code>$(&#39;字符串&#39;)</code>)</strong></p>
<ul>
<li>&#96;&#96;&#96;<br>css<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    选择器的规则</span><br><span class="line"></span><br><span class="line">    - 标签选择器</span><br><span class="line">    - `id`选择器</span><br><span class="line">    - 类选择器</span><br><span class="line">    - 混合选择器</span><br><span class="line"></span><br><span class="line">  - `css3`的选择器规则</span><br><span class="line"></span><br><span class="line">  - 状态和伪类（`:even` `:odd` `:first` `:last` `:eq(index)`）</span><br><span class="line"></span><br><span class="line">  - 属性（`[attr=value]`）</span><br><span class="line"></span><br><span class="line">- 层级选择器:通过`DOM`的嵌套关系匹配元素</span><br><span class="line">  - `jQuery`层级选择器—-包含选择器、子选择器、相邻选择器、兄弟选择器4种</span><br><span class="line">  - a.包含选择器：`$(&quot;a b&quot;)`在给定的祖先元素下匹配所有后代元素。(不受层级限制)</span><br><span class="line">  - b.子选择器：`$(&quot;parent &gt; child&quot;)`在给定的父元素下匹配所有子元素。</span><br><span class="line">  - c.相邻选择器：`$(&quot;prev + next&quot;)` 匹配所有紧接在`prev`元素后的`next`元素。</span><br><span class="line">  - d.兄弟选择器：`$(&quot;prev ~ siblings&quot;)` 匹配prev元素之后的所有`sibling`元素。</span><br><span class="line"></span><br><span class="line">##### 过滤选择器</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **基本过滤选择**</span><br><span class="line"></span><br><span class="line">| 选择器       | 说明                           | 返回     |</span><br><span class="line">| :----------- | :----------------------------- | :------- |</span><br><span class="line">| `:first`     | 匹配找到的第1个元素            | 单个元素 |</span><br><span class="line">| `:last`      | 匹配找到的最后一个元素         | 单个元素 |</span><br><span class="line">| `:eq`        | 匹配一个给定索引值的元素       | 单个元素 |</span><br><span class="line">| `:even`      | 匹配所有索引值为偶数的元素     | 集合元素 |</span><br><span class="line">| `: odd`      | 匹配所有索引值为奇数的元素     | 集合元素 |</span><br><span class="line">| `:gt(index)` | 匹配所有大于给定索引值的元素   | 集合元素 |</span><br><span class="line">| `:lt(index)` | 匹配所有小于给定索引值的元素   | 集合元素 |</span><br><span class="line">| `:not`       | 去除所有与给定选择器匹配的元素 | 集合元素 |</span><br><span class="line">| `:animated`  | 选取当前正在执行动画的所有元素 | 集合元素 |</span><br><span class="line">| `focus`      | 选取当前正在获取焦点的元素     | 集合元素 |</span><br><span class="line"></span><br><span class="line">- **内容过滤选择器**</span><br><span class="line"></span><br><span class="line">| 选择器            | 描述                             | 返回     |</span><br><span class="line">| :---------------- | :------------------------------- | :------- |</span><br><span class="line">| `:contains(text)` | 选取含有文本内容为text的元素     | 集合元素 |</span><br><span class="line">| `:empty`          | 选取不包含子元素获取文本的空元素 | 集合元素 |</span><br><span class="line">| `:has(selector)`  | 选择含有选择器所匹配的元素的元素 | 集合元素 |</span><br><span class="line">| `:parent`         | 选取含有子元素或者文本的元素     | 集合元素 |</span><br><span class="line"></span><br><span class="line">- **可见过滤选择器**</span><br><span class="line"></span><br><span class="line">| 选择器     | 描述                 | 返回     |</span><br><span class="line">| :--------- | :------------------- | :------- |</span><br><span class="line">| `:hidden`  | 选择所有不可见的元素 | 集合元素 |</span><br><span class="line">| `:visible` | 选取所有可见的元素   | 集合元素 |</span><br><span class="line"></span><br><span class="line">- **属性过滤选择器**</span><br><span class="line"></span><br><span class="line">| 选择器              | 说明                            | 返回     |</span><br><span class="line">| :------------------ | :------------------------------ | :------- |</span><br><span class="line">| `[attribute]`       | 选取拥有此属性的元素            | 集合元素 |</span><br><span class="line">| `[attribute=value]` | 选取属性值为`value`值的元素     | 集合元素 |</span><br><span class="line">| `[attribue^=value]` | 选取属性的值以`value`开始的元素 | 集合元素 |</span><br><span class="line">| `[attribue$=value]` | 选取属性的值以`value`结束的元素 | 集合元素 |</span><br><span class="line"></span><br><span class="line">- **子元素过滤选择器**</span><br><span class="line"></span><br><span class="line">| 选择器                       | 说明                                                         | 返回     |</span><br><span class="line">| :--------------------------- | :----------------------------------------------------------- | :------- |</span><br><span class="line">| `:nth-child(index/even/odd)` | 选取每个父元素下的第index个子元素或者奇偶元素（`index`从`1`算起） | 集合元素 |</span><br><span class="line">| `:first-child`               | 选取每个元素的第一个子元素                                   | 集合元素 |</span><br><span class="line">| `:last-child`                | 选取每个元素的最后一个子元素                                 | 集合元素 |</span><br><span class="line"></span><br><span class="line">- `:nth-child()`选择器是很常用的子元素过滤选择器，如下</span><br><span class="line">  - `:nth-child(even)`选择每个父元素下的索引值是偶数的元素</span><br><span class="line">  - `:nth-child(odd)`选择每个父元素下的索引值是奇数的元素</span><br><span class="line">  - `:nth-child(2)`选择每个父元素下的索引值是`2`的元素</span><br><span class="line">  - `:nth-child(3n)`选择每个父元素下的索引值是3的倍数的元素 (`n`从`1`开始)</span><br><span class="line">- **表单对象属性过滤选择器**</span><br><span class="line"></span><br><span class="line">| 选择器      | 说明                                   | 返回     |</span><br><span class="line">| :---------- | :------------------------------------- | :------- |</span><br><span class="line">| `:enabled`  | 选取所有可用元素                       | 集合元素 |</span><br><span class="line">| `:disabled` | 选取所有不可用元素                     | 集合元素 |</span><br><span class="line">| `:checked`  | 选取所有被选中的元素（单选框、复选框） | 集合元素 |</span><br><span class="line">| `:selected` | 选取所有被选中的元素（下拉列表）       | 集合元素 |</span><br><span class="line"></span><br><span class="line">- **表单选择器**</span><br><span class="line"></span><br><span class="line">| 选择器      | 说明                                             |</span><br><span class="line">| :---------- | :----------------------------------------------- |</span><br><span class="line">| `:input`    | 选取所有`input` `textarea` `select` `button`元素 |</span><br><span class="line">| `:text`     | 选取所有单行文本框                               |</span><br><span class="line">| `:password` | 选取所有密码框                                   |</span><br><span class="line">| `:radio`    | 选取所有单选框                                   |</span><br><span class="line">| `:checkbox` | 选取所有多选框                                   |</span><br><span class="line">| `:submit`   | 选取所有的提交按钮                               |</span><br><span class="line">| `:image`    | 选取所有的图像按钮                               |</span><br><span class="line">| `:reset`    | 选取所有的重置按钮                               |</span><br><span class="line">| `:button`   | 选取所有的按钮                                   |</span><br><span class="line">| `:file`     | 选取所有的上传域                                 |</span><br><span class="line">| `:hidden`   | 选取所有的不可见元素                             |</span><br><span class="line"></span><br><span class="line">- **特定位置选择器**</span><br><span class="line">  - `:first`</span><br><span class="line">  - `:last`</span><br><span class="line">  - `:eq(index)`</span><br><span class="line">- **指定范围选择器**</span><br><span class="line">  - `:even`</span><br><span class="line">  - `:odd`</span><br><span class="line">  - `:gt(index)`</span><br><span class="line">  - `:lt(index)`</span><br><span class="line">- **排除选择器**</span><br><span class="line">  - `:not` 非</span><br><span class="line"></span><br><span class="line">#### 第三节 选择器优化</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 使用合适的选择器表达式可以提高性能、增强语义并简化逻辑。常用的选择器中，`ID`选择器速度最快，其次是类型选择器。</span><br><span class="line">  - a. 多用`ID`选择器</span><br><span class="line">  - b. 少直接使用`class`选择器</span><br><span class="line">  - c. 多用父子关系，少用嵌套关系</span><br><span class="line">  - d. 缓存`jQuery`对象</span><br><span class="line">- **使用过滤器**</span><br><span class="line">  - `jQuery`提供了`2`种选择文档元素的方式：选择器和过滤器</span><br><span class="line">  - a. 类过虑器：根据元素的类属性来进行过滤操作。</span><br><span class="line">    - `hasClass(className)`：判断当前`jQuery`对象中的某个元素是否包含指定类名，包含返回`true`，不包含返回`false`</span><br><span class="line">  - b. 下标过滤器：精确选出指定下标元素</span><br><span class="line">    - `eq(index)`：获取第`N`个元素。`index`是整数值，下标从`0`开始</span><br><span class="line">  - c. 表达式过滤器</span><br><span class="line">    - `filter(expr)/(fn)`：筛选出与指定表达式/函数匹配的元素集合。</span><br><span class="line">    - 功能最强大的表达式过滤器，可接收函数参数，也可以是简单的选择器表达式</span><br><span class="line">  - d. 映射 `map(callback)`：将一组元素转换成其他数组</span><br><span class="line">  - e. 清洗 `not(expr)`：删除与指定表达式匹配的元素</span><br><span class="line">  - f. 截取 `slice(start,end)`：选取一个匹配的子集</span><br><span class="line">- **查找**</span><br><span class="line">  - 向下查找后代元素</span><br><span class="line">    - `children()`:取得所有元素的所有子元素集合（子元素）</span><br><span class="line">    - `find()`:搜索所有与指定表达式匹配的元素(所有后代元素中查找)</span><br><span class="line">  - 查找兄弟元素 `siblings()`查找当前元素的兄弟</span><br><span class="line"></span><br><span class="line">#### 第四节 代理对象属性和样式操作</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **代理对象属性和样式操作**</span><br><span class="line">  - `attr`</span><br><span class="line">  - `prop`(一般属性值是`boolean`的值或者不用设置属性值，一般使用)</span><br><span class="line">  - `css`(最好不用，一般我用来做测试)</span><br><span class="line">  - `addClass` / `removeClass`</span><br><span class="line">- 操作原生`DOM`的时候用的方式：一次只能操作一个</span><br><span class="line">  - 操作属性：`setAttribute` / `getAttribute`</span><br><span class="line">  - 操作样式：`style.xx = value`</span><br><span class="line">  - 操作类样式：`className=&#x27;&#x27;`</span><br><span class="line">  - 获取`DOM`的子元素`children`属性</span><br><span class="line">  - `DOM`里面添加一个子元素`appendChild()`</span><br><span class="line">- 操作`jQuery`代理对象的时候：批量操作`DOM`对象(全都是通过方法操作)</span><br><span class="line">- 操作属性：`attr()`、`prop()`</span><br><span class="line">  - `attr`和`prop`区别：如果属性的值是布尔类型的值 用`prop`操作 反之`attr`</span><br><span class="line">- 操作样式：`css()`</span><br><span class="line">- 操作类样式：`addClass()` `removeClass()`</span><br><span class="line">- 操作`DOM`子元素：`children()`</span><br><span class="line">- 添加子元素：`append()`</span><br><span class="line"></span><br><span class="line">#### 第五节 jQuery中DOM操作</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- `DOM`是一种与浏览器、平台|语言无关的接口，使用该接口可以轻松的访问 页面中的所有的标准组件</span><br><span class="line"></span><br><span class="line">- **`DOM`操作的分类**</span><br><span class="line"></span><br><span class="line">  - **`DOM Core`**</span><br><span class="line"></span><br><span class="line">    - `DOM core`并不专属于`JavaScript`，任何支持`DOM`的程序都可以使用</span><br><span class="line">    - `JavaScript` 中的`getElementByID()` `getElementsByTagName()` `getAttribute()` `setAttribute()`等方法都是`DOM Core`的组成部分</span><br><span class="line"></span><br><span class="line">  - **`HTML-DOM`**</span><br><span class="line"></span><br><span class="line">    - `HTML -DOM`的出现比`DOM-Core`还要早，它提供一些更简明的标志来描述`HTML`元素的属性</span><br><span class="line"></span><br><span class="line">    - 比如：使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  HTML-DOM  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">来获取某元素的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  src  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      属性的方法</span><br><span class="line"></span><br><span class="line">      - `element.src`</span><br><span class="line"></span><br><span class="line">  - **`CSS-DOM`**</span><br><span class="line"></span><br><span class="line">    - 针对`CSS`的操作。在`JavaScript`中，主要用于获取和设置`style`对象的各种属性，通过改变`style`对象的属性，使网页呈现不同的效果</span><br><span class="line"></span><br><span class="line">- **查找节点**</span><br><span class="line"></span><br><span class="line">  - 查找属性节点 `attr()` 可以获取各属性的值</span><br><span class="line"></span><br><span class="line">- 创建节点</span><br><span class="line"></span><br><span class="line">  - `$(html)`：根据传递的标记字符串，创建`DOM`对象</span><br><span class="line"></span><br><span class="line">- **插入节点**</span><br><span class="line"></span><br><span class="line">| 方法             | 说明                             |</span><br><span class="line">| :--------------- | :------------------------------- |</span><br><span class="line">| `append()`       | 向每个匹配元素内部追加内容       |</span><br><span class="line">| `appendTo()`     | 颠倒`append()`的操作             |</span><br><span class="line">| `prepend()`      | 向每个匹配元素的内容内部前置内容 |</span><br><span class="line">| `prependTo()`    | 颠倒`prepend()`的操作            |</span><br><span class="line">| `after()`        | 向每个匹配元素之后插入内容       |</span><br><span class="line">| `insertAfter()`  | 颠倒`after()`的操作              |</span><br><span class="line">| `before()`       | 在每个匹配元素之前插入内容       |</span><br><span class="line">| `insertBefore()` | 颠倒`before()`的操作             |</span><br><span class="line"></span><br><span class="line">- **删除节点**</span><br><span class="line"></span><br><span class="line">  - jQuery提供了三种删除节点的方法 `remove()` `detach()` `empty()`</span><br><span class="line">  - `remove()方法`</span><br><span class="line">    - 当某个节点用此方法删除后，该节点所包含的所有后代节点将同时被删除，用`remove()`方法删除后，还是可以继续使用删除后的引用</span><br><span class="line">  - `detach()`</span><br><span class="line">    - 和`remove()`方法一样，也是从`DOM`中去掉所有匹配的元素，与`remove()`不同的是，所有绑定的事件、附加的数据等，都会被保留下来</span><br><span class="line">  - `empty()`</span><br><span class="line">    - `empty()`方法并不是删除节点，而是清空节点，它能清空元素中所有后代节点</span><br><span class="line"></span><br><span class="line">- **复制节点**</span><br><span class="line"></span><br><span class="line">  - 使用`clone()`方法来完成</span><br><span class="line">  - 在`clone()`方法中传递一个参数`true`，同时复制元素中所绑定的事件</span><br><span class="line"></span><br><span class="line">- **替换节点**</span><br><span class="line"></span><br><span class="line">  - `jQuery`提供相应的方法 `replaceWidth()`</span><br><span class="line"></span><br><span class="line">- **样式操作**</span><br><span class="line"></span><br><span class="line">  - 获取样式和设置样式 `attr()`</span><br><span class="line">  - 追加样式 `addClass()`</span><br><span class="line">  - 移除样式 `removeClass()`</span><br><span class="line">  - 切换样式</span><br><span class="line">    - `toggle()`方法只要是控制行为上的重复切换（如果元素是显示的，则隐藏；如果元素原来是隐藏的，则显示）</span><br><span class="line">    - `toggleClass()`方法控制样式上的重复切换（如何类名存在，则删除它，如果类名不存在，则添加它）</span><br><span class="line">  - 判断是否含有某个样式</span><br><span class="line">    - `hasClass()`可以用来判断元素是否含有某个`class`,如有返回`true` 该方法等价于`is()`</span><br><span class="line"></span><br><span class="line">- **设置和获取HTML、文本和值**</span><br><span class="line"></span><br><span class="line">  - `html()`</span><br><span class="line"></span><br><span class="line">    - 此方法类似`JavaScript`中`innerHTML`属性，可以用来读取和设置某个元素中的`HTML`内容</span><br><span class="line"></span><br><span class="line">  - `text()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 此方法类型`JavaScript`中`innerHTML`，用来读取和设置某个元素中的文本内容</span><br><span class="line"></span><br><span class="line">  - `val()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 此方法类似`JavaScript`中的`value`属性，用来设置获取元素的值。无论是文本框、下拉列表还是单选框，都可以返回元素的值，如果元素多选，返回一个包含所有选择的值的数组</span><br><span class="line"></span><br><span class="line">- **遍历节点**</span><br><span class="line"></span><br><span class="line">  - `children()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 该方法用来取得匹配元素的子元素集合</span><br><span class="line">    - `childre()`方法只考虑子元素而不考虑其他后代元素</span><br><span class="line"></span><br><span class="line">  - `next()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 该方法用于取得匹配元素后面紧邻的同辈元素</span><br><span class="line"></span><br><span class="line">  - `prev()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 用于匹配元素前面紧邻的同辈元素</span><br><span class="line"></span><br><span class="line">  - `siblings()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 用于匹配元素前后所有的同辈元素</span><br><span class="line"></span><br><span class="line">  - `parent()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 获得集合中每个 元素的父级元素</span><br><span class="line"></span><br><span class="line">  - `parents()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 获得集合中每个元素的祖先元素</span><br><span class="line"></span><br><span class="line">##### CSS DOM操作</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- `CSS DOM`技术简单的来说就是读取和设置`style`对象的各种属性</span><br><span class="line"></span><br><span class="line">- 用`css()`方法获取元素的样式属性，可以同时设置多个样式属性</span><br><span class="line"></span><br><span class="line">- `CSS DOM`中关于元素定位有几个常用的方法</span><br><span class="line"></span><br><span class="line">  - `offset()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 它的作用是获取元素在当前视窗的相对偏移其中返回的对象包含两个属性，即`top`和`left`，他只对可见元素有效</span><br><span class="line"></span><br><span class="line">  - `position()`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 获取相对于最近的一个`position()`样式属性设置为`relative`或者`absolute`的祖父节点的相对偏移，与`offset()`一样，他返回的对象也包括两个属性，即`top`和`left`</span><br><span class="line"></span><br><span class="line">  - `scrollTop()`</span><br><span class="line"></span><br><span class="line">    方法和</span><br><span class="line"></span><br><span class="line">    `scrollLeft`</span><br><span class="line"></span><br><span class="line">    方法</span><br><span class="line"></span><br><span class="line">    - 这两个方法的作用分别是获取元素的滚动条距顶端的距离和距左侧的距离</span><br><span class="line"></span><br><span class="line">  - **一张图总结以上的位置关系(项目中很常用-必须要弄清楚)**</span><br><span class="line"></span><br><span class="line">![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery4.jpg)</span><br><span class="line">![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery5.jpg)</span><br><span class="line">![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery6.jpg)</span><br><span class="line">![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery7.jpg)</span><br><span class="line">![img](http://7xq6al.com1.z0.glb.clouddn.com/jquery7.jpg)</span><br><span class="line"></span><br><span class="line">#### 第六节 jQuery动画</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">##### 回顾上节</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 操作DOM</span><br><span class="line">  - a.什么是`DOM`：`Document Object Model`缩写，文档对象模型</span><br><span class="line">  - b.理解页面的树形结构</span><br><span class="line">  - c.什么是节点：是DOM结构中最小单元，包括元素、属性、文本、文档等。</span><br><span class="line"></span><br><span class="line">###### 一、创建节点</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 1.创建元素</span><br><span class="line">  - 语法：`document.createElement(name)`;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>var div &#x3D; document.createElement(“div”);<br>document.body.appendChild(div);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `$(html)`：根据传递的标记字符串，创建DOM对象</span><br><span class="line">- 2.创建文本</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var div &#x3D; document.createElement(“div”);<br>var txt &#x3D; document.createTextNode(“DOM”);<br>div.appendChild(txt);<br>document.body.appendChild(div);</p>
<p>var $div &#x3D; &#x3D; $(“<div>DOM</div>“);<br>$(body).append($div);<br>​&#96;&#96;&#96;		</p>
<ul>
<li>3.设置属性<ul>
<li>语法：<code>e.setAttrbute(name,value)</code></li>
</ul>
</li>
</ul>
<p>​&#96;&#96;&#96;javascript<br>var div &#x3D; document.createElement(“div”);<br>var txt &#x3D; document.createTextNode(“DOM”);<br>div.appendChild(txt);<br>document.body.appendChild(div);<br>div.setAttribute(“title”,”盒子”);</p>
<p>var $div &#x3D; &#x3D; $(“<div title='盒子'>DOM</div>“);<br>$(body).append($div);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### 二、插入内容</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 内部插入</span><br><span class="line">  - 向元素最后面插入节点：</span><br><span class="line">    - `append()`:向每个匹配的元素内部追加内容</span><br><span class="line">    - `appendTo()`:把所有匹配的元素追加到指定元素集合中，`$(&quot;A&quot;).append(&quot;B&quot;)`等效 `$(&quot;B&quot;).appendTo(&quot;A&quot;)`</span><br><span class="line">  - 向元素最前面插入节点：</span><br><span class="line">    - `prepend（）`：把每个匹配的元素内部前置内容</span><br><span class="line">    - `prependTo（）`：把所有匹配的元素前置到另一个指定的元素集合中,`$(&quot;A&quot;).prepend(&quot;B&quot;)` 等效 `$(&quot;B&quot;).prependTo(&quot;A&quot;)`</span><br><span class="line">- 外部插入</span><br><span class="line">  - `after()`:在每个匹配的元素之后插入内容</span><br><span class="line">  - `before()`：在每个匹配想元素之前插入内容</span><br><span class="line">  - `insertAfter()`：将所有匹配的元素插入到另一个指定的元素集合后面，`$A.insert($B)` 等效`$B.insertAfter($A);`</span><br><span class="line">  - `insertBefore()`：将所有匹配的元素插入到另一个指定的元素集合前面 `$A.before($B)` 等效 `$B.insertBefore($A)`;</span><br><span class="line"></span><br><span class="line">###### 三、删除内容</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 移除</span><br><span class="line">  - `remove()`:从`DOM`中删除所有匹配元素</span><br><span class="line">- 清空</span><br><span class="line">  - `empty()`:删除匹配的元素集合中所有子节点内容</span><br><span class="line"></span><br><span class="line">###### 四、克隆内容：创建指定节点副本</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  clone()</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：若<code>clone（true）</code>则是包括克隆元素的属性，事件等</li>
</ul>
<h6 id="五、替换内容"><a href="#五、替换内容" class="headerlink" title="五、替换内容"></a>五、替换内容</h6><hr>
<ul>
<li><p><code>replaceWith()</code>:将所有匹配的元素替换成指定的元素</p>
</li>
<li><p><code>replaceAll()</code>:用匹配的元素替换掉指定元素</p>
</li>
<li><p>注意：两者效果一致，只是语法不同 <code>$A.replaceAll($B)</code>等效于 <code>$B.replaceWhith($A)</code>;</p>
</li>
</ul>
<h5 id="本节新知识"><a href="#本节新知识" class="headerlink" title="本节新知识"></a>本节新知识</h5><hr>
<ul>
<li><code>JavaScrip</code>t语言本身不支持动画设计，必须通过改变<code>CSS</code>来实现动画效果</li>
</ul>
<p><strong>显隐动画</strong></p>
<ul>
<li><p><code>show()</code>:显示 <code>hide()</code>:隐藏</p>
<ul>
<li><p>原理：<code>hide()</code>通过改变元素的高度宽度和不透明度，直到这三个属性值到<code>0</code></p>
</li>
<li><p><code>show()</code>从上到下增加元素的高度，从左到右增加元素宽度，从<code>0</code>到<code>1</code>增加透明度，直至内容完全可见</p>
</li>
<li><p>参数：</p>
<ul>
<li>&#96;&#96;&#96;<br>show(speed,callback)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - `speed`: 字符串或数字，表示动画将运行多久（`slow=0.6`/`normal=0.4`/`fast=0.2`）</span><br><span class="line">      - `callback`: 动画完成时执行的方法</span><br><span class="line"></span><br><span class="line">- 显示和隐藏式一对密不可分的动画形式</span><br><span class="line"></span><br><span class="line">- **显隐切换**</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    toggle()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>:切换元素的可见状态</p>
<ul>
<li><p>原理：匹配元素的宽度、高度以及不透明度，同时进行动画，隐藏动画后将<code>display</code>设置为<code>none</code></p>
</li>
<li><p>参数：</p>
<ul>
<li><p><code>toggle(speed)</code></p>
</li>
<li><p><code>toggle(speed,callback)</code></p>
</li>
<li><p>&#96;&#96;&#96;<br>toggle(boolean)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        - `speed`: 字符串或数字，表示动画将运行多久（`slow=0.6`/`normal=0.4`/`fast=0.2`）</span><br><span class="line">        - `easing`： 使用哪个缓冲函数来过渡的字符串(`linear`/`swing`)</span><br><span class="line">        - `callback`： 动画完成时执行的方法</span><br><span class="line">        - `boolean`:`true`为显示 `false`为隐藏</span><br><span class="line"></span><br><span class="line">**滑动**</span><br><span class="line"></span><br><span class="line">- **显隐滑动效果**</span><br><span class="line">  - `slideDown()`:滑动隐藏</span><br><span class="line">  - `slidUp()`:滑动显示</span><br><span class="line">  - 参数:</span><br><span class="line">    - `slideDown(speed,callback)`</span><br><span class="line">    - `slidUp(speed,callback)`</span><br><span class="line">- **显隐切换滑动**</span><br><span class="line">  - `slideToggle()`:显隐滑动切换</span><br><span class="line">  - 参数:</span><br><span class="line">    - `slidUp(speed,callback)`</span><br><span class="line"></span><br><span class="line">**渐变：通过改变不透明度**</span><br><span class="line"></span><br><span class="line">- **淡入淡出**</span><br><span class="line">  - `fadeIn()`</span><br><span class="line">  - `fadeOut()`</span><br><span class="line">  - 参数：</span><br><span class="line">    - `fadeIn(speed,callback)`</span><br><span class="line">    - `fadeOut(speed,callback)`</span><br><span class="line">- **设置淡出透明效果**</span><br><span class="line">  - `fadeTo()`⁭：以渐进的方式调整到指定透明度</span><br><span class="line">  - 参数：</span><br><span class="line">    - `fadeTo(speed,opacity,callback)`</span><br><span class="line">- **渐变切换:结合`fadeIn`和`fadeOut`**</span><br><span class="line">  - `fadeToggle()`</span><br><span class="line">  - 参数:</span><br><span class="line">    - `fadeOut(speed,callback)`</span><br><span class="line"></span><br><span class="line">- 自定义动画：`animate()`</span><br><span class="line"></span><br><span class="line">  - 注意：在使用`animate`方法之前，为了影响该元素的`top` `left` `bottom` `right`样式属性，必须先把元素的`position`样式设置为`relative`或者`absolute`</span><br><span class="line"></span><br><span class="line">  - 停止元素的动画</span><br><span class="line"></span><br><span class="line">    - 很多时候需要停止匹配正在进行的动画，需要使用stop()</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      stop()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>语法结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop([clearQueue],[gotoEnd]);</span><br></pre></td></tr></table></figure>

<ul>
<li>都是可选参数，为布尔值</li>
<li>如果直接使用<code>stop()</code>方法，会立即停止当前正在进行的动画</li>
</ul>
</li>
</ul>
</li>
<li><p>判断元素是否处于动画状态</p>
<ul>
<li>如果不处于动画状态，则为元素添加新的动画，否则不添加<br><code>if(!$(element).is(&quot;:animated&quot;))&#123; //判断元素是否处于动画状态&#125;</code></li>
<li>这个方法在<code>animate</code>动画中经常被用到，需要注意</li>
</ul>
</li>
<li><p>延迟动画</p>
<ul>
<li>在动画执行过程中，如果你想对动画进行延迟操作，那么使用<code>delay()</code></li>
</ul>
</li>
</ul>
</li>
<li><p>用<code>animate</code>模拟<code>show()</code>:</p>
<ul>
<li><code>show</code>: 表示由透明到不透明</li>
<li><code>toggle</code>: 切换</li>
<li><code>hide</code>:表示由显示到隐藏</li>
</ul>
</li>
<li><p><strong>动画方法总结</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>hide()</code>和<code>show()</code></td>
<td align="left">同时修改多个样式属性即高度和宽度和不透明度</td>
</tr>
<tr>
<td align="left"><code>fadeIn()</code>和<code>fadeOut()</code></td>
<td align="left">只改变不透明度</td>
</tr>
<tr>
<td align="left"><code>slideUp()</code>和<code>slideDown()</code></td>
<td align="left">只改变高度</td>
</tr>
<tr>
<td align="left"><code>fadeTo()</code></td>
<td align="left">只改变不透明度</td>
</tr>
<tr>
<td align="left"><code>toggle()</code></td>
<td align="left">用来代替<code>show()</code>和<code>hide()</code>方法，所以会同时修改多个属性即高度、宽度和不透明度</td>
</tr>
<tr>
<td align="left"><code>slideToggle()</code></td>
<td align="left">用来代替<code>slideUp</code>和<code>slideDown()</code>方法，所以只能改变高度</td>
</tr>
<tr>
<td align="left"><code>fadeToggle()</code></td>
<td align="left">用来代替<code>fadeIn()</code>和<code>fadeOut</code>方法，只能改变不透明度</td>
</tr>
<tr>
<td align="left"><code>animate()</code></td>
<td align="left">属于自定义动画，以上各种动画方法都是调用了<code>animate</code>方法。此外，用<code>animate</code>方法还能自定义其他的样式属性，例如：<code>left``marginLeft ``scrollTop</code>等</td>
</tr>
</tbody></table>
<h4 id="第七节-jQuery中的事件"><a href="#第七节-jQuery中的事件" class="headerlink" title="第七节 jQuery中的事件"></a>第七节 jQuery中的事件</h4><hr>
<ul>
<li><p><strong>事件对象的属性</strong></p>
<ul>
<li><code>event.type</code>：获取事件的类型</li>
<li><code>event.target</code>:获取到触发事件的元素</li>
<li><code>event.preventDefault</code>方法 阻止默认事件行为</li>
<li><code>event.stopPropagation()</code>阻止事件的冒泡</li>
<li><code>keyCode</code>：只针对于<code>keypress</code>事件，获取键盘键数字 按下回车，<code>13</code></li>
<li><code>event.pageX / event.pageY</code> 获取到光标相对于页面的<code>x</code>坐标和<code>y</code>坐标<ul>
<li>如果没有<code>jQuery</code>，在IE浏览器中用<code>event.x</code> &#x2F; <code>event.y</code>;在<code>Firefox</code>浏览器中用<code>event.pageX</code> &#x2F; <code>event.pageY</code>。如果页面上有滚动条还要加上滚动条的宽度和高度</li>
</ul>
</li>
<li><code>event.clientX</code>：光标对于浏览器窗口的水平坐标 浏览器</li>
<li><code>event.clientY</code>：光标对于浏览器窗口的垂直坐标</li>
<li><code>event.screenX</code>：光标对于电脑屏幕的水平坐标 电脑屏幕</li>
<li><code>event.screenY</code>：光标对于电脑屏幕的水平坐标</li>
<li><code>event.which</code> 该方法的作用是在鼠标单击事件中获取到鼠标的左、中、右键，在键盘事件中的按键 <code>1</code>代表左键 <code>2</code>代表中键 <code>3</code>代表右键</li>
</ul>
</li>
<li><p><strong>事件冒泡</strong></p>
<ul>
<li>什么是冒泡<ul>
<li>在页面上可以有多个事件，也可以多个元素影响同一个元素</li>
<li>从里到外</li>
<li>嵌套关系</li>
<li>相同事件</li>
<li>其中的某一父类没有相同事件时,继续向上查找</li>
</ul>
</li>
<li>停止事件冒泡<ul>
<li>停止事件冒泡可以阻止事件中其他对象的事件处理函数被执行</li>
<li>在<code>jQuery</code>中提供了**<code>stopPropagation()</code>**方法</li>
</ul>
</li>
<li>阻止默认行为<ul>
<li>网页中元素有自己的默认行为，例如：单击超链接后会跳转、单击提交后表单会提交，有时需要阻止元素的默认行为</li>
<li>在<code>jQuery</code>中提供了<code>preventDefault()</code>方法来阻止元素的默认行为</li>
</ul>
</li>
<li>事件捕获<ul>
<li>事件捕获和冒泡是相反的过程，事件捕获是从最顶端往下开始触发</li>
<li>并非所有的浏览器都支持事件捕获，并且这个缺陷无法通过<code>JavaScript</code>来修复。<code>jQuery</code>不支持事件捕获，如需要用事件捕获，要用原生的<code>JavaScript</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>bind()</code>;绑定</strong></p>
<ul>
<li>为匹配元素绑定处理方法</li>
<li>需要给一个元素添加多个事件 ，事件执行一样时候</li>
<li><code>one()</code>：只执行一次</li>
</ul>
</li>
<li><p><strong>绑定特定事件类型方法</strong>：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">方法名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">页面载入</td>
<td align="left"><code>ready(fn)</code></td>
<td align="left">当<code>DOM</code>载入就绪可以绑定一个要执行的函数</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>blind(type,[data],fn)</code></td>
<td align="left">为每个匹配元素的特定事件绑定一个事件处理函数</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>unblind()</code></td>
<td align="left">解除绑定</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>on(events,[,selector[,]data],handler)</code></td>
<td align="left">在选择元素上绑定一个或者多个事件处理函数</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>off()</code></td>
<td align="left">移除<code>on</code>绑定的事件</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>delegate(selector,eventType,handler)</code></td>
<td align="left">为所有选择匹配元素附加一个或多个事件处理函数</td>
</tr>
<tr>
<td align="left">事件绑定</td>
<td align="left"><code>undelegate()</code></td>
<td align="left">移除绑定</td>
</tr>
<tr>
<td align="left">事件动态</td>
<td align="left"><code>live(type,fn)</code></td>
<td align="left">对动态生成的元素进行事件绑定</td>
</tr>
<tr>
<td align="left">事件动态</td>
<td align="left"><code>die(type,fn)</code></td>
<td align="left">移除<code>live()</code>绑定的事件</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>hover()</code></td>
<td align="left">鼠标移入移出</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>toggle(fn1,fn2,[fn3],[fn4])</code></td>
<td align="left">每单击后依次调用函数</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>blur(fn)</code></td>
<td align="left">触发每一个匹配元素的<code>blur</code>事件</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>change()</code></td>
<td align="left">触发每一个匹配元素的<code>change</code>事件</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>click()</code></td>
<td align="left">触发每一个匹配元素的<code>click</code>事件</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>focus()</code></td>
<td align="left">触发每一个匹配元素的<code>focus</code>事件</td>
</tr>
<tr>
<td align="left">交互事件</td>
<td align="left"><code>submit()</code></td>
<td align="left">触发每一个匹配元素的<code>submit</code>事件</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>keydown()</code></td>
<td align="left">触发每一个匹配元素的<code>keydown</code>事件</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>keypress()</code></td>
<td align="left">触发每一个匹配元素的<code>keypress</code>事件</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>keyup()</code></td>
<td align="left">触发每一个匹配元素的keyup事件</td>
</tr>
<tr>
<td align="left">鼠标事件</td>
<td align="left"><code>mousedown(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">鼠标事件</td>
<td align="left"><code>mouseenter(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>mouseleave(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>mouseout(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">键盘事件</td>
<td align="left"><code>mouseover(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">窗口操作</td>
<td align="left"><code>resize(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
<tr>
<td align="left">窗口操作</td>
<td align="left"><code>scroll(fn)</code></td>
<td align="left">绑定一个处理函数</td>
</tr>
</tbody></table>
<h4 id="第八节-jQuery与Ajax"><a href="#第八节-jQuery与Ajax" class="headerlink" title="第八节 jQuery与Ajax"></a>第八节 jQuery与Ajax</h4><hr>
<ul>
<li><p>Ajax</p>
<p>简介 :</p>
<ul>
<li><code>Asynchronous Javascript And XML</code> （异步的<br><code>JavaScript</code>和<code>XML</code>）</li>
<li>它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体</li>
</ul>
</li>
<li><p><code>Ajax</code>优势与不足</p>
<ul>
<li><p><code>Ajax</code>优势</p>
<ul>
<li><p>优秀的用户体验</p>
<ul>
<li>这是<code>Ajax</code>下最大的有点，能在不刷新整个页面前提下更新数据</li>
</ul>
</li>
<li><p>提高</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web</span><br></pre></td></tr></table></figure>

<p>程序的性能</p>
<ul>
<li>与传统模式相比，<code>Ajax</code>模式在性能上最大的区别在于传输数据的方式，在传统模式中，数据的提交时通过表单来实现的。<code>Ajax</code>模式只是通过<code>XMLHttpRequest</code>对象向服务器提交希望提交的数据，即按需发送</li>
</ul>
</li>
<li><p>减轻服务器和带宽的负担</p>
<ul>
<li><code>Ajax</code>的工作原理相当于在用户和服务器之间加了一个中间层，似用户操作与服务器响应异步化。它在客户端创建<code>Ajax</code>引擎，把传统方式下的一些服务器负担的工作转移到客户端，便于客户端资源来处理，减轻服务器和带宽的负担</li>
</ul>
</li>
</ul>
</li>
<li><p>Ajax的不足</p>
<ul>
<li>浏览器对<code>XMLHttpRequest</code>对象的支持度不足</li>
<li>破坏浏览器前进、后退按钮的正常功能</li>
<li>对搜索引擎的支持的不足</li>
<li>开发和调试工具的缺乏</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="创建一个Ajax请求"><a href="#创建一个Ajax请求" class="headerlink" title="创建一个Ajax请求"></a>创建一个Ajax请求</h5><hr>
<ul>
<li><p><code>Ajax</code>的核心是<code>XMLHttpRequest</code>对象，它是<code>Ajax</code>实现的关键，发送异步请求、接受响应以及执行回调都是通过它来完成</p>
</li>
<li><p><strong>创建<code>ajax</code>对象 <code>var xhr = new XMLHttpRequest();</code></strong></p>
</li>
<li><p><strong>准备发送请求</strong></p>
<ul>
<li><p><strong><code>get</code> &#x2F; <code>post</code></strong></p>
<ul>
<li><p><code>get</code></p>
<ul>
<li>传递的数据放在<code>URL</code>后面</li>
<li>中文编码 <code>encodeURI( &#39;&#39; )</code>;</li>
<li>缓存 在数据后面加上随机数或者日期对象或者……</li>
</ul>
</li>
<li><p><strong><code>post</code></strong></p>
<ul>
<li>传递的数据放在<code>send()</code>里面，并且一定要规定数据格式</li>
<li>没有缓存问题</li>
</ul>
</li>
<li><p><code>form</code>表单中:</p>
<ul>
<li>&#96;&#96;&#96;<br>action<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        :</span><br><span class="line"></span><br><span class="line">        - `method`: (默认是`get`)</span><br><span class="line">        - `get`: 会在`url`里面以 `name=value` , 两个数据之间用 `&amp;` 连接</span><br><span class="line"></span><br><span class="line">      - `post`:</span><br><span class="line"></span><br><span class="line">    - `enctype`: `&quot;application/x-www-form-urlencoded&quot;`</span><br><span class="line"></span><br><span class="line">  - `url`</span><br><span class="line"></span><br><span class="line">  - 是否异步</span><br><span class="line"></span><br><span class="line">    - 同步(`false`)：阻塞</span><br><span class="line">    - 异步(`true`)：非阻塞</span><br><span class="line"></span><br><span class="line">- **正式发送请求**</span><br><span class="line"></span><br><span class="line">- **`ajax`请求处理过程**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>xhr.onreadystatechange &#x3D; function(){<br>    if (xhr.readyState &#x3D;&#x3D; 4)<br>    {<br>        alert( xhr.responseText );<br>    }<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `onreadystatechange` ：当处理过程发生变化的时候执行下面的函数</span><br><span class="line">- `readyState` ：`ajax`处理过程</span><br><span class="line">  - 0：请求未初始化（还没有调用 `open()`）。</span><br><span class="line">  - 1：请求已经建立，但是还没有发送（还没有调用 `send()`）。</span><br><span class="line">  - 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。</span><br><span class="line">  - 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。</span><br><span class="line">  - 4：响应已完成；您可以获取并使用服务器的响应了。</span><br><span class="line">- `responseText` ：请求服务器返回的数据存在该属性里面</span><br><span class="line">- `status` : `http`状态码</span><br><span class="line"></span><br><span class="line">![HTTP状态码](http://7xq6al.com1.z0.glb.clouddn.com/jquery9.png)</span><br><span class="line"></span><br><span class="line">- 案例：`ajax`封装案例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;ajax请求后台数据<br>var btn &#x3D;  document.getElementsByTagName(“input”)[0];<br>btn.onclick &#x3D; function(){</p>
<pre><code>ajax(&#123;//json格式
    type:&quot;post&quot;,
    url:&quot;post.php&quot;,
    data:&quot;username=poetries&amp;pwd=123456&quot;,
    asyn:true,
    success:function(data)&#123;
        document.write(data);
    &#125;
&#125;);
</code></pre>
<p>}<br>&#x2F;&#x2F;封装ajax<br>function ajax(aJson){<br>    var ajx &#x3D; null;<br>    var type &#x3D; aJson.type || “get”;<br>    var asyn &#x3D; aJson.asyn || true;<br>    var url &#x3D; aJson.url;		&#x2F;&#x2F; url 接收 传输位置<br>    var success &#x3D; aJson.success;&#x2F;&#x2F; success 接收 传输完成后的回调函数<br>    var data &#x3D; aJson.data || ‘’;&#x2F;&#x2F; data 接收需要附带传输的数据</p>
<pre><code>if(window.XMLHttpRequest)&#123;//兼容处理
    ajx = new XMLHttpRequest();//一般浏览器
&#125;else
&#123;
    ajx = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE6+
&#125;
if (type == &quot;get&quot; &amp;&amp; data)
&#123;
    url +=&quot;/?&quot;+data+&quot;&amp;&quot;+Math.random();
&#125;

//初始化ajax请求
ajx.open( type , url , asyn );
//规定传输数据的格式
ajx.setRequestHeader(&#39;content-type&#39;,&#39;application/x-www-form-urlencoded&#39;);
//发送ajax请求（包括post数据的传输）
type == &quot;get&quot; ?ajx.send():ajx.send(aJson.data);

//处理请求
ajx.onreadystatechange = function(aJson)&#123;
    
if(ajx.readState == 4)&#123;
        
    if (ajx.status == 200 &amp;&amp; ajx.status&lt;300)//200是HTTP 请求成功的状态码
    &#123;
        //请求成功处理数据
        success &amp;&amp; success(ajx.responseText);
    &#125;else&#123;
        alert(&quot;请求出错&quot;+ajx.status);
        
    &#125;
&#125;
    
&#125;;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### jQuery中的Ajax [补充部分–来自锋利的jQuery]</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">`jquery`对`Ajax`操作进行了封装，在`jquery`中的`$.ajax()`方法属于最底层的方法，第`2`层是`load()`、`$.get()`、`$.post();`第`3`层是`$.getScript()`、`$.getJSON()`，第`2`层使用频率很高</span><br><span class="line"></span><br><span class="line">###### `load()`方法</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  load()</span><br></pre></td></tr></table></figure>

<p>  方法是</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jquery</span><br></pre></td></tr></table></figure>

<p>  中最简单和常用的</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax</span><br></pre></td></tr></table></figure>

<p>  方法，能载入远程</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br></pre></td></tr></table></figure>

<p>  代码并插入</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOM</span><br></pre></td></tr></table></figure>

<p>  中 结构为：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load(url,[data],[callback])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>url</code>参数指定选择符可以加载页面内的某些元素 <code>load</code>方法中<code>url</code>语法：<code>url selector</code> 注意：<code>url</code>和选择器之间有一个空格</p>
</li>
<li><p>传递方式</p>
<ul>
<li><code>load()</code>方法的传递方式根据参数<code>data</code>来自动指定，如果没有参数传递，则采用<code>GET</code>方式传递，反之，采用<code>POST</code></li>
</ul>
</li>
<li><p>回调参数</p>
<ul>
<li>必须在加载完成后才执行的操作，该函数有三个参数 分别代表请求返回的内容、请求状态、<code>XMLHttpRequest</code>对象</li>
<li>只要请求完成，回调函数就会被触发</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#testTest&quot;).load(&quot;test.html&quot;,function(responseText,textStatus,XMLHttpRequest)&#123;</span><br><span class="line">    //respnoseText 请求返回的内容</span><br><span class="line">    //textStatus 请求状态 ：sucess、error、notmodified、timeout</span><br><span class="line">    //XMLHttpRequest </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>load方法参数</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>url</code></td>
<td align="left"><code>String</code></td>
<td align="left">请求<code>HTML</code>页面的<code>URL</code>地址</td>
</tr>
<tr>
<td align="left"><code>data(可选)</code></td>
<td align="left"><code>Object</code></td>
<td align="left">发送至服务器的<code>key</code> &#x2F; <code>value</code>数据</td>
</tr>
<tr>
<td align="left"><code>callback(可选)</code></td>
<td align="left"><code>Function</code></td>
<td align="left">请求完成时的回调函数，无论是请求成功还是失败</td>
</tr>
</tbody></table>
<h6 id="get-和-post-方法"><a href="#get-和-post-方法" class="headerlink" title="$.get()和$.post()方法"></a>$.get()和$.post()方法</h6><hr>
<p><code>load()</code>方法通常用来从web服务器上获取静态的数据文件。在项目中需要传递一些参数给服务器中的页面，那么可以使用<code>$.get()</code>和<code>$.post()</code>或<code>$.ajax()</code>方法</p>
<ul>
<li><p>注意：<code>$.get()</code>和<code>$.post()</code>方法是<code>jquery</code>中的全局函数</p>
</li>
<li><p><strong>$.get()方法</strong></p>
<ul>
<li><p><code>$.get()</code>方法使用<code>GET</code>方式来进行异步请求</p>
</li>
<li><p>结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get(url,[data],callback,type)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果服务器返回的内容格式是<code>xml</code>文档，需要在服务器端设置<code>Content-Type</code>类型 代码如下：<code>header(&quot;Content-Type:text/xml:charset=utf-8&quot;)</code> &#x2F;&#x2F;<code>php</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>$.get()</code>方法参数解析</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>url</code></td>
<td align="left"><code>String</code></td>
<td align="left">请求<code>HTML</code>页的地址</td>
</tr>
<tr>
<td align="left"><code>data(可选)</code></td>
<td align="left"><code>Object</code></td>
<td align="left">发送至服务器的<code>key</code>&#x2F; <code>value</code> 数据会作为<code>QueryString</code>附加到请求URL中</td>
</tr>
<tr>
<td align="left"><code>callback(可选)</code></td>
<td align="left"><code>Function</code></td>
<td align="left">载入成功的回调函数（只有当<code>Response</code>的返回状态是success才调用该方法）</td>
</tr>
<tr>
<td align="left"><code>type(可选)</code></td>
<td align="left"><code>String</code></td>
<td align="left">服务器返回内容的格式，包括<code>xml</code>、<code>html</code>、<code>script</code>、<code>json</code>、<code>text</code>和<code>_default</code></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>$.post()方法</strong></p>
<ul>
<li><p>它与</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get()</span><br></pre></td></tr></table></figure>

<p>方法的结构和使用方式相同，有如下区别</p>
<ul>
<li>&#96;&#96;&#96;<br>GET<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">请求会将参数跟张乃URL后进行传递，而</span><br><span class="line"></span><br></pre></td></tr></table></figure>
POST<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">请求则是作为</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Http<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">消息的实体内容发送给web服务器，在</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ajax<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      请求中，这种区别对用户不可见</span><br><span class="line"></span><br><span class="line">      - `GET`方式对传输数据有大小限制（通常不能大于`2KB`），而使用`POST`方式传递的数据量要比`GET`方式大得多（理论不受限制）</span><br><span class="line">      - `GET`方式请求的数据会被浏览器缓存起来，因此其他人可以从浏览器的历史纪录中读取这些数据，如：账号、密码。在某种情况下，`GET`方式会带来严重的安全问题，而`POST`相对来说可以避免这些问题</span><br><span class="line">      - `GET`和`POST`方式传递的数据在服务端的获取也不相同。在`PHP`中，`GET`方式用`$_GET[]`获取；`POST`方式用`$_POST[]`获取;两种方式都可用`$_REQUEST[]`来获取</span><br><span class="line"></span><br><span class="line">- **总结**</span><br><span class="line"></span><br><span class="line">  - 使用`load()`、`$.get()`和`$.post()`方法完成了一些常规的`Ajax`程序，如果还需要复杂的`Ajax`程序，就需要用到`$.ajax()`方式</span><br><span class="line"></span><br><span class="line">###### $.ajax()方法</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- `$.ajax()`方法是`jquery`最底层的`Ajax`实现，它的结构为`$.ajax(options)`</span><br><span class="line">- 该方法只有一个参数，但在这个对象里包含了`$.ajax()`方式所需要的请求设置以及回调函等信息，参数以`key` / `value`存在，所有参数都是可选的</span><br><span class="line">- **$.ajax()方式常用参数解析**</span><br><span class="line"></span><br><span class="line">| 参数         | 类型       | 说明                                                         |</span><br><span class="line">| :----------- | :--------- | :----------------------------------------------------------- |</span><br><span class="line">| `url`        | `String`   | (默认为当前页地址)发送请求的地址                             |</span><br><span class="line">| `type`       | `String`   | 请求方式（`POST`或`GET`）默认为`GET`                         |</span><br><span class="line">| `timeout`    | `Number`   | 设置请求超时时间（毫秒）                                     |</span><br><span class="line">| `dataType`   | `String`   | 预期服务器返回的类型。可用的类型如下  **xml**:返回`XML`文档，可用`jquery`处理 **html**:返回纯文本的`HTML`信息，包含的`script`标签也会在插入`DOM`时执行 **script**：返回纯文本的`javascript`代码。不会自动缓存结果，除非设置`cache`参数。注意：在远程请求时，所有的`POST`请求都将转为`GET`请求 **json**:返回`JSON`数据 **jsonp**:`JSONP`格式，使用`jsonp`形式调用函数时，例如：`myurl?call back=?,jquery`将自动替换后一个`？`为正确的函数名，以执行回调函数 **text**:返回纯文本字符串 |</span><br><span class="line">| `beforeSend` | `Function` | 发送请求前可以修改`XMLHttpRequest`对象的函数，例如添加自定义`HTTP`头。在`beforeSend`中如果返回`false`可以取消本次`Ajax`请求。`XMLHttpRequest`对象是唯一的参数 function(XMLHttpRequest)&#123;      `this`;//调用本次`Ajax`请求时传递的`options`参数 &#125; |</span><br><span class="line">| `complete`   | `Function` | 请求完成后的回调函数（请求成功或失败时都调用） 参数：`XMLHttpRequest`对象和一个描述成功请求类型的字符串 function(XMLHttpRequest,textStatus)&#123;      `this`;//调用本次Ajax请求时传递的`options`参数 &#125; |</span><br><span class="line">| `success`    | `Function` | 请求成功后调用的回调函数，有两个参数 (1)由服务器返回，并根据`dataTyppe`参数进行处理后的数据 (2)描述状态的字符串 `function`(data,textStatus)&#123;      //`data`可能是`xmlDoc、``jsonObj`、`html`、`text`等      `this`;//调用本次`Ajax`请求时传递的`options`参数 &#125; |</span><br><span class="line">| `error`      | `Function` | 请求失败时被调用的函数                                       |</span><br><span class="line">| `global`     | `Boolean`  | 默认为`true`。表示是否触发全局`Ajax`事件，设置为`false`将不会触发。`AjaxStart`或`AjaxStop`可用于控制各种`Ajax`事件 |</span><br><span class="line"></span><br><span class="line">#### 第九节 插件</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **什么是插件**</span><br><span class="line">  - 插件(`Plugin`)也称为`jQuery`的扩展。以`jQuery`核心代码为基础编写的符合一定规范的应用程序。通过`js`文件的方式引用。</span><br><span class="line">- **插件分为哪几类**</span><br><span class="line">  - `UI`类、表单及验证类、输入类、特效类、`Ajax`类、滑动类、图形图像类、导航类、综合工具类、动画类等等</span><br><span class="line"></span><br><span class="line">- 引入插件的步骤</span><br><span class="line">  - 引入`jquery.js`文件，而且在所以插件之前引入</span><br><span class="line">  - 引入插件</span><br><span class="line">  - 引入插件相关文件，比如皮肤、中文包</span><br><span class="line"></span><br><span class="line">- **如何自定义插件**：</span><br><span class="line">  - 插件形式分为3类：</span><br><span class="line">    - 封装对象方法插件</span><br><span class="line">    - 封装全局函数插件</span><br><span class="line">    - 选择器插件(类似于.`find()`)</span><br><span class="line">- **自定义插件的规范**（解决各种插件的冲突和错误，增加成功率）</span><br><span class="line">  - 命名：`jquery.插件名.js`</span><br><span class="line">  - 所有的新方法附加在`jquery.fn`对象上面，所有新功能附加在`jquery`上</span><br><span class="line">  - 所有的方法或插件必须用分号结尾，避免出问题</span><br><span class="line">  - 插件必须返回jQuery对象，便于链式连缀</span><br><span class="line">  - 避免插件内部使用`$`，如果要使用，请传递`jQuery`(`$`并不是总等于`jQuery`，另外其他`js`框架也可能使用`$`)</span><br><span class="line">  - 插件中的`this`应该指向`jQuery`对象</span><br><span class="line">  - 使用`this.each()`迭代元素</span><br><span class="line">- **自定义插件案例**</span><br><span class="line">  - 为了方便用户创建插件，`jQuery`提供了 `jQuery.extend()` 和 `jQuery.fn.extend()`</span><br><span class="line">  - `jQuery.extend()`：创建工具函数或者是选择器</span><br><span class="line">  - `jQuery.fn.extend()`：创建`jQuery`对象命令 （`fn`相当于`prototype`的别名）</span><br><span class="line">- **`jQuery`官方提供的插件开发模板**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>;(function($){<br>    $.fn.plugin&#x3D;function(options){<br>        var defaults &#x3D; {<br>            &#x2F;&#x2F;各种参数 各种属性<br>        }<br>        var options &#x3D; $.extend(defaults,options);</p>
<pre><code>    this.each(function()&#123;
        //实现功能的代码
    &#125;);

    return this;
&#125;
</code></pre>
<p>})(jQuery);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**自定义`jQuery`函数**：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(function($){<br>    $.extend({<br>        test: function(){<br>            alert(“hello plugin”);<br>        }<br>    })<br>    })(jQuery);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**自定义`jQuery`命令**：</span><br><span class="line"></span><br><span class="line">- 形式1：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(function($){<br>    $.fn.extend({<br>        say : function(){<br>         alert(“hello plugin”);<br>    }<br>    })<br>})(jQuery);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 形式2：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(function($){<br>    $.fn.say &#x3D; function(){<br>        alert(“hello plugin”);<br>    };</p>
<p>})(jQuery);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 附录一 jQuery各个版本新增的一些常用的方法</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- `jQuery1.3`新增常用的方法</span><br><span class="line"></span><br><span class="line">| 方法         | 说明                                                         |</span><br><span class="line">| :----------- | :----------------------------------------------------------- |</span><br><span class="line">| `.closest()` | 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 |</span><br><span class="line">| `die()`      | 从元素中删除先前用`live()`方法绑定的所有的事件               |</span><br><span class="line">| `live()`     | 附加一个事件处理器到符合目前选择器的所有元素匹配             |</span><br><span class="line"></span><br><span class="line">- `jQuery1.4`新增常用的方法</span><br><span class="line"></span><br><span class="line">| 方法            | 说明                                                         |</span><br><span class="line">| :-------------- | :----------------------------------------------------------- |</span><br><span class="line">| `.first()`      | 获取集合中第一个元素                                         |</span><br><span class="line">| `last()`        | 获取集合中最后一个元素                                       |</span><br><span class="line">| `has(selector)` | 保留包含特定后代的元素，去掉那些不含有指定后代的元素         |</span><br><span class="line">| `detach()`      | 从`DOM`中去掉所有匹配的元素。`detach()`和`remov()`一样，除了`detach()`保存了所有`jquery`数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入`DOM`时，这种方法很有用 |</span><br><span class="line">| `delegate()`    | 为所有选择器匹配的元素附加一个处理一个或多个事件             |</span><br><span class="line">| `undelegate()`  | 为所有选择器匹配的元素删除一个处理一个或多个事件             |</span><br><span class="line"></span><br><span class="line">- `jQuery1.6`新增常用的方法</span><br><span class="line"></span><br><span class="line">| 方法                           | 说明                                     |</span><br><span class="line">| :----------------------------- | :--------------------------------------- |</span><br><span class="line">| `prop(proptyName)`             | 获取在匹配元素集合中的第一个元素的属性值 |</span><br><span class="line">| `removeProp(proptyName,value)` | 为匹配的元素删除设置的属性               |</span><br><span class="line">| `:focus`                       | 选择当前获取焦点的元素                   |</span><br><span class="line"></span><br><span class="line">#### 附录二 jQuery性能优化</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **性能优化**</span><br><span class="line"></span><br><span class="line">  - 使用最新版的jQuery类库</span><br><span class="line"></span><br><span class="line">  - 使用合适的选择器</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      $(#id)</span><br></pre></td></tr></table></figure>

<pre><code>  - 使用`id`来定位`DOM`元素是最佳的方式，为了提高性能，建议从最近的`ID`元素开始往下搜索

- ```
  $(&quot;p&quot;)
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
  $(&quot;div&quot;)
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
  $(&quot;input&quot;)
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 标签选择器性能也不错，它是性能优化的第二选择。因为`jQuery`将直接调用本地方法`document.getElementsByTagName()`来定位`DOM`元素</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  $(&quot;.class&quot;)</span><br></pre></td></tr></table></figure>

  - 建议有选择性的使用

- ```
  $(&quot;[attribute=value]&quot;)
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 对这个利用属性定位`DOM`元素，本地`JavaScript`并没有直接实现。这种方式性能并不是很理想。建议避免使用。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  $(&quot;:hidden&quot;)</span><br></pre></td></tr></table></figure>

  - 和上面利用属性定位`DOM`方式类似，建议尽量不要使用

- 注意的地方

  - 尽量使用`ID`选择器
  - 尽量给选择器指定上下文
</code></pre>
<ul>
<li><p>缓存对象</p>
<ul>
<li>如果你需要在其他函数中使用<code>jQuery</code>对象，你可以把他们缓存在全局环境中</li>
</ul>
</li>
<li><p>数组方式使用<code>jQuery</code>对象</p>
<ul>
<li>使用<code>jQuery</code>选择器获取的结果是一个<code>jQuery</code>对象。在性能方面，建议使用<code>for</code>或<code>while</code>循环来处理，而不是<code>$.each()</code></li>
</ul>
</li>
<li><p>事件代理</p>
<ul>
<li><p>每一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br></pre></td></tr></table></figure>

<p>事件（如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">click</span><br></pre></td></tr></table></figure>

<p>、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mouseove</span><br></pre></td></tr></table></figure>

<p>r）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时这点很有用。比如，我们要为一个表单绑定这样的行为：点击td后，把背景颜色设置为红色</p>
<ul>
<li><p><code>$(&quot;#myTable td&quot;).click(function()&#123;$(this).css(&quot;background&quot;,&quot;red&quot;);&#125;);</code></p>
</li>
<li><p>假设有<code>100</code>个<code>td</code>元素，在使用以上的方式时，绑定了<code>100</code>个事件，将带来性能影响</p>
</li>
<li><p>代替这种多元素的事件监听方法是，你只需向他们的父节点绑定一次事件，然后通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.target</span><br></pre></td></tr></table></figure>

<p>获取到点击的当前元素</p>
<ul>
<li><code>$(&quot;#myTable td&quot;).click(function(&#123;$(e.target).css(&quot;background&quot;,&quot;red&quot;)&#125;);</code></li>
<li><code>e.target</code>捕捉到触发的目标</li>
</ul>
</li>
<li><p>在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery1.7</span><br></pre></td></tr></table></figure>

<p>中提供了一个新的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on()</span><br></pre></td></tr></table></figure>

<p>，来帮助你将整个事件监听封装到一个便利的方法中</p>
<ul>
<li><code>$(&quot;#myTable td&quot;).on(&quot;click&quot;,&#39;td&#39;,function()&#123;$(this).css(&quot;background&quot;,&quot;red&quot;);&#125;);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>将你的代码转化成jQuery插件</p>
<ul>
<li>它能够使你的代码有更好的重用性，并且能够有效的帮助你组织代码</li>
</ul>
</li>
<li><p><strong>使用join()方法来拼接字符串</strong></p>
<ul>
<li>也许你之前使用<code>+</code>来拼接字符串，现在可以改了。它确实有助于性能优化，尤其是长字符串处理的时候</li>
</ul>
</li>
<li><p><strong>合理使用HTML5和Data属性</strong></p>
<ul>
<li>&#96;&#96;&#96;<br>HTML5<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
data<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">属性可以帮助我们插入数据，特别是后端的数据交换。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
jQuery<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Data()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法有效利用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
HTML5<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      的属性</span><br><span class="line"></span><br><span class="line">      - 例如：``</span><br><span class="line">      - 为了读取数据，你需要使用如下代码</span><br><span class="line">        - `$(&quot;#dl&#x27;).data(&quot;role&#x27;;//page)`</span><br><span class="line">        - `$(&quot;#dl&#x27;).data(&quot;lastValue&#x27;;//43)`</span><br><span class="line">        - `$(&quot;#dl&#x27;).data(&quot;options&#x27;;//john)`</span><br><span class="line"></span><br><span class="line">  - **尽量使用原生的JavaScript方法**</span><br><span class="line"></span><br><span class="line">  - 压缩JavaScript代码</span><br><span class="line"></span><br><span class="line">    - 一方面使用`Gzip`；另一方面去除`JavaScript`文件里面的注释、空白</span><br><span class="line"></span><br><span class="line">#### 附录三 常用的jQuery代码片段</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 禁用页面的右键菜单</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>$(document).ready(functuion(){<br>    $(document).bind(“contextmenu”,function(e){<br>        return false;<br>  });<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 新窗口打开页面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    &#x2F;&#x2F;例子1：href&#x3D;”http:&#x2F;&#x2F;“的链接将会在新窗口打开链接<br>    $(‘a[href&#x3D;^&#x3D;”http:&#x2F;&#x2F;“]’).attr(“target”,”_blank”);</p>
<p>  &#x2F;&#x2F;例子2：rel&#x3D;”external”的超链接将会在新窗口打开链接<br>    $(“a[rel$&#x3D;’external’]”).click(function(){<br>      this.target &#x3D; “_blank”;<br>    });<br>});<br>&#x2F;&#x2F;use<br><a target="_blank" href="http://baidu.com" rel="external noopener">open</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 判断浏览器类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).reday(function(){<br>    &#x2F;&#x2F;Firefox2 and above<br>    if( $.browser.mozilla &amp;&amp; $.browser.version&gt;&#x3D;”1.8”){<br>      &#x2F;&#x2F;do something<br>  }</p>
<p>  &#x2F;&#x2F; Safari<br>  if($.browser.safari){<br>     &#x2F;&#x2F;do something<br>  }</p>
<p>  &#x2F;&#x2F; Chrome<br>  if($.browser.chrome){<br>     &#x2F;&#x2F;do something<br>  }</p>
<p>  &#x2F;&#x2F; Opera<br>  if($.browser.opera){<br>     &#x2F;&#x2F;do something<br>  }</p>
<p>})</p>
<p>  &#x2F;&#x2F; IE6 and blow<br>  if($.browser.msie &amp;&amp; $.browser.version&lt;&#x3D;6){<br>     &#x2F;&#x2F;do something<br>  }</p>
<p>  &#x2F;&#x2F; anything above IE6<br>  if($.browser.msie &amp;&amp; $.browser.version &gt; 6){<br>     &#x2F;&#x2F;do something<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 输入框文字获取和失去焦点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    $(“input.text1”).val(“Enter you search text here”);<br>    textFill($(‘input.text1’));<br>});</p>
<p>function textFill(input){&#x2F;&#x2F;input focus text function<br>    var originvalue &#x3D; input.val();<br>    input.focus(funtion(){<br>        if($.trim(input.val())&#x3D;&#x3D; originvalue){<br>            input.val(‘ ‘);<br>        }<br>  }).blur(function(){<br>      if($.trim(input.val()) &#x3D;&#x3D; ‘ ‘){<br>          input.val(originalvalue);<br>      }<br>  })<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 获取鼠标位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>  $(document).mousemove(function(e){<br>      $(“#XY”).html(“X:” + e.pageX+ “| Y” + e.pageY);<br>  });<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 判断元素是否存在</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    if($(“#id”).length){<br>      &#x2F;&#x2F; do some thing<br>  }<br>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 点击div也可以跳转</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(“div”).click(function(){<br>    window.location  &#x3D; $(this).find(“a”).attr(“href”);<br>})</p>
<p>&#x2F;&#x2F;use</p>
<div><a href="index.html">home</a></div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 设置div在屏幕中央</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$(document).ready(function(){
    jQuery.fn.center = function(){
        this.css("position","absolute");
        this.css("top",($(window).height() - this.lenght()) / 2 +$(window).scrollTop() + "px"); 
        this.css("left",($(window).height() - this.lenght()) / 2 +$(window).scrollLeft() + "px"); 
      return this;
  }
//use 

<p> $(“#XY”).center();<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 关闭所有动画效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    jQuery.fx.off &#x3D; true;<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 检测鼠标的右键和左键</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    $(“#xy”).mousedown(function(e){<br>        alert(e.which);&#x2F;&#x2F;1 &#x3D; 鼠标左键  2&#x3D; 鼠标中间 3 &#x3D; 鼠标右键<br>  });<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 回车提交表单</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>    $(“input”).keyup(function(e){<br>        if(e.which &#x3D;&#x3D; “13”){<br>            alert(“回车提交”);<br>      }<br>  })<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 设置全局的Ajax参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(“#load”).ajaxStart(function(){<br>    showLoading();&#x2F;&#x2F;显示loading<br>    disableButtons() &#x2F;&#x2F;禁用按钮<br>})<br> $(“#load”).ajaxComplete(function(){<br>    hideLoading();&#x2F;&#x2F;隐藏loading<br>    enableButtons();&#x2F;&#x2F;启用按钮<br>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 获取选中的下拉框</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(“#someElement”).find(‘option:selected’);<br>$(“#someElement option:selected”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 切换复选框</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var tog &#x3D; false;<br>$(“button”).click(function(){<br>    $(“input[type&#x3D;checkbox]’).attr(“checked”,!tog);<br>    tog &#x3D; !tog;<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 个性化链接</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function(){<br>     $(“a[href$&#x3D;’pdf’]”).addClass(“pdf”);<br>     $(“a[href$&#x3D;’zip’]”).addClass(“zip”);<br>     $(“a[href$&#x3D;’psd’]”).addClass(“psd”);<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在一段时间后自动隐藏或关闭元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>setTimeOut(function(){<br>        $(“div”).fadeIn(400);<br>  },3000);</p>
<p>&#x2F;&#x2F;而在1.4之后的版本可以用delay()来实现<br>$(“div”).slideUp(300).delay(3000).fadeIn(400);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用事件代理绑定元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> &#x2F;&#x2F;为table里面的td元素绑定click事件，不管td是一直存在还是动态创建的<br> &#x2F;&#x2F;jQuery 1.4.2之前使用这种方式<br> $(“table”).each(function(){<br>    $(“td”,this).live(“click”,function(){<br>       $(this).toggleClass(“hover”);<br>    });<br>});</p>
<p>&#x2F;&#x2F;jquery 1.4.2使用的方式</p>
<p>$(“table”).delegate(“td”,”click”,function(){<br>    $(this).toggleClass(“hover”);<br>});</p>
<p>&#x2F;&#x2F;jQuery1.7.1使用的方式<br>$(“table”).on(“click”,”td”,function(){<br>    $(this).toggleClass(“hover”);<br> })</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 预加载图片</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(function($) {<br>  var cache &#x3D; [];<br>  &#x2F;&#x2F; Arguments are image paths relative to the current page.<br>  $.preLoadImages &#x3D; function() {<br>    var args_len &#x3D; arguments.length;<br>    for (var i &#x3D; args_len; i–;) {<br>      var cacheImage &#x3D; document.createElement(‘img’);<br>      cacheImage.src &#x3D; arguments[i];<br>      cache.push(cacheImage);<br>    }<br>  }<br>jQuery.preLoadImages(“image1.gif”, “&#x2F;path&#x2F;to&#x2F;image2.png”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 让页面中的每个元素都适合在移动设备上展示</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var scr &#x3D; document.createElement(‘script’);<br>scr.setAttribute(‘src’, ‘<a target="_blank" rel="noopener" href="https://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js&#39;">https://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js&#39;</a>);<br>document.body.appendChild(scr);<br>scr.onload &#x3D; function(){<br>    $(‘div’).attr(‘class’, ‘’).attr(‘id’, ‘’).css({<br>        ‘margin’ : 0,<br>        ‘padding’ : 0,<br>        ‘width’: ‘100%’,<br>        ‘clear’:’both’<br>    });<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 图像等比例缩放</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(window).bind(“load”, function() {<br>    &#x2F;&#x2F; IMAGE RESIZE<br>    $(‘#product_cat_list img’).each(function() {<br>        var maxWidth &#x3D; 120;<br>        var maxHeight &#x3D; 120;<br>        var ratio &#x3D; 0;<br>        var width &#x3D; $(this).width();<br>        var height &#x3D; $(this).height();<br>        if(width &gt; maxWidth){<br>            ratio &#x3D; maxWidth &#x2F; width;<br>            $(this).css(“width”, maxWidth);<br>            $(this).css(“height”, height * ratio);<br>            height &#x3D; height * ratio;<br>        }<br>        var width &#x3D; $(this).width();<br>        var height &#x3D; $(this).height();<br>        if(height &gt; maxHeight){<br>            ratio &#x3D; maxHeight &#x2F; height;<br>            $(this).css(“height”, maxHeight);<br>            $(this).css(“width”, width * ratio);<br>            width &#x3D; width * ratio;<br>        }<br>    });<br>    &#x2F;&#x2F;$(“#contentpage img”).show();<br>    &#x2F;&#x2F; IMAGE RESIZE<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 返回页面顶部</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; Back To Top<br>$(document).ready(function(){<br>  $(‘.top’).click(function() {<br>     $(document).scrollTo(0,500);<br>  });<br>});<br>&#x2F;&#x2F;Create a link defined with the class .top<br><a href="#" class="top">Back To Top</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用jQuery打造手风琴式的折叠效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var accordion &#x3D; {<br>     init: function(){<br>           var $container &#x3D; $(‘#accordion’);<br>           $container.find(‘li:not(:first) .details’).hide();<br>           $container.find(‘li:first’).addClass(‘active’);<br>           $container.on(‘click’,’li a’,function(e){<br>                  e.preventDefault();<br>                  var $this &#x3D; $(this).parents(‘li’);<br>                  if($this.hasClass(‘active’)){<br>                         if($(‘.details’).is(‘:visible’)) {<br>                                $this.find(‘.details’).slideUp();<br>                         } else {<br>                                $this.find(‘.details’).slideDown();<br>                         }<br>                  } else {<br>                         $container.find(‘li.active .details’).slideUp();<br>                         $container.find(‘li’).removeClass(‘active’);<br>                         $this.addClass(‘active’);<br>                         $this.find(‘.details’).slideDown();<br>                  }<br>           });<br>     }<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用jQuery和Ajax自动填充选择框</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(function(){<br>$(“select#ctlJob”).change(function(){<br>$.getJSON(“&#x2F;select.php”,{id: $(this).val(), ajax: ‘true’}, function(j){<br>var options &#x3D; ‘’;<br>for (var i &#x3D; 0; i &lt; j.length; i++) {<br>options +&#x3D; ‘<br>‘ + j[i].optionDisplay + ‘<br>‘;<br>}<br>$(“select#ctlPerson”).html(options);<br>})<br>})<br>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 自动替换丢失的图片</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; Safe Snippet<br>$(“img”).error(function () {<br>    $(this).unbind(“error”).attr(“src”, “missing_image.gif”);<br>});<br>&#x2F;&#x2F; Persistent Snipper<br>$(“img”).error(function () {<br>    $(this).attr(“src”, “missing_image.gif”);<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 预防对表单进行多次提交</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(document).ready(function() {<br>  $(‘form’).submit(function() {<br>    if(typeof jQuery.data(this, “disabledOnSubmit”) &#x3D;&#x3D; ‘undefined’) {<br>      jQuery.data(this, “disabledOnSubmit”, { submited: true });<br>      $(‘input[type&#x3D;submit], input[type&#x3D;button]’, this).each(function() {<br>        $(this).attr(“disabled”, “disabled”);<br>      });<br>      return true;<br>    }<br>    else<br>    {<br>      return false;<br>    }<br>  });<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 动态添加表单元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;change event on password1 field to prompt new input<br>$(‘#password1’).change(function() {<br>        &#x2F;&#x2F;dynamically create new input and insert after password1<br>        $(“#password1”).append(“”);<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在窗口滚动时自动加载内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var loading &#x3D; false;<br>$(window).scroll(function(){<br>    if((($(window).scrollTop()+$(window).height())+250)&gt;&#x3D;$(document).height()){<br>        if(loading &#x3D;&#x3D; false){<br>            loading &#x3D; true;<br>            $(‘#loadingbar’).css(“display”,”block”);<br>            $.get(“load.php?start&#x3D;”+$(‘#loaded_max’).val(), function(loaded){<br>                $(‘body’).append(loaded);<br>                $(‘#loaded_max’).val(parseInt($(‘#loaded_max’).val())+50);<br>                $(‘#loadingbar’).css(“display”,”none”);<br>                loading &#x3D; false;<br>            });<br>        }<br>    }<br>});<br>$(document).ready(function() {<br>    $(‘#loaded_max’).val(50);<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 导航菜单背景切换效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul id='nav'> 
    <li>导航一</li> 
    <li>导航二</li> 
    <li>导航三</li>
</ul>

<p>&#x2F;&#x2F;注意：代码需要修饰完善</p>
<p>$(‘#nav’).click(function(e) {<br> &#x2F;&#x2F; 要知道siblings的使用          </p>
<p>$(e.target).addClass(‘tclass’).siblings(‘.tclass’).removeClass(‘tclass’);;</p>
<p> });</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解决`jQuery`, `prototype`共存，`$`全局变量冲突问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<script src="prototype.js"></script>
<script src="http://blogbeta.blueidea.com/jquery.js"></script>
<script type="text/javascript"> jQuery.noConflict();</script> 

<p>注意：一定要先引入prototype.js 再引入jquery.js，先后顺序不可错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- jQuery 判断元素上是否绑定了事件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;jQuery event封装支持判断元素上是否绑定了事件，此方法只适用于jQuery绑定的事件<br>var $events &#x3D; $(“#foo”).data(“events”);<br>if( $events &amp;&amp; $events[“click”] ){　　<br>    &#x2F;&#x2F;your code<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如何正确地使用`toggleClass`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;切换（toggle）类允许你根据某个类的&#x2F;&#x2F;是否存在来添加或是删除该类。<br>&#x2F;&#x2F;这种情况下有些开发者使用：<br>a.hasClass(‘blueButton’) ? a.removeClass(‘blueButton’) : a.addClass(‘blueButton’);<br>&#x2F;&#x2F;toggleClass允许你使用下面的语句来很容易地做到这一点<br>a.toggleClass(‘blueButton’);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如何设置IE特有的功能</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>if ($.browser.msie) {<br>    &#x2F;&#x2F; Internet Explorer就是个虐待狂<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如何验证某个元素是否为空</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 方法一<br>if (! $(‘#keks’).html()) {<br>    &#x2F;&#x2F;什么都没有找到;<br>}<br>&#x2F;&#x2F; 方法二<br>if ($(‘#keks’).is(“:empty”)) {<br>    &#x2F;&#x2F;什么都没有找到;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 访问IFrame里的元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var iFrameDOM &#x3D; $(“iframe#someID”).contents();<br>&#x2F;&#x2F;然后，就可以通过find方法来遍历获取iFrame中的元素了<br>iFrameDOM.find(“.message”).slideUp();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 管理搜索框的值</span><br><span class="line">  - 现在各大网站都有搜索框，而搜索框通常都有默认值，当输入框获取焦点时，默认值消失。而一旦输入框失去焦点，而输入框里又没有输入新的值，输入框里的值又会恢复成默认值，如果往输入框里输入了新值，则输入框的值为新输入的值。这种特效用`JQuery`</span><br><span class="line">    很容易实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$(“#searchbox”) .focus(function(){<br>      $(this).val(‘’)<br>}) .blur(function(){<br>     var $this &#x3D; $(this);<br>    &#x2F;&#x2F; ‘请搜索…’为搜索框默认值<br>    ($this.val() &#x3D;&#x3D;&#x3D; ‘’)? $this.val(‘请搜索…’) : null;<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 部分页面加载更新</span><br><span class="line">  - 为了提高`web`性能，有更新时我们通常不会加载整个页面，而只是仅仅更新部分页面内容，如图片的延迟加载等。页面部分刷新的特效在`JQuery`中也很容易实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>setInterval(function() {<br>&#x2F;&#x2F;每隔5秒钟刷新页面内容 &#x2F;&#x2F;获取的内容将增加到 id为content的元素后 </p>
<p>$(“#content”).load(url); }, 5000);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 采配置JQuery与其它库的兼容性</span><br><span class="line">  - 如果在项目中使用`JQuery`，`$` 是最常用的变量名，但`JQuery`并不是唯一一个使用`$`作为变量名的库，为了避免命名冲突，你可以按照下面方式来组织你的代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;方法一： 为JQuery重新命名为<br> $jvar $j &#x3D; jQuery.noConflict();$j(‘#id’)…. &#x2F;&#x2F;</p>
<p>方法二： 推荐使用的方式</p>
<p>(function($){ $(document).ready(function(){<br>     &#x2F;&#x2F;这儿，你可以正常的使用JQuery语法 });<br>})(jQuery);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 测试密码的强度</span><br><span class="line">  - 在某些网站注册时常常会要求设置密码，网站也会根据输入密码的字符特点给出相应的提示，如密码过短、强度差、强度中等、强度强等。这又是怎么实现的呢？看下面代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><input type="password" name="pass" id="pass" /> <span id="passstrength"></span><br>&#x2F;&#x2F;下面的正则表达式建议各位收藏哦，项目上有可能会用得着<br>$(‘#pass’).keyup(function(e) { </p>
<p>&#x2F;&#x2F;密码为八位及以上并且字母数字特殊字符三项都包括<br>var strongRegex &#x3D; new RegExp(“^(?&#x3D;.{8,})(?&#x3D;.<em>[A-Z])(?&#x3D;.</em>[a-z])(?&#x3D;.*[0-9])(?&#x3D;.<em>\W).</em>$”, “g”); </p>
<p>&#x2F;&#x2F;密码为七位及以上并且字母、数字、特殊字符三项中有两项，强度是中等<br> var mediumRegex &#x3D; new RegExp(“^(?&#x3D;.{7,})(((?&#x3D;.<em>[A-Z])(?&#x3D;.</em>[a-z]))|((?&#x3D;.<em>[A-Z])(?&#x3D;.</em>[0-9]))|((?&#x3D;.<em>[a-z])(?&#x3D;.</em>[0-9]))).<em>$”, “g”);<br>var enoughRegex &#x3D; new RegExp(“(?&#x3D;.{6,}).</em>“, “g”); </p>
<p>if (false &#x3D;&#x3D; enoughRegex.test($(this).val())) { </p>
<p>$(‘#passstrength’).html(‘More Characters’); }<br> else if (strongRegex.test($(this).val())) {<br>     $(‘#passstrength’).className &#x3D; ‘ok’;<br>     $(‘#passstrength’).html(‘Strong!’); }<br>else if (mediumRegex.test($(this).val())) {<br>    $(‘#passstrength’).className &#x3D; ‘alert’;<br>    $(‘#passstrength’).html(‘Medium!’); }<br> else {<br>    $(‘#passstrength’).className &#x3D; ‘error’;<br>    $(‘#passstrength’).html(‘Weak!’);<br>}<br>return true;</p>
<p>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 附录四 常见CND加速服务</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- [Bootstrap中文网开源项目免费 CDN 服务](http://www.bootcdn.cn/)</span><br><span class="line">- [百度静态资源公共库](http://cdn.code.baidu.com/)</span><br><span class="line">- [360网站卫士常用前端公共库CDN服务–已停止服务](http://libs.useso.com/)</span><br><span class="line">- [开放静态文件 CDN](http://staticfile.org/)</span><br><span class="line">- [微软CDN服务](http://www.asp.net/ajax/cdn)</span><br><span class="line">- [阿里云](https://bbs.aliyun.com/read/139395.html)</span><br><span class="line">- [百度开放云平台](http://developer.baidu.com/wiki/index.php?title=docs/cplat/libs)</span><br><span class="line">- [jQuery CDN](http://code.jquery.com/)</span><br><span class="line">- [jQuery cdn加速](http://www.jq22.com/cdn/)</span><br><span class="line">- [新浪CDN](http://lib.sinaapp.com/)</span><br><span class="line"></span><br><span class="line">#### 附录五 jQuery的一些资源</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 速查手册</span><br><span class="line"></span><br><span class="line">  - [jQuery API 中文文档–css88](http://www.css88.com/jqapi-1.9/)</span><br><span class="line">  - [jQuery-overapi](http://overapi.com/jquery)</span><br><span class="line">  - [在线桌面版API](http://www.sxt.cn/searchsxt/sxtapipro/index.html)</span><br><span class="line">  - [更多详情—一份实用的API参考手册集合](https://github.com/poetries/mywiki/blob/master/bookmark/实用参考手册API.md)</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  jQuery</span><br></pre></td></tr></table></figure>

<p>  插件</p>
<ul>
<li>基础常用<ul>
<li><a target="_blank" rel="noopener" href="http://caibaojian.com/scrollfix">滚动固定在某个位置</a></li>
<li><a target="_blank" rel="noopener" href="http://caibaojian.com/power-slider">jQuery图片滚动插件全能版</a></li>
<li><a target="_blank" rel="noopener" href="http://code.ciaoca.com/jquery/wookmark/?utm_source=caibaojian.com">jQuery Wookmark Load 瀑布流布局</a></li>
<li><a target="_blank" rel="noopener" href="http://code.ciaoca.com/jquery/jcrop/?utm_source=caibaojian.com">jQuery Jcrop 图像裁剪</a></li>
<li><a target="_blank" rel="noopener" href="http://code.ciaoca.com/jquery/kxbdmarquee/?utm_source=caibaojian.com">jQuery kxbdMarquee 无缝滚动</a></li>
<li><a target="_blank" rel="noopener" href="http://code.ciaoca.com/jquery/lightbox/?utm_source=caibaojian.com">jQuery lightBox 灯箱效果</a></li>
<li><a target="_blank" rel="noopener" href="http://www.appelsiini.net/projects/lazyload?utm_source=caibaojian.com">Lazy Load Plugin for jQuery</a></li>
</ul>
</li>
<li>更多插件-动效库整理<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/poetries/mywiki/blob/master/bookmark/%E6%8F%92%E4%BB%B6%E5%BA%93.md">插件动效库</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/poetries/mywiki/blob/master/bookmark/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6.md">常用组件</a></li>
</ul>
</li>
</ul>
<h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><hr>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/aaronjs/p/3279314.html">jQuery源码分析系列</a></li>
</ul>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/12/html+css+js+ts/jQuery%E6%80%BB%E7%BB%93/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-前端性能优化-03">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/09/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8FAPI%EF%BC%88web%E6%8F%90%E4%BE%9B%EF%BC%8C%E5%8A%A8%E6%80%81%E6%B5%8B%E9%87%8F%EF%BC%89/">前端性能优化-03</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-09
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/%E4%BC%98%E5%8C%96/" class="cube-excerpt-tag-link">#优化</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="Web-Api"><a href="#Web-Api" class="headerlink" title="Web Api"></a>Web Api</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427135134108.png" alt="image-20220427135134108"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427135953185.png" alt="image-20220427135953185"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427135638721.png" alt="image-20220427135638721"></p>
<h2 id="页面渲染原理"><a href="#页面渲染原理" class="headerlink" title="页面渲染原理"></a>页面渲染原理</h2><p><strong><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140026412.png" alt="image-20220427140026412"></strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140215339.png" alt="image-20220427140215339"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140251251.png" alt="image-20220427140251251"></p>
<p>浏览器解释器  将他们翻译成浏览器认识的形式。</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140455463.png" alt="image-20220427140455463"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140508402.png" alt="image-20220427140508402"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427140829766.png" alt="image-20220427140829766"></p>
<h2 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427141037729.png" alt="image-20220427141037729"></p>
<p>里纳西不断的回流：</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427141659895.png" alt="image-20220427141659895"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427141728695.png" alt="image-20220427141728695"></p>
<h2 id="fastdom"><a href="#fastdom" class="headerlink" title="fastdom"></a>fastdom</h2><p>批量对DOM的读写操作     先执行读操作  后执行写操作</p>
<p>强制布局：很卡顿（连续的强制读写更新） 但是使用了fastdom(读写分离)后执行就会流畅</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427144318668.png" alt="image-20220427144318668"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427144353664.png" alt="image-20220427144353664"></p>
<h2 id="复合线程与图层"><a href="#复合线程与图层" class="headerlink" title="复合线程与图层"></a>复合线程与图层</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427144903921.png" alt="image-20220427144903921"></p>
<p>在控制太我们通过frame就可以查看对应图层</p>
<p>这些不会触发布局和重绘，只会触发复合的过程给他们一个图层</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427145049336.png" alt="image-20220427145049336"></p>
<p>查看图层：</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427145130349.png" alt="image-20220427145130349"></p>
<p>查看交互点击第一个录制，然后停止就可以查看</p>
<p>第二个刷新只页面重新加载  。</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427145223610.png" alt="image-20220427145223610"></p>
<p>图层越多 开销也会越大。</p>
<h2 id="减少重绘"><a href="#减少重绘" class="headerlink" title="减少重绘"></a>减少重绘</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427150359238.png" alt="image-20220427150359238"></p>
<p>render：选中第一个它会告诉我们谁会重绘并且标问绿色</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427150050337.png" alt="image-20220427150050337"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427150133967.png" alt="image-20220427150133967"></p>
<h2 id="高频事件处理函数-防抖"><a href="#高频事件处理函数-防抖" class="headerlink" title="高频事件处理函数 防抖"></a>高频事件处理函数 防抖</h2><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427150900593.png" alt="image-20220427150900593"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427151047338.png" alt="image-20220427151047338"></p>
<p>事件触发  js  触发视觉变换   1帧开始    raf在  之前进行布局和绘制，</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427150955637.png" alt="image-20220427150955637"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427151104506.png" alt="image-20220427151104506"></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/09/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8FAPI%EF%BC%88web%E6%8F%90%E4%BE%9B%EF%BC%8C%E5%8A%A8%E6%80%81%E6%B5%8B%E9%87%8F%EF%BC%89/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-js 异步处理">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/06/html+css+js+ts/3-js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/">js 异步处理</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-06
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/javascript/" class="cube-excerpt-tag-link">#javascript</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <blockquote>
<p>整理于互联网</p>
</blockquote>
<blockquote>
<ul>
<li>在<code>JavaScript</code>的世界中，所有代码都是单线程执行的</li>
<li>由于这个“缺陷”，导致<code>JavaScript</code>的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现</li>
<li>异步操作会在将来的某个时间点触发一个函数调用</li>
</ul>
</blockquote>
<ul>
<li>主流的异步处理方案主要有：回调函数<code>(CallBack)</code>、<code>Promise</code>、<code>Generator</code>函数、<code>async/await</code>。</li>
</ul>
<h2 id="一、回调函数-CallBack"><a href="#一、回调函数-CallBack" class="headerlink" title="一、回调函数(CallBack)"></a>一、回调函数(CallBack)</h2><hr>
<ul>
<li>这是异步编程最基本的方法</li>
<li>假设我们有一个 <code>getData</code> 方法，用于异步获取数据，第一个参数为请求的 <code>url</code> 地址，第二个参数是回调函数，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getData (url, callBack) &#123;</span><br><span class="line">    // 模拟发送网络请求</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        // 假设 res 就是返回的数据</span><br><span class="line">        var res = &#123;</span><br><span class="line">            url: url,</span><br><span class="line">            data: Math.random()</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行回调，将数据作为参数传递</span><br><span class="line">        callBack(res)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们预先设定一个场景，假设我们要请求三次服务器，每一次的请求依赖上一次请求的结果，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getData(&#x27;/page/1?param=123&#x27;, (res1) =&gt; &#123;</span><br><span class="line">    console.log(res1)</span><br><span class="line">    getData(`/page/2?param=$&#123;res1.data&#125;`, (res2) =&gt; &#123;</span><br><span class="line">        console.log(res2)</span><br><span class="line">        getData(`/page/3?param=$&#123;res2.data&#125;`, (res3) =&gt; &#123;</span><br><span class="line">            console.log(res3)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过上面的代码可以看出，第一次请求的 <code>url</code> 地址为：<code>/page/1?param=123</code>，返回结果为 <code>res1</code>。</li>
<li>第二个请求的 <code>url</code> 地址为：<code>/page/2?param=$&#123;res1.data&#125;</code>，依赖第<code>一次请求的</code>res1.data<code>，返回结果为</code>res2&#96;。</li>
<li>第三次请求的 <code>url</code>地址为：<code>/page/3?param=$&#123;res2.data&#125;</code>，依赖第二次请求的 <code>res2.data</code>，返回结果为 <code>res3</code>。</li>
<li>由于后续请求依赖前一个请求的结果，所以我们只能把下一次请求写到上一次请求的回调函数内部，这样就形成了常说的：回调地狱。</li>
</ul>
<h2 id="二、发布-x2F-订阅"><a href="#二、发布-x2F-订阅" class="headerlink" title="二、发布&#x2F;订阅"></a>二、发布&#x2F;订阅</h2><blockquote>
<p>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（<code>publish</code>）一个信号，其他任务可以向信号中心”订阅”（<code>subscribe</code>）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布&#x2F;订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）</p>
</blockquote>
<ul>
<li>这个模式有多种实现，下面采用的是Ben Alman的<a target="_blank" rel="noopener" href="https://gist.github.com/661855">Tiny Pub&#x2F;Sub</a>，这是<code>jQuery</code>的一个插件</li>
<li>首先，<code>f2</code>向”信号中心”<code>jQuery</code>订阅”<code>done</code>“信号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(&quot;done&quot;, f2);</span><br></pre></td></tr></table></figure>

<ul>
<li>f1进行如下改写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">　　　　setTimeout(function () &#123;</span><br><span class="line">　　　　　　// f1的任务代码</span><br><span class="line">　　　　　　jQuery.publish(&quot;done&quot;);</span><br><span class="line">　　　　&#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>jQuery.publish(&quot;done&quot;)</code>的意思是，<code>f1</code>执行完成后，向”信号中心<code>&quot;jQuery</code>发布<code>&quot;done&quot;</code>信号，从而引发f2的执行。 此外，f2完成执行后，也可以取消订阅（<code>unsubscribe</code>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.unsubscribe(&quot;done&quot;, f2);</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</li>
</ul>
<h2 id="三、Promise"><a href="#三、Promise" class="headerlink" title="三、Promise"></a>三、Promise</h2><hr>
<blockquote>
<ul>
<li><code>Promise</code> 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大</li>
<li>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<code>Promise</code> 提供统一的 <code>API</code>，各种异步操作都可以用同样的方法进行处理</li>
</ul>
</blockquote>
<ul>
<li>简单说，它的思想是，每一个异步任务返回一个<code>Promise</code>对象，该对象有一个<code>then</code>方法，允许指定回调函数。</li>
<li>现在我们使用 <code>Promise</code> 重新实现上面的案例，首先，我们要把异步请求数据的方法封装成 <code>Promise</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getDataAsync (url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            var res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: Math.random()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>那么请求的代码应该这样写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getDataAsync(&#x27;/page/1?param=123&#x27;)</span><br><span class="line">    .then(res1 =&gt; &#123;</span><br><span class="line">        console.log(res1)</span><br><span class="line">        return getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(res2 =&gt; &#123;</span><br><span class="line">        console.log(res2)</span><br><span class="line">        return getDataAsync(`/page/3?param=$&#123;res2.data&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(res3 =&gt; &#123;</span><br><span class="line">        console.log(res3)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>then</code> 方法返回一个新的 <code>Promise</code> 对象，<code>then</code> 方法的链式调用避免了 <code>CallBack</code> 回调地狱</li>
<li>但也并不是完美，比如我们要添加很多 <code>then</code> 语句， 每一个 <code>then</code> 还是要写一个回调。</li>
<li>如果场景再复杂一点，比如后边的每一个请求依赖前面所有请求的结果，而不仅仅依赖上一次请求的结果，那会更复杂。 为了做的更好，<code>async/await</code> 就应运而生了，来看看使用 <code>async/await</code> 要如何实现</li>
</ul>
<h2 id="四、async-x2F-await"><a href="#四、async-x2F-await" class="headerlink" title="四、async&#x2F;await"></a>四、async&#x2F;await</h2><hr>
<ul>
<li><p><code>await</code>后面必须是一个<code>Promise</code>对象</p>
</li>
<li><p><code>getDataAsync</code> 方法不变，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> function getDataAsync (url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            var res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: Math.random()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>业务代码如下</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function getData () &#123;</span><br><span class="line">    var res1 = await getDataAsync(&#x27;/page/1?param=123&#x27;)</span><br><span class="line">    console.log(res1)</span><br><span class="line">    var res2 = await getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)</span><br><span class="line">    console.log(res2)</span><br><span class="line">    var res3 = await getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)</span><br><span class="line">    console.log(res3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到使用<code>async\await</code>就像写同步代码一样</li>
<li>对比 <code>Promise</code> 感觉怎么样？是不是非常清晰，但是 <code>async/await</code> 是基于 <code>Promise</code> 的，因为使用 <code>async</code>修饰的方法最终返回一个 <code>Promise</code>， 实际上，<code>async/await</code> 可以看做是使用 <code>Generator</code> 函数处理异步的语法糖，我们来看看如何使用 <code>Generator</code> 函数处理异步</li>
</ul>
<h2 id="五、Generator"><a href="#五、Generator" class="headerlink" title="五、Generator"></a>五、Generator</h2><hr>
<ul>
<li>首先异步函数依然是</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getDataAsync (url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            var res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: Math.random()</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>Generator</code> 函数可以这样写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function * getData () &#123;</span><br><span class="line">    var res1 = yield getDataAsync(&#x27;/page/1?param=123&#x27;)</span><br><span class="line">    console.log(res1)</span><br><span class="line">    var res2 = yield getDataAsync(`/page/2?param=$&#123;res1.data&#125;`)</span><br><span class="line">    console.log(res2)</span><br><span class="line">    var res3 = yield getDataAsync(`/page/2?param=$&#123;res2.data&#125;`)</span><br><span class="line">    console.log(res3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后我们这样逐步执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var g = getData()</span><br><span class="line">g.next().value.then(res1 =&gt; &#123;</span><br><span class="line">    g.next(res1).value.then(res2 =&gt; &#123;</span><br><span class="line">        g.next(res2).value.then(() =&gt; &#123;</span><br><span class="line">            g.next()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码，我们逐步调用遍历器的 <code>next()</code> 方法，由于每一个 <code>next()</code> 方法返回值的 <code>value</code> 属性为一个 <code>Promise</code>对象</li>
<li>所以我们为其添加 <code>then</code> 方法， 在 <code>then</code> 方法里面接着运行 <code>next</code> 方法挪移遍历器指针，直到 <code>Generator</code>函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function run (gen) &#123;</span><br><span class="line">    var g = gen()</span><br><span class="line"></span><br><span class="line">    function next (data) &#123;</span><br><span class="line">        var res = g.next(data)</span><br><span class="line">        if (res.done) return res.value</span><br><span class="line">        res.value.then((data) =&gt; &#123;</span><br><span class="line">            next(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>run 方法用来自动运行异步的 Generator 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 Generator 函数了。 有了 run 方法，我们只需要这样运行 getData 方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(getData)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样，我们就可以把异步操作封装到 <code>Generator</code> 函数内部，使用 <code>run</code> 方法作为 <code>Generator</code> 函数的自执行器，来处理异步。其实我们不难发现， <code>async/await</code> 方法相比于 <code>Generator</code> 处理异步的方式，有很多相似的地方，只不过 <code>async/await</code> 在语义化方面更加明显，同时 <code>async/await</code> 不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 <code>async/await</code> 是 <code>Generator</code> 函数处理异步的语法糖了</p>
</blockquote>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/06/html+css+js+ts/3-js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-前端性能优化-02">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/02%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8BRAIL%E6%B5%8B%E9%87%8F/">前端性能优化-02</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-03-02
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/%E4%BC%98%E5%8C%96/" class="cube-excerpt-tag-link">#优化</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="什么是RAIL："><a href="#什么是RAIL：" class="headerlink" title="什么是RAIL："></a>什么是RAIL：</h2><p>缩写每一个字母表示一个性能指标</p>
<p>Response：响应  对用户而言用户点击有没有即使访问</p>
<p>Animation：动画 给用户的体验好。会不会出现卡顿</p>
<p>Idie：空闲 有足够的空闲时间才能够进行响应交互   不让他始终处于繁忙的时间，不然无法处理其他请求</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427100359004.png" alt="image-20220427100359004"></p>
<p>Load：加载 资源网络加载的时间</p>
<p><strong>RAIL目标</strong></p>
<p><strong>评估指标</strong></p>
<p>响应：处理时间应在50ms以内完成</p>
<p>动画：没10ms产生一帧</p>
<p>空闲：尽可能增加空闲时间</p>
<p>加载：在5s内完成内容加载并可以交互</p>
<p>逐步发现问题解决问题</p>
<p>性能测量工具</p>
<p>Chrome DevTools 开发者调试工具，性能评测</p>
<p>Lighthouse 网站整体质量评估</p>
<p>WebPageTest 多测量地点、全面行能报告（通过 它的问斩对自己的网站就行进行评估）</p>
<h2 id="WenPageTest"><a href="#WenPageTest" class="headerlink" title="WenPageTest"></a><strong>WenPageTest</strong></h2><p>webpagetest.org</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427101136898.png" alt="image-20220427101136898"></p>
<p>用户首次方位  第二次访问  （第一次对一些静态资源做缓存）</p>
<p>录视频</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427101340209.png" alt="image-20220427101340209"></p>
<p>测试结果：</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427101426225.png" alt="image-20220427101426225"></p>
<p>第一次加载，首屏渲染，</p>
<p>speed 速度指数等</p>
<p>图片并行加载  时间有加载最长时间决定</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103510108.png" alt="image-20220427103510108"></p>
<p>高亮（重定向了）  可以优化  直接去访问重定向后的位置</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103527654.png" alt="image-20220427103527654"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103716493.png" alt="image-20220427103716493"></p>
<p>前提：docker</p>
<p>docker pull webpagetest&#x2F;server</p>
<p>docker pull webpagetest&#x2F;a</p>
<p>docker run -d -p 4000:80 webpagetest&#x2F;server</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103841249.png" alt="image-20220427103841249"></p>
<p>自定义镜像</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103951183.png" alt="image-20220427103951183"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103923723.png" alt="image-20220427103923723"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427103940202.png" alt="image-20220427103940202"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104025309.png" alt="image-20220427104025309"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104016148.png" alt="image-20220427104016148"></p>
<p>打包</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104104578.png" alt="image-20220427104104578"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104110269.png" alt="image-20220427104110269"></p>
<p>这样就可以本地测试了。</p>
<h2 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a>Lighthouse</h2><p>npm install -g lighthouse</p>
<p>lighthouse 测试网站地址</p>
<p>自动打开一个浏览器窗口</p>
<p>生成而是报告到本地</p>
<p>打开即可查看</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104412546.png" alt="image-20220427104412546"></p>
<p>第一个有意义的内容</p>
<p>什么时候用户可以交互了</p>
<p>用户访问过程截屏。</p>
<p>Opportunity：告诉我们还可以做些什么做到了可以提升那些多长时间</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427104938078.png" alt="image-20220427104938078"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427105002256.png" alt="image-20220427105002256"></p>
<p>可以指定什么样的资源不进行加载。</p>
<h2 id="Chrome-devtool调试"><a href="#Chrome-devtool调试" class="headerlink" title="Chrome devtool调试"></a>Chrome devtool调试</h2><p>Network：</p>
<p>资源名称  大小   耗时</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427133838888.png" alt="image-20220427133838888"></p>
<p>对请求资源进行压缩在返回前端</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427134024090.png" alt="image-20220427134024090"></p>
<p>实际大小 parse  1.4MB   网络传输（index）55kb</p>
<p>Performance：</p>
<p>开始出现性能分析：可以定位出导致长任务（耗费时间长）的方法。</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427134236511.png" alt="image-20220427134236511"></p>
<p>主线程任务。</p>
<p>Disabel cache缓存。 Online：选择网络</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427134610044.png" alt="image-20220427134610044"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427134719082.png" alt="image-20220427134719082"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427134737203.png" alt="image-20220427134737203"></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/02%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8BRAIL%E6%B5%8B%E9%87%8F/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-前端性能优化-01">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/02/26/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/01%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0/">前端性能优化-01</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-02-26
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/%E4%BC%98%E5%8C%96/" class="cube-excerpt-tag-link">#优化</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p><strong>平凡程序员和大牛程序员、架构师的分水岭</strong></p>
<p><strong>怎样做出高性能的工程，达到大厂产品水平</strong></p>
<p><strong>只是储配，动手实战</strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427093826921.png" alt="image-20220427093826921"></p>
<p><strong>优化标准“</strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427093854500.png" alt="image-20220427093854500"></p>
<p><strong>学习体系</strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427093906855.png" alt="image-20220427093906855"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094119486.png" alt="image-20220427094119486"></p>
<p>一、为什么要进行性能优化</p>
<p>性能-web网站和应用的支柱</p>
<p>网站性能对用户很重要</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094359679.png" alt="image-20220427094359679"></p>
<p><strong>寻找性能瓶颈</strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094506838.png" alt="image-20220427094506838"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094612815.png" alt="image-20220427094612815"></p>
<p><strong>性能指标和性能优化</strong></p>
<p>性能指标：</p>
<p>Network  (页面清空缓存 ，重新加载，查看)</p>
<p>请求数量  资源量   Dom加载时间   混合资源加载时间</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094837633.png" alt="image-20220427094837633"></p>
<p>瀑布图：</p>
<p>请求前资源排队，dns解析，连接，SSL协商</p>
<p>发送：TTFB（用户体验和他有大多数关系）   下载（资源大小）  资源进行并行加载（不阻塞）</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427094932008.png" alt="image-20220427094932008"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095003259.png" alt="image-20220427095003259"></p>
<p>右键下载查看  进行性能分析</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095231244.png" alt="image-20220427095231244"></p>
<p>性能测量工具：</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095256620.png" alt="image-20220427095256620"></p>
<p>first C …：页面出现数据的时间</p>
<p>Speed Index：速度指数（标准为4s）</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095310577.png"></p>
<p>交互性：</p>
<p>画面流畅（帧数问题）</p>
<p>查看查看帧数变化工具：最后一项</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095707388.png" alt="image-20220427095707388"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095839003.png" alt="image-20220427095839003"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095911447.png" alt="image-20220427095911447"></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220427095937536.png" alt="image-20220427095937536"></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/02/26/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/01%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-vue-组件和插件的区别">
    <header class="cube-excerpt-header">
        <h1><a href="/2021/01/15/Vue/vue-%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/">vue-组件和插件的区别</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-01-15
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/vue/" class="cube-excerpt-tag-link">#vue</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、组件是什么"><a href="#一、组件是什么" class="headerlink" title="一、组件是什么"></a>一、组件是什么</h2><p>回顾以前对组件的定义：</p>
<p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件</p>
<p>组件的优势</p>
<ul>
<li>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li>
<li>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li>
<li>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li>
</ul>
<h2 id="二、插件是什么"><a href="#二、插件是什么" class="headerlink" title="二、插件是什么"></a>二、插件是什么</h2><p>插件通常用来为 <code>Vue</code> 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p>
<ul>
<li>添加全局方法或者属性。如: <code>vue-custom-element</code></li>
<li>添加全局资源：指令&#x2F;过滤器&#x2F;过渡等。如 <code>vue-touch</code></li>
<li>通过全局混入来添加一些组件选项。如<code>vue-router</code></li>
<li>添加 <code>Vue</code> 实例方法，通过把它们添加到 <code>Vue.prototype</code> 上实现。</li>
<li>一个库，提供自己的 <code>API</code>，同时提供上面提到的一个或多个功能。如<code>vue-router</code></li>
</ul>
<h2 id="三、两者的区别"><a href="#三、两者的区别" class="headerlink" title="三、两者的区别"></a>三、两者的区别</h2><p>两者的区别主要表现在以下几个方面：</p>
<ul>
<li>编写形式</li>
<li>注册形式</li>
<li>使用场景</li>
</ul>
<h3 id="编写形式"><a href="#编写形式" class="headerlink" title="编写形式"></a>编写形式</h3><h4 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h4><p>编写一个组件，可以有很多方式，我们最常见的就是<code>vue</code>单文件的这种格式，每一个<code>.vue</code>文件我们都可以看成是一个组件</p>
<p><code>vue</code>文件标准格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>我们还可以通过<code>template</code>属性来编写一个组件，如果组件内容多，我们可以在外部定义<code>template</code>组件内容，如果组件内容并不多，我们可直接写在<code>template</code>属性上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=<span class="string">&quot;testComponent&quot;</span>&gt;     <span class="comment">// 组件显示的内容</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>component!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>   </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;componentA&#x27;</span>,&#123; </span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;#testComponent&#x27;</span>  </span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;component&lt;/div&gt;`</span>  <span class="comment">// 组件内容少可以通过这种形式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h4><p><code>vue</code>插件的实现应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">myGlobalMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params">methodOptions</span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册形式"><a href="#注册形式" class="headerlink" title="注册形式"></a>注册形式</h3><h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><p><code>vue</code>组件注册主要分为全局注册与局部注册</p>
<p>全局注册通过<code>Vue.component</code>方法，第一个参数为组件的名称，第二个参数为传入的配置项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>局部注册只需在用到的地方通过<code>components</code>属性注册一个组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component1 = &#123;...&#125; <span class="comment">// 定义一个组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="attr">components</span>:&#123;</span><br><span class="line">		component1   <span class="comment">// 局部注册</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插件注册"><a href="#插件注册" class="headerlink" title="插件注册"></a>插件注册</h4><p>插件的注册通过<code>Vue.use()</code>的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(插件名字,&#123; <span class="comment">/* ... */</span>&#125; )</span><br></pre></td></tr></table></figure>

<p>注意的是：</p>
<p>注册插件的时候，需要在调用 <code>new Vue()</code> 启动应用之前完成</p>
<p><code>Vue.use</code>会自动阻止多次注册相同插件，只会注册一次</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>具体的其实在插件是什么章节已经表述了，这里在总结一下</p>
<p>组件 <code>(Component)</code> 是用来构成你的 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code></p>
<p>插件 <code>(Plugin)</code> 是用来增强你的技术栈的功能模块，它的目标是 <code>Vue</code> 本身</p>
<p>简单来说，插件就是指对<code>Vue</code>的功能的增强或补充</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2021/01/15/Vue/vue-%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack与其他打包工具的区别">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/12/12/webpack/webpack%E4%B8%8E%E5%85%B6%E4%BB%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8C%BA%E5%88%AB/">webpack与其他打包工具的区别</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-12-12
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="一、模块化工具"><a href="#一、模块化工具" class="headerlink" title="一、模块化工具"></a>一、模块化工具</h2><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式</p>
<p>可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(<code>bundle</code>)</p>
<p>在前端领域中，并非只有<code>webpack</code>这一款优秀的模块打包工具，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code></p>
<p>通过这些模块打包工具，能够提高我们的开发效率，减少开发成本</p>
<p>这里没有提及<code>gulp</code>、<code>grunt</code>是因为它们只是定义为构建工具，不能类比</p>
<h3 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h3><p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup</code>要小巧的多</p>
<p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/messages.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">hi</span>: <span class="string">&#x27;Hey Guys, I am zce~&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/logger.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">log</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- INFO ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------------------------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">error</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;---------- ERROR ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;---------------------------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;./logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> messages <span class="keyword">from</span> <span class="string">&#x27;./messages&#x27;</span></span><br><span class="line"><span class="title function_">log</span>(messages.<span class="property">hi</span>)</span><br></pre></td></tr></table></figure>

<p>然后通过<code>rollup</code>进行打包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx rollup ./src/index.<span class="property">js</span> --file ./dist/bundle.<span class="property">js</span></span><br></pre></td></tr></table></figure>

<p>打包结果如下图<img src="https://static.vue-js.com/8fe07830-b143-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>可以看到，代码非常简洁，完成不像<code>webpack</code>那样存在大量引导代码和模块函数</p>
<p>并且<code>error</code>方法由于没有被使用，输出的结果中并无<code>error</code>方法，可以看到，<code>rollup</code>默认开始<code>Tree-shaking</code> 优化输出结果</p>
<p>因此，可以看到<code>Rollup</code>的优点：</p>
<ul>
<li>代码效率更简洁、效率更高</li>
<li>默认支持 Tree-shaking</li>
</ul>
<p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup</code>需要使用插件去完成</p>
<p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p>
<p>但是在用于打包<code>JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略</p>
<h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p>
<p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以任意类型文件作为打包入口，但建议使用<code>HTML</code>文件作为入口，该<code>HTML</code>文件像平时一样正常编写代码、引用资源。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ./src/index.<span class="property">html</span> --&gt;</span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Parcel Tutorials<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>main.js文件通过<code>ES Moudle</code>方法导入其他模块成员</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;./logger&#x27;</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;hello parcel&#x27;</span>)</span><br><span class="line"><span class="comment">// ./src/logger.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">log</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- INFO ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后，使用命令打包</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx parcel src/index.html</span><br></pre></td></tr></table></figure>

<p>执行命令后，<code>Parcel</code>不仅打包了应用，同时也启动了一个开发服务器，跟<code>webpack Dev Server</code>一样</p>
<p>跟<code>webpack</code>类似，也支持模块热替换，但用法更简单</p>
<p>同时，<code>Parcel</code>有个十分好用的功能：支持自动安装依赖，像<code>webpack</code>开发阶段突然使用安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程</p>
<p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code></p>
<p>打包命令如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx parcel src/index.html</span><br></pre></td></tr></table></figure>

<p>由于打包过程是多进程同时工作，构建速度会比<code>Webpack</code> 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中</p>
<p><img src="https://static.vue-js.com/ec17e7a0-b1a2-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>可以感受到，<code>Parcel</code>给开发者一种很大的自由度，只管去实现业务代码，其他事情用<code>Parcel</code>解决</p>
<h3 id="Snowpack"><a href="#Snowpack" class="headerlink" title="Snowpack"></a>Snowpack</h3><p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验</p>
<p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件</p>
<p>下图给出<code>webpack</code>与<code>snowpack</code>打包区别：</p>
<p><img src="https://static.vue-js.com/79197830-b1a3-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新</p>
<h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p>
<p>它主要由两部分组成：</p>
<ul>
<li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR</li>
<li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li>
</ul>
<p>其作用类似<code>webpack</code>+ <code>webpack-dev-server</code>，其特点如下：</p>
<ul>
<li>快速的冷启动</li>
<li>即时的模块热更新</li>
<li>真正的按需编译</li>
</ul>
<p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p>
<p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p>
<p>原理图如下所示：</p>
<p><img src="https://static.vue-js.com/9f2eed30-b143-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>相比上述的模块化工具，<code>webpack</code>大而全，很多常用的功能做到开箱即用。有两大最核心的特点：<strong>一切皆模块</strong>和<strong>按需加载</strong></p>
<p>与其他构建工具相比，有如下优势：</p>
<ul>
<li>智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容</li>
<li>万物模块：对 js、css、图片等资源文件都支持打包</li>
<li>开箱即用：HRM、Tree-shaking等功能</li>
<li>代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li>
<li>插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性</li>
<li>易于调试：支持 SourceUrls 和 SourceMaps</li>
<li>快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li>
<li>生态环境好：社区更丰富，出现的问题更容易解决</li>
</ul>
<ol>
<li>除了Webpack外，你还了解哪些模块管理工具<br> webpack:<br> 就目前而言，webpack已是最常用的打包工具，webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。<br> gulp：<br> gulp是一个前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task，第一task处理的事情（如代码压缩，合并，编译以及浏览器实时更新等）。然后定义这些执行顺序，来让glup执行这些task，从而构建项目的整个开发流程。自动化构建工具并不能把所有的模块打包到一起，也不能构建不同模块之间的依赖关系。</li>
</ol>
<p>  grunt：<br>  是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。<br>  Rollup</p>
<ol start="2">
<li>Rollup 是一款 ES Modules 打包器， 从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要小巧的多<br> 现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等<br> Parcel<br> Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序<br> Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用		HTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。<br> 模块化是一种处理复杂系统分解为更好的可管理模块的方式。可以用来分割、组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体。<br> 在前端领域中，除了Webpack外，比较流行的模块打包工具还包括Rollup、Parcel、snowpack和最近风靡的Vite。</li>
</ol>
<p>  2.1. Rollup<br>  Rollup 是一款 ES Modules 打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多。现在很多苦都使用它进行打包，比如：Vue、React和three.js等。<br>  使用之前，可以使用npm install –global rollup 命令进行安装。Rollup 可以通过命令行接口(command line interface)配合可选配置文件(optional configuration file)来调用，或者可以通过 JavaScript API来调用。运行 rollup –help 可以查看可用的选项和参数。<br>  2.2. Parcel<br>  Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序。<br>  2.3.  Vite<br>  Vite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。<br>  Vite具有以下特点： - 快速的冷启动 - 即时热模块更新（HMR，Hot Module Replacement） - 真正按需编译<br>  Vite由两部分组成： - 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR。 - 一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。<br>  Vite在开发阶段可以直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块的时候，根据需要对模块的内容进行编译，大大缩短了编译时间。工作原理如下图所示。<br>  在热模块HMR方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像Webpack那样需要把该模块的相关依赖模块全部编译一次，因此效率也更高。<br>3. webpack，rollup，parcel优劣？(了解)<br>    对比</p>
<p>  Webpack<br>  Rollup<br>  Parcel<br>  功能</p>
<p>为处理资源管理和分割代码而生，可以用来处理任何类型的文件，灵活，插件多。<br>    用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。<br>    用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。<br>配置<br>    webpack需要配config文件，指明entry, output, plugin，transformations。<br>    rollup需要配config文件，指明entry, output, plugin，transformations。rollup 有对import&#x2F;export所做的node polyfills，webpack没有。rollup支持相对路径，而webpack没有，所以得使用</p>
<pre><code>parcel则是完全开箱可用的，不用配置。
</code></pre>
<p>入口文件<br>    webpack只支持js文件作为入口文件，如果要以其他格式的文件作为入口，比如html文件为入口，如要加第三方Plugin。<br>    rollup可以用html作为入口文件，但也需要plugin，比如rollup-plugin-html-entry。<br>    parcel可以用index.html作为入口文件，而且它会通过看index.html的script tag里包含的什么自己找到要打包生成哪些js文件。<br>transformations<br>    transformations指的是把其他文件转化成js文件的过程，需要经过transformation才能够被打包。webpack使用Loaders来处理。<br>    rollup使用plugins来处理。<br>    parcel会自动去转换，当找到配置文件比如.babelrc, .postcssrc后就会自动转。<br>摇树优化<br>    摇树优化是webpack的一大特性。需要1，用import&#x2F;export语法，2，在package.json中加副作用的入口，3，加上支持去除死代码的缩小器（uglifyjsplugin）。<br>    rollup会统计引入的代码并排除掉那些没有被用到的。这使您可以在现有工具和模块的基础上构建，而无需添加额外的依赖项或膨胀项目的大小。<br>    parcel不支持摇树优化。<br>dev server<br>    webpack用webpack-dev-server。<br>rollup用rollup-plugin-serve和rollup-plugin-livereload共同作用。<br>    parcel内置的有dev server<br>热更新<br>    webpack的 wepack-dev-server支持hot模式。<br>    rollup不支持hmr。<br>    parcel有内置的hmr。<br>代码分割<br>    webpack通过在entry中手动设置，使用CommonsChunkPlugin，和模块内的内联函数动态引入来做代码分割。<br>    rollup有实验性的代码分割特性。它是用es模块在浏览器中的模块加载机制本身来分割代码的。需要把experimentalCodeSplitting 和 experimentalDynamicImport 设为true。<br>    parcel支持0配置的代码分割。主要是通过动态improt。</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/12/12/webpack/webpack%E4%B8%8E%E5%85%B6%E4%BB%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8C%BA%E5%88%AB/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack模块联邦">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/12/07/webpack/webpack%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/">webpack模块联邦</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-12-07
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。<br>这通常被称作微前端，但并不仅限于此。<br>Webpack5 模块联邦可以让 Webpack 达到了线上 Runtime 的效果，让代码直接在项目间利用 CDN 直接共享，不再需要本地安装 Npm 包、构建再发布了！<br>我们知道 Webpack 可以通过 DLL 或者 Externals 做代码共享时 Common Chunk，但不同应用和项目间这个任务就变得困难了，我们几乎无法在项目之间做到按需热插拔。</p>
<p>早期NPM方式共享模块   代码的共享是将依赖作为library安装到我们的项目里进行webpack打包并且构建上线<br>对于项目 Home 与 Search，需要共享一个模块时，最常见的办法就是将其抽成通用依赖并分别安装在各自项目中。虽然 Monorepo 可以一定程度解决重复安装和修改困难的问题，但依然需要走本地编译。</p>
<p>真正 Runtime 的方式可能是 UMD 方式共享代码模块，即将模块用 Webpack UMD模式打包，并输出到其他项目中。这是非常普遍的模块共享方式：<br>对于项目 Home 与 Search，直接利用 UMD 包复用一个模块。但这种技术方案问题也很明显，就是包体积无法达到本地编译时的优化效果，且库之间容易冲突。</p>
<p>微前端：micro-frontends (MFE) 也是最近比较火的模块共享管理方式，微前端就是要解决多项目并存问题，多项目并存的最大问题就是模块共享，模块之间是不能有冲突。  对于微前端我们还要考虑样式冲突，声明周期管理冲突等问题，我们先不考虑这些   想把问题聚焦在资源加载的方式上   微前端一般有两种打包方式：1.子应用独立打包，模块实现解耦，但这种方式无法抽取公共的依赖，2.整体应用打一个打包 很好的解决我们上面第一种方式的问题，但是打包效率速度实在是太慢了。不具备水平的扩展能力。<br>由于微前端还要考虑样式冲突、生命周期管理，所以本文只聚焦在资源加载方式上。微前端一般有两种打包方式：</p>
<ol>
<li>子应用独立打包，模块更解耦，但无法抽取公共依赖等。</li>
<li>整体应用一起打包，很好解决上面的问题，但打包速度实在是太慢了，不具备水平扩展能力。</li>
</ol>
<p>终于提到本文的主角了，模块联邦方式作为 Webpack5 内置核心特性之一的 FederatedModule：<br>这个方案是直接将一个应用的包应用于另一个应用，同时具备整体应用一起打包的公共依赖抽取能力。  比如：我们直接可以在Search应用里直接使用已经发布到线上的Home应用的组件。</p>
<p><strong>应用案例</strong><br>本案例模拟三个应用： Nav 、 Search 及 Home 。每个应用都是独立的，又通过模块邦联系到了一起。<br>比如Home需要使用Nav组件共享出来的header，Search可能要使用Header和Home组件构建出来的HomeList。<br>模块联邦将他们共享的模块暴露出来进行引用。<br>1、Nav 导航<br>src&#x2F;header.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Header = () =&gt; &#123;</span><br><span class="line"> const header = document.createElement(&#x27;h1&#x27;)</span><br><span class="line"> header.textContent = &#x27;公共头部内容&#x27;</span><br><span class="line"> return header</span><br><span class="line">&#125;</span><br><span class="line">export default Header</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Header from &#x27;./Header&#x27;</span><br><span class="line">const div = document.createElement(&#x27;div&#x27;)</span><br><span class="line">div.appendChild(Header())</span><br><span class="line">document.body.appendChild(div)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   // 模块联邦名字</span><br><span class="line">   name: &#x27;nav&#x27;,</span><br><span class="line">   // 外部访问的资源名字</span><br><span class="line">   filename: &#x27;remoteEntry.js&#x27;,</span><br><span class="line">   // 引用的外部资源列表</span><br><span class="line">   remotes: &#123;&#125;,</span><br><span class="line">   // 暴露给外部资源列表</span><br><span class="line">   exposes: &#123;</span><br><span class="line">    &#x27;./Header&#x27;: &#x27;./src/Header.js&#x27;,   // 暴露 Header组件  key：可以定义成./Header 这个./Header并不代表是我当前引用下的某个路径   而是将来在别人用的时候基于这个路径来拼接url，值是正真的我们本地项目的应用</span><br><span class="line">  &#125;,</span><br><span class="line">   // 共享模块，如lodash</span><br><span class="line">   shared: &#123;&#125;,   // 如果我们的 header模块里有共享的第三方模块比如：lodash等，我们可以把他放到这里在打包的时候可以把第三方的共享的模块打到单独的一个包里。</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3003</span><br></pre></td></tr></table></figure>

<p>2、Home 首页<br>src&#x2F;HomeList</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const HomeList = (num) =&gt; &#123;</span><br><span class="line"> let str = &#x27;&lt;ul&gt;&#x27;</span><br><span class="line"> for (let i = 0; i &lt; num; i++) &#123;</span><br><span class="line">  str += &#x27;&lt;li&gt;item &#x27; + i + &#x27;&lt;/li&gt;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"> str += &#x27;&lt;/ul&gt;&#x27;</span><br><span class="line"> return str</span><br><span class="line">&#125;</span><br><span class="line">export default HomeList</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import HomeList from &#x27;./HomeList&#x27;</span><br><span class="line">remotes: &#123;</span><br><span class="line">    nav</span><br><span class="line">	(&#x27;nav/Header&#x27;)：remotes: &#123; nav &#125;Header    exposes: &#123;./Header&#x27;:&#x27;&#x27;&#125;</span><br><span class="line">import(&#x27;nav/Header&#x27;).then((Header) =&gt; &#123;  //引用模块联邦的组件  这样导入别人组件的时候需要通过异步的方式因为 网络共享或者是模块载入 是由延迟的，所以要通过promise的方式（异步模块加载的形式）去引用它。</span><br><span class="line"> const body = document.createElement(&#x27;div&#x27;)</span><br><span class="line"> body.appendChild(Header.default())</span><br><span class="line"> document.body.appendChild(body)</span><br><span class="line"> document.body.innerHTML += HomeList(5)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   name: &quot;home&quot;,</span><br><span class="line">   filename: &quot;remoteEntry.js&quot;,</span><br><span class="line">   remotes: &#123;</span><br><span class="line">    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,    // 引用第三方或别人写好的应用的路径。远端的服务路径</span><br><span class="line">  &#125;,</span><br><span class="line">   exposes: &#123;</span><br><span class="line">    &#x27;./HomeList&#x27;: &#x27;./src/HomeList.js&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   shared: &#123;&#125;,</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3001</span><br></pre></td></tr></table></figure>

<p>3、search 搜索<br>src&#x2F;index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([import(&#x27;nav/Header&#x27;), import(&#x27;home/HomeList&#x27;)])</span><br><span class="line">.then(([&#123;</span><br><span class="line">  default: Header</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  default: HomeList</span><br><span class="line">&#125;]) =&gt; &#123;</span><br><span class="line">  document.body.appendChild(Header())</span><br><span class="line">  document.body.innerHTML += HomeList(4)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   name: &#x27;search&#x27;,</span><br><span class="line">   filename: &#x27;remoteEntry.js&#x27;,</span><br><span class="line">   remotes: &#123;</span><br><span class="line">    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,</span><br><span class="line">    home: &quot;home@http://localhost:3001/remoteEntry.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">   exposes: &#123;&#125;,</span><br><span class="line">   shared: &#123;&#125;,</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3002</span><br></pre></td></tr></table></figure>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/12/07/webpack/webpack%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-webpack面试题总结">
    <header class="cube-excerpt-header">
        <h1><a href="/2020/12/03/webpack/webpack%E9%9D%A2%E8%AF%95%E9%A2%98/">webpack面试题总结</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2020-12-03
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/webpack/" class="cube-excerpt-tag-link">#webpack</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>webpack 面试题</p>
<h1 id="一、-概念"><a href="#一、-概念" class="headerlink" title="一、 概念"></a>一、 概念</h1><h2 id="1-什么是webpack，谈谈你对它的理解？"><a href="#1-什么是webpack，谈谈你对它的理解？" class="headerlink" title="1. 什么是webpack，谈谈你对它的理解？"></a>1. 什么是webpack，谈谈你对它的理解？</h2><p>是一个模块化打包工具，将不同的资源和文件，进行打包，合并在一个文件里。<br>概念+打包流程+前端模块化<br>1、依赖管理：方便引用第三方模块，让模块更容易复用、避免全局注入导致的冲突、、避免重复加载或者加载不必要的模块<br>2、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数，配合uglify.js可以减少、优化代码的体积<br>3、各种插件：babel把ES6+转化为ES5-，eslint可以检查编译时的各种错误</p>
<p>(30条消息) 前端模块化理解<em>perwhy_wang的博客-CSDN博客</em>前端模块化的理解</p>
<h2 id="2-webpack的工作原理"><a href="#2-webpack的工作原理" class="headerlink" title="2. webpack的工作原理?"></a>2. webpack的工作原理?</h2><h3 id="工作原理概括"><a href="#工作原理概括" class="headerlink" title="工作原理概括"></a>工作原理概括</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在了解webpack原理前，需要掌握以下几个核心概念，以方便后面的理解：</p>
<ol>
<li><p>Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图</p>
</li>
<li><p>output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名</p>
</li>
<li><p>Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript)</p>
</li>
<li><p>plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等</p>
</li>
<li><p>mode:模式指示webpack使用相应模式的配置</p>
<h3 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h3><p>webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
</li>
<li><p>初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数；</p>
</li>
<li><p>开始编译： 用上一步得到的参数初始化Complier对象，加载所有配置的插件，执行对象的run方法开始执行编译；</p>
</li>
<li><p>确定入口： 根据配置中的entry找出所有入口文件；</p>
</li>
<li><p>编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理；</p>
</li>
<li><p>完成模块编译： 在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系；</p>
</li>
<li><p>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</p>
</li>
<li><p>输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p>
<p>在以上过程中，webpack会在特定的时间点广播出特定的时间，插件在监听到感兴趣的时间后会执行特定的逻辑，并且插件可以调用Webpack提供的API改变Webpack的运行结果。</p>
<h3 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h3><p>Webpack的构建流程可以分为以下三个阶段：</p>
</li>
<li><p>初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier.</p>
</li>
<li><p>编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。</p>
</li>
<li><p>输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。<br>如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下：</p>
</li>
</ol>
<h2 id="3-webpack4和webpack5的区别？"><a href="#3-webpack4和webpack5的区别？" class="headerlink" title="3. webpack4和webpack5的区别？"></a>3. webpack4和webpack5的区别？</h2><p>更快的构建速度<br>更高的版本要求<br>更灵活的模块组合<br>更智能的缓存优化<br>更小的体积<br>webpack4 上需要下载安装 terser-webpack-plugin 插件<br>webpack5 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode&#x3D;“production” 的时候会自动开启 js 压缩功能。<br>webpack4 缓存配置<br>● npm install hard-source-webpack-plugin -D<br>webpack5 缓存配置<br>● webpack5 内部内置了 cache 缓存机制。直接配置即可。<br>● cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。<br>webpack4 启动服务<br>● 通过 webpack-dev-server 启动服务<br>webpack5 启动服务<br>● 内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。<br>devtool的区别<br>● sourceMap需要在 webpack.config.js里面直接配置 devtool 就可以实现了。而 devtool有很多个选项值，不同的选项值，不同的选项产生的 .map 文件不同，打包速度不同。<br>● 一般情况下，我们一般在开发环境配置用“cheap-eval-module-source-map”，在生产环境用‘none’。<br>v4: devtool: ‘cheap-eval-module-source-map’<br>v5: devtool: ‘eval-cheap-module-source-map’<br>打包：<br>● webpack4打包:即使后续没有使用到num1的函数，依然会将代码打包进去<br>● webpack5打包:后续没有使用到num1的函数，不会将代码打包进去<br>输出代码：<br>● webpack4只能输出es5的代码<br>● webpack5新增属性output.ecmaVersion，可以生成ES5和ES6的代码</p>
<h2 id="4-前端代码为何要进行构建和打包？"><a href="#4-前端代码为何要进行构建和打包？" class="headerlink" title="4. 前端代码为何要进行构建和打包？"></a>4. 前端代码为何要进行构建和打包？</h2><ol>
<li><p>代码方面体积更小，加载更快（tree-shaking，压缩合并）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i. 编译高级语言和语法（ts，es6，模块化） ii. 兼容性和错误提示（polyfill，postcss，eslint）</span><br></pre></td></tr></table></figure>
</li>
<li><p>研发流程统一、高效的开发环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i. 统一的构建流程和产出标准 ii. 集成公司构建规范（提测，上线）</span><br></pre></td></tr></table></figure></li>
</ol>
<p>打包之后许多零碎的文件打包成一个整体，页面只需请求一次，js文件中使用模块化互相引用，这样能在一定程度上提供页面渲染效率，打包的同时会进行编译，将es6，sass等高级语法进行转换编译，以兼容高版本的浏览器</p>
<h2 id="5-webpack的优缺点？"><a href="#5-webpack的优缺点？" class="headerlink" title="5. webpack的优缺点？"></a>5. webpack的优缺点？</h2><p>优点：<br>（1） webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。<br>（2）能被模块化的不仅仅是 JS 了。<br>（3） 开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。<br>（4）扩展性强，插件机制完善<br>缺点：<br>● 配置复杂<br>● 不分包bundle.js体积庞大<br>● 只能用于采用模块化开发的项目<br>● 打包慢<br>● ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译</p>
<h2 id="6-什么是bundle，什么是chunk，什么是module"><a href="#6-什么是bundle，什么是chunk，什么是module" class="headerlink" title="6. 什么是bundle，什么是chunk，什么是module"></a>6. 什么是bundle，什么是chunk，什么是module</h2><p>bundle： 是由webpack打包出来的文件<br>chunk： 是指webpack在进行模块依赖分析的时候，代码分割出来的代码块<br>module： 是开发中的单个模块</p>
<h1 id="二、-loader"><a href="#二、-loader" class="headerlink" title="二、 loader"></a>二、 loader</h1><h2 id="1-Loader机制的作用是什么？"><a href="#1-Loader机制的作用是什么？" class="headerlink" title="1. Loader机制的作用是什么？"></a>1. Loader机制的作用是什么？</h2><p>webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。<br>webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换打包成js。<br>注意：use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize中的minimize告诉css-loader要开启 CSS 压缩。</p>
<h2 id="2-有哪些常见的Loader？他们是解决什么问题的？"><a href="#2-有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="2. 有哪些常见的Loader？他们是解决什么问题的？"></a>2. 有哪些常见的Loader？他们是解决什么问题的？</h2><p>● file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件<br>● url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>● source-map-loader：加载额外的 Source Map 文件，以方便断点调试<br>● image-loader：加载并且压缩图片文件<br>● babel-loader：把 ES6 转换成 ES5<br>● css-loader：加载 CSS，支持模块化、压缩、文件导入等特性<br>● style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<br>● eslint-loader：通过 ESLint 检查 JavaScript 代码</p>
<h2 id="3-Webpack-的-Loader-是什么？"><a href="#3-Webpack-的-Loader-是什么？" class="headerlink" title="3. Webpack 的 Loader 是什么？"></a>3. Webpack 的 Loader 是什么？</h2><p>Webpack 只能理解 JavaScript 和 JSON 文件，这是 Webpack 开箱可用的自带能力。loader 可以让 Webpack 能够去处理其他类型的文件，比如 .scss 和 .ts，并将它们转换为有效的功能离散的 chunk 文件以供应用程序使用，以及被添加到依赖图中，也可将内联图像转换为 data URL。简单来说，loader 可以将一段代码转换成另一端代码，通常用来将一段特殊代码转换成一段浏览器可识别的代码。<br>loader从下到上地取值(evaluate)&#x2F;执行(execute)，也就是是从后往前执行。在下面的示例中，从 ts-loader开始执行，然后继续执行 css-loader，最后以 raw-loader 为结束。loader 有两个属性：test，正则表达式，用于识别出哪些文件会被转换，use 定义在进行转换时应该使用哪个 loader，可以是字符串、数组和对象。</p>
<h1 id="三、-plugin"><a href="#三、-plugin" class="headerlink" title="三、 plugin"></a>三、 plugin</h1><h2 id="1-Plugin（插件）的作用是什么？"><a href="#1-Plugin（插件）的作用是什么？" class="headerlink" title="1. Plugin（插件）的作用是什么？"></a>1. Plugin（插件）的作用是什么？</h2><p>通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的webpack 插件有如下两个：<br>① webpack-dev-server<br>类似于 node.js 阶段用到的 nodemon 工具<br>每当修改了源代码，webpack 会自动进行项目的打包和构建<br>② html-webpack-plugin<br>webpack 中的 HTML 插件（类似于一个模板引擎插件）<br>可以通过此插件自定制 index.html 页面的内容<br>webpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。<br>运行如下的命令，即可在项目中安装webpack插件：<br>npm install webpack-dev-<a href="mailto:server@3.11.0">server@3.11.0</a> -D</p>
<p>下面进行webpack-dev-server配置，修改package.json -&gt; scripts中的dev命令：<br>“scripts”:{<br>“dev”：”webpack serve”，&#x2F;&#x2F; script 节点下的脚本,可以通过 npm run 执行<br>}</p>
<p>再次运行npm run dev 命令，重新进行项目的打包，在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 地址，查看自动打包效果，注意webpack-dev-server 会启动一个实时打包的http 服务器。</p>
<h2 id="2-有哪些常见的Plugin？他们是解决什么问题的？"><a href="#2-有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="2. 有哪些常见的Plugin？他们是解决什么问题的？"></a>2. 有哪些常见的Plugin？他们是解决什么问题的？</h2><p>● define-plugin：定义环境变量<br>● commons-chunk-plugin：提取公共代码<br>● uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码<br>● purgecss-webpack-plugin：擦除无用css<br>● happypack：多线程处理打包<br>● webpack-bundle-analyzer：打包分析<br>● speed-measure-webpack-plugin：构建速度分析<br>● html-webpack-plugin：<br>● 为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题</p>
<h2 id="3-是否写过Loader和Plugin？描述一下编写loader或plugin的思路？"><a href="#3-是否写过Loader和Plugin？描述一下编写loader或plugin的思路？" class="headerlink" title="3. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？"></a>3. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</h2><p>Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。<br>编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。<br>相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<h2 id="4-Webpack-的-Plugin-是什么？"><a href="#4-Webpack-的-Plugin-是什么？" class="headerlink" title="4. Webpack 的 Plugin 是什么？"></a>4. Webpack 的 Plugin 是什么？</h2><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。<br>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文 件压缩等等。</p>
<h2 id="5-Loader和Plugin的不同？"><a href="#5-Loader和Plugin的不同？" class="headerlink" title="5. Loader和Plugin的不同？"></a>5. Loader和Plugin的不同？</h2><p>不同的作用<br>● Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。<br>● Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。<br>不同的用法</p>
<ol>
<li><p>Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</p>
</li>
<li><p>Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</p>
<h2 id="6-是否写过Loader和Plugin？描述一下编写loader或plugin的思路？"><a href="#6-是否写过Loader和Plugin？描述一下编写loader或plugin的思路？" class="headerlink" title="6. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？"></a>6. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</h2><p>Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。</p>
<p>编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。</p>
<p>相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
</li>
</ol>
<h1 id="四、-优化"><a href="#四、-优化" class="headerlink" title="四、 优化"></a>四、 优化</h1><h2 id="1、-如何提高webpack的构建速度？"><a href="#1、-如何提高webpack的构建速度？" class="headerlink" title="1、 如何提高webpack的构建速度？"></a>1、 如何提高webpack的构建速度？</h2><ol>
<li>多入口情况下，使用CommonsChunkPlugin来提取公共代码</li>
<li>通过externals配置来提取常用库<br>利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。</li>
<li>使用Happypack 实现多线程加速编译</li>
<li>使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</li>
<li>使用Tree-shaking和Scope Hoisting来剔除多余代码</li>
</ol>
<h2 id="2、-如何利用webpack来优化前端性能？（提高性能和体验）"><a href="#2、-如何利用webpack来优化前端性能？（提高性能和体验）" class="headerlink" title="2、 如何利用webpack来优化前端性能？（提高性能和体验）!"></a>2、 如何利用webpack来优化前端性能？（提高性能和体验）!</h2><p>前端性能优化方案都有哪些？ - 知乎 (zhihu.com)<br>(30条消息) 前端性能优化的方法_万般皆是你的博客-CSDN博客<br>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。<br>● 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css<br>● 利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径<br>● 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现<br>● 提取公共代码。<br>● 异步组件<br>● 异步图片<br>● 配置webpack对小图片打包成base64字符 减少io请求</p>
<h2 id="3、-怎么配置单页应用？怎么配置多页应用？"><a href="#3、-怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="3、 怎么配置单页应用？怎么配置多页应用？"></a>3、 怎么配置单页应用？怎么配置多页应用？</h2><p>单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述<br>多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。</p>
<h2 id="4、-如何提升webpack的运行速度-开发环境-有哪些策略？"><a href="#4、-如何提升webpack的运行速度-开发环境-有哪些策略？" class="headerlink" title="4、 如何提升webpack的运行速度(开发环境) ,有哪些策略？"></a>4、 如何提升webpack的运行速度(开发环境) ,有哪些策略？</h2><p>多入口情况下，使用CommonsChunkPlugin来提取公共代码<br>通过externals配置来提取常用库<br>利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。<br>使用Happypack 实现多线程加速编译<br>使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度<br>使用Tree-shaking和Scope Hoisting来剔除多余代码<br>● JS代码压缩<br>● terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小。在production模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的。如果想要自定义配置它，配置方法如下。<br>● TerserPlugin常用的属性如下： - extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释 - parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1 - terserOptions：设置我们的terser相关的配置： compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true mangle：设置丑化相关的选项，可以直接设置为true toplevel：底层变量是否进行转换keep_classnames：保留类的名称 keep_fnames：保留函数的名称<br>● 代码压缩<br>● cssCSS压缩通常用于去除无用的空格等，不过因为很难去修改选择器、属性的名称、值等，所以我们可以使用另外一个插件：css-minimizer-webpack-plugin<br>● Html文件代码压缩<br>● 文件大小压缩<br>● 对文件的大小进行压缩，可以有效减少http传输过程中宽带的损耗，文件压缩需要用到 compression-webpack-plugin插件<br>● 图片压缩<br>● 如果我们对bundle包进行分析，会发现图片等多媒体文件的大小是远远要比 js、css 文件要大的，所以图片压缩在打包方面也是很重要的</p>
<p>● Tree Shaking<br>● Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析。在webpack实现Trss shaking有两种不同的方案： - usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的 - sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用<br>● usedExports的配置方法很简单，只需要将usedExports设为true即可，如下。而sideEffects则用于告知webpack compiler在编译时哪些模块有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports，如果有些文件需要保留，可以设置为数组的形式。<br>● 代码分离<br>■ 默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度。如果可以分出出更小的bundle，以及控制资源加载优先级，从而优化加载性能。<br>■ 代码分离可以通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可。<br>■ splitChunks有如下几个属性： - Chunks：对同步代码还是异步代码进行处理 - minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分 - maxSize： 将大于maxSize的包，拆分为不小于minSize的包 - minChunks：被引入的次数，默认是1<br>● 内联 chunk<br>■ 可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大但是必须加载的，比如：总结一下，Webpack对前端性能的优化，主要是通过文件体积大小入手，主要的措施有分包、减少Http请求次数等。</p>
<p>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。<br>1、压缩代码:删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS文件， 利用 cssnano （css-loader? minimize）来压缩css<br>2、利用CDN加速: 在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用 webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径<br>3、Tree Shaking: 将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数 — optimize-minimize 来实现<br>4、Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利用浏览 器缓存<br>5、提取公共第三方库: SplitChunksPlugin插件来进行公共模块抽取,利用浏览器缓存可以长期缓存这 些无需频繁变动的公共代码</p>
<h2 id="5、-npm打包时需要注意哪些？如何利用webpack来更好的构建？"><a href="#5、-npm打包时需要注意哪些？如何利用webpack来更好的构建？" class="headerlink" title="5、 npm打包时需要注意哪些？如何利用webpack来更好的构建？"></a>5、 npm打包时需要注意哪些？如何利用webpack来更好的构建？</h2><p>● Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。<br>● NPM模块需要注意以下问题：要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。Npm包大小应该是尽量小（有些仓库会限制包大小）发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。</p>
<h2 id="6、-什么是长缓存？在webpack中如何做到长缓存优化？"><a href="#6、-什么是长缓存？在webpack中如何做到长缓存优化？" class="headerlink" title="6、 什么是长缓存？在webpack中如何做到长缓存优化？"></a>6、 什么是长缓存？在webpack中如何做到长缓存优化？</h2><p>● 浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或者更新，都需要浏览器去下载新的代码，最方便和最简单的更新方式就是引入新的文件名称。<br>● 在webpack中，可以在output给出输出的文件制定chunkhash，并且分离经常更新的代码和框架代码，通过NameModulesPlugin或者HashedModulesPlugin使再次打包文件名不变。</p>
<h2 id="7、-在项目中tree-shaking摇树不是很干净，有什么解决方案？"><a href="#7、-在项目中tree-shaking摇树不是很干净，有什么解决方案？" class="headerlink" title="7、 在项目中tree-shaking摇树不是很干净，有什么解决方案？"></a>7、 在项目中tree-shaking摇树不是很干净，有什么解决方案？</h2><p>在webpack.config.js中通过<br>来进行tree-shaking 但是单单指定这一个配置 不是很干净<br>有些模块导入，只要被引入，<br>就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配<br>置的JavaScript 文件。<br>如何告诉 Webpack 你的代码无副作用，可以通过 package.json 有一个特殊的属性<br>sideEffects，就是为此而存在的。<br>它有三个可能的值：<br>● true：如果不指定其他值的话。这意味着所有的文件都有副作用，也就是没有一个文件<br>可以 tree-shaking。<br>● false： 告诉 Webpack 没有文件有副作用，所有文件都可以 tree-shaking。<br>● 数组[…]：是文件路径数组。它告诉 webpack，除了数组中包含的文件外，你的任何文件<br>都没有副作用。因此，除了指定的文件之外，其他文件都可以安全地进行 tree-shaking。</p>
<h2 id="8、-怎么提高webpack的打包效率？"><a href="#8、-怎么提高webpack的打包效率？" class="headerlink" title="8、 怎么提高webpack的打包效率？"></a>8、 怎么提高webpack的打包效率？</h2><p>(29条消息) 提高webpack的打包速度方法<em>孙德海想进阿里的博客-CSDN博客</em>提升webpack打包速度<br>如何提高webpack的构建速度 - 简书 (jianshu.com)<br>开发环境优化</p>
<ol>
<li><p>开启热模块替换（HMR）</p>
</li>
<li><p>使用 source-map 进行源代码映射</p>
</li>
<li><p>将只需要被loader执行一次的规则放到 oneOf 里面去<br>生产环境优化</p>
</li>
<li><p>对资源进行缓存</p>
</li>
<li><p>使用tree shaking（树摇）</p>
</li>
<li><p>使用code split 进行代码分割</p>
</li>
<li><p>文件懒加载和预加载</p>
</li>
<li><p>多进程打包</p>
</li>
<li><p>使用PWA（离线加载）</p>
</li>
<li><p>使用externals 忽略某些包，然后通过cdn引入</p>
</li>
<li><p>使用dll 技术对某些库（第三方库）进行单独打包</p>
<h2 id="9、-按需加载的原理"><a href="#9、-按需加载的原理" class="headerlink" title="9、 按需加载的原理"></a>9、 按需加载的原理</h2><p>● 使用符合 ECMAScript 提案 的 import() 语法</p>
<p>● 使用 webpack 特定的 require.ensure</p>
<h2 id="10、-预获取-x2F-预加载模块"><a href="#10、-预获取-x2F-预加载模块" class="headerlink" title="10、 预获取&#x2F;预加载模块"></a>10、 预获取&#x2F;预加载模块</h2><p>Webpack v4.6.0+ 增加了对预获取和预加载的支持。</p>
<p>在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 “resource hint(资源提示)”，来告知浏览器</p>
<p>● prefetch(预获取)：将来某些导航下可能需要的资源</p>
<p>● preload(预加载)：当前导航下可能需要资源</p>
<p>添加第二句魔法注释： webpackPrefetch: true</p>
<p>告诉 webpack 执行预获取。这会生成 <link rel="prefetch" href="math.js"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并追加到页面头部，指示着浏览器在闲置时间预取 math.js 文件。</span><br></pre></td></tr></table></figure>

<h2 id="11、-懒加载"><a href="#11、-懒加载" class="headerlink" title="11、 懒加载"></a>11、 懒加载</h2><p>懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把</p>
<p>你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用</p>
<p>或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体</p>
<p>体积，因为某些代码块可能永远不会被加载。</p>
<p>创建一个 math.js 文件，在主页面中通过点击按钮调用其中的函数：</p>
<p>button.addEventListener(‘click’, () &#x3D;&gt; {</p>
<p>import(&#x2F;</p>
<p> webpackChunkName: ‘math’ </p>
<p>&#x2F; ‘.&#x2F;math.js’).then(({ add</p>
<p>}) &#x3D;&gt; {</p>
<p>console.log(add(4, 5))</p>
<p>})</p>
<p>})</p>
</li>
</ol>
<p>这里有句注释，我们把它称为 webpack 魔法注释： webpackChunkName: ‘math’ ,告诉webpack打包生成的文件名为 math 。<br>第一次加载完页面， math.bundle.js 不会加载，当点击按钮后，才加载<br>math.bundle.js 文件。</p>
<ol>
<li>什么是Tree-sharking?<br>Tree是树，sharking是摇晃的意思。那么树摇晃的时候，肯定会’摇’下来一些无用的叶子。从编程的角度思考，如果假设我们的代码是一棵树（Tree），那么摇下来的无用的的叶子是什么呢？当然是无用的代码啦，他有个专业的术语，叫做dead-code（死码）<br>指打包中去除那些引入了但在代码中没用到的死代码。在wepack中js treeshaking通过UglifyJsPlugin来进行，css中通过purify-CSS来进行。</li>
</ol>
<h1 id="五、-构建流程"><a href="#五、-构建流程" class="headerlink" title="五、 构建流程"></a>五、 构建流程</h1><h2 id="1-webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全"><a href="#1-webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全" class="headerlink" title="1. webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全"></a>1. webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<ol>
<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li>
<li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li>
<li>确定入口：根据配置中的 entry 找出所有的入口文件；</li>
<li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li>
<li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。<br>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</li>
</ol>
<h2 id="2-解决ESLint报错常用的五种方案"><a href="#2-解决ESLint报错常用的五种方案" class="headerlink" title="2. 解决ESLint报错常用的五种方案"></a>2. 解决ESLint报错常用的五种方案</h2><p>（1）Strings must use singlequote quotes<br>表示变量使用了双引号，把表示变量的双引号改为单引号即可。<br>（2）Expected to be enclosed by double quotes (vue&#x2F;html-quotes)<br>这个报错代表让你要将单引号改为双引号<br>（3）Trailing spaces not allowed no-trailing-spaces<br>代表有的地方空格多余，比如标签结尾处，只要删除多余空格即可<br>（4）Unexpected tab character’<br>面意思理解呢就是意想不到的制表符，当时出现的时候就是我习惯的使用Tab键去打空格，但是eslint默认不认可Tab，所以解决方法很简单：<br>在eslint的配置文件中（.eslintrc）rules项中添加一行：“no-tabs”:“off”。如下：<br>（5）‘expected indentation of 2 spaces but found 1 tab’<br>字面意思就是预期缩进2个空格，但找到1个Tab。说实话，我一开始找了半天，没发现原因，后来想到可能是eslint不认可tab开头，因此我找到了我使用的编辑器VSCord的设置，添加了相应的文字：</p>
<p>大概的意思就是在格式话保存的时候按照1tab&#x3D;2space的计算量将tab替换成space，这样就不会有问题了。<br>（6）Unexpected trailing comma. (comma-dangle)<br>字面意思是尾随了一个多余的逗号<br>（7）There should be no space before this paren space-in-parens<br>结尾有多余的空格，去掉就好。</p>
<h2 id="3-什么是模块热更新？有什么优点？"><a href="#3-什么是模块热更新？有什么优点？" class="headerlink" title="3. 什么是模块热更新？有什么优点？"></a>3. 什么是模块热更新？有什么优点？</h2><p>HMR即Hot Module Replacement是指当你对代码修改并保存后，webpack将会对代码进行重新打包，并将改动的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块，去实现局部更新页面而非整体刷新页面。<br>借助webpack.HotModuleReplacementPlugin()，devServer开启hot<br>场景1：实现只刷新css，不影响js场景2：js中实现热更新，只更新指定js模块<br>优点：<br>在开发阶段，可以提高开发效率，不用手动重新编译即可看到最新效果，webpack服务会通知页面驱动试图进行更新，不用在浏览器手动进行刷新页面</p>
<h2 id="4-Webpack-Proxy工作原理"><a href="#4-Webpack-Proxy工作原理" class="headerlink" title="4. Webpack Proxy工作原理"></a>4. Webpack Proxy工作原理</h2><p>4.1 代理<br>在项目开发中不可避免会遇到跨越问题，Webpack中的Proxy就是解决前端跨域的方法之一。所谓代理，指的是在接收客户端发送的请求后转发给其他服务器的行为，webpack中提供服务器的工具为webpack-dev-server。<br>4.1.1 webpack-dev-server<br>webpack-dev-server是 webpack 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起。同时，为了提高开发者日常的开发效率，只适用在开发阶段。在webpack配置对象属性中配置代理的代码如下：<br>&#x2F;&#x2F; .&#x2F;webpack.config.js<br>const path &#x3D; require(‘path’)</p>
<p>module.exports &#x3D; {<br>&#x2F;&#x2F; …<br>devServer: {<br>contentBase: path.join(__dirname, ‘dist’),<br>compress: true,<br>port: 9000,<br>proxy: {<br>‘&#x2F;api’: {<br>target: ‘<a target="_blank" rel="noopener" href="https://api.github.com/">https://api.github.com</a>‘<br>}<br>}<br>&#x2F;&#x2F; …<br>}<br>}</p>
<p>其中，devServetr里面proxy则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配。<br>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为 &#x2F;api，值为对应的代理匹配规则，对应如下： - target：表示的是代理到的目标地址。 - pathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite。 - secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false。 - changeOrigin：它表示是否更新代理后请求的 headers 中host地址。<br>4.2 原理<br>proxy工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器。比如下面的例子：<br>const express &#x3D; require(‘express’);<br>const proxy &#x3D; require(‘http-proxy-middleware’);<br>const app &#x3D; express();<br>app.use(‘&#x2F;api’, proxy({target: ‘<a target="_blank" rel="noopener" href="http://www.example.org/">http://www.example.org</a>‘, changeOrigin: true}));<br>app.listen(3000);<br>&#x2F;&#x2F; <a target="_blank" rel="noopener" href="http://localhost:3000/api/foo/bar">http://localhost:3000/api/foo/bar</a> -&gt; <a target="_blank" rel="noopener" href="http://www.example.org/api/foo/bar">http://www.example.org/api/foo/bar</a></p>
<p>在上面的例子中，本地地址为<a href="http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中。">http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中。</a><br>4.3 跨域<br>在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题。<br>解决这种问题时，只需要设置webpack proxy代理即可。当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地，原理图如下：</p>
<p>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能</p>
<h2 id="5-webpack-dev-server-和-http服务器的区别"><a href="#5-webpack-dev-server-和-http服务器的区别" class="headerlink" title="5. webpack-dev-server 和 http服务器的区别"></a>5. webpack-dev-server 和 http服务器的区别</h2><p>webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，比传统的http服务对开发更加有效。提高Webpack的构建速度</p>
<h2 id="6-webpack的热更新原理是怎样的？"><a href="#6-webpack的热更新原理是怎样的？" class="headerlink" title="6. webpack的热更新原理是怎样的？"></a>6. webpack的热更新原理是怎样的？</h2><ol>
<li>Webpack 通过 Watch 模式可以侦听文件的变化，当文件发生改变时，会根据配置进行重新编译（Compile），并将编译后的代码保存在内存中。</li>
<li>webpack-dev-server 也会对文件变化进行监控（需要配置 devServer.watchContentBase &#x3D; true），但不会进行重新编译，而是监听这些配置文件中静态文件的变化，变化后会通知浏览器进行直接刷新，而不是 HMR。</li>
<li>在浏览器和服务端之间有一个通过 SocketJs 建立的 websocket 长连接。webpack-dev-server 会将 Webpack 编译打包时的各个阶段的状态信息和 hash 值一并告知 webpack-dev-server&#x2F;client（位于浏览器端）。</li>
<li>但是 webpack-dev-server&#x2F;client 并不能够请求更新的代码，而是把这些工作交给了 webpack&#x2F;hot&#x2F;dev-server，webpack&#x2F;hot&#x2F;dev-server 的工作就是根据 webpack-dev-server&#x2F;client 传来的信息以及 dev-server 的配置决定是刷新浏览器还是 HMR。</li>
<li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到 webpack&#x2F;hot&#x2F;dev-server 传递的新模块的 hash 值，通过 JsonpMainTemplate.runtime 向 webpack-dev-server 发送 Ajax 请求获取到返回的 Json，该 Json 包含了所有要更新的模块的 hash 值，之后通过 Jsonp 请求，获取到最新的模块代码。</li>
<li>接下来，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</li>
<li>如果 HMR 失败，则通过刷新浏览器来获取最新打包代码。</li>
</ol>
<h1 id="六、-基本配置"><a href="#六、-基本配置" class="headerlink" title="六、 基本配置"></a>六、 基本配置</h1><h2 id="1-entry的值有几种数据类型？"><a href="#1-entry的值有几种数据类型？" class="headerlink" title="1. entry的值有几种数据类型？"></a>1. entry的值有几种数据类型？</h2><p>字符串（单入口）<br>数组（多入口）<br>object(object中的key在webpack里相当于此入口的name)</p>
<h2 id="2-webpack如何配置多入口文件？"><a href="#2-webpack如何配置多入口文件？" class="headerlink" title="2. webpack如何配置多入口文件？"></a>2. webpack如何配置多入口文件？</h2><p>● 配置多入口entry<br>○<br>● 配置出口output<br>○ filename 中的 [name] 对应入口的文件名；<br>○ contentHash 会命中缓存，提高性能；<br>○<br>● 配置插件htmlWebpackPlugin，生成多页面<br>○ htmlWebpackPlugin 插件会生成页面。<br>○ chunk 为代码块，默认引入 entry 中所有文件。<br>○</p>
<h2 id="3-webpack-config-js能不能做拆分？"><a href="#3-webpack-config-js能不能做拆分？" class="headerlink" title="3. webpack.config.js能不能做拆分？"></a>3. webpack.config.js能不能做拆分？</h2><p>可以<br>将webpack.config.js 配置文件进行分开。分成三个配置文件，如下：</p>
<ol>
<li><p>webpack.base.config.js：两个环境公共的部分</p>
</li>
<li><p>webpack.dev.config.js：开发环境独有的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack.prod.config.js`：生产环境独有的配置</span><br></pre></td></tr></table></figure>
</li>
<li><p>output的对象中的常见属性有哪些?</p>
<p>output 是一个 object 对象，其中包含一系列的配置项，其中比较重要的是 filename 和 path。</p>
<p>● output.filename：配置输出文件的名称，指定一个 string 类型的值。如果只有一个输出文件，则可以把它写成静态不变的。</p>
<p>● output.path ：配置输出文件存放在本地的目录，是一个 string 类型的绝对路径。通常通过 Node.js 的 path 模块去获取绝对路径。</p>
<p>在 webpack.config.js 配置文件中，一个 entry 对应一个 output。</p>
<h1 id="七、-区别"><a href="#七、-区别" class="headerlink" title="七、 区别"></a>七、 区别</h1><h2 id="1-babel-runtime和babel-polyfill的区别"><a href="#1-babel-runtime和babel-polyfill的区别" class="headerlink" title="1. babel-runtime和babel-polyfill的区别"></a>1. babel-runtime和babel-polyfill的区别</h2><p>● babel-polyfill</p>
<p>○ 原理是当运行环境中并没有实现的一些方法，babel-polyfill 会给其做兼容。 但是这样做也有一个缺点，就是会污染全局变量，而且项目打包以后体积会增大很多，因为把整个依赖包也搭了进去。所以并不推荐在一些方法类库中去使用。</p>
<p>○ babel-polyfill 可以用来转码，因为 babel-polyfill 是直接在原型链上增加方法。</p>
<p>● babel-runtime</p>
<p>○ 为了不污染全局对象和内置的对象原型，但是又想体验使用新鲜语法的快感。就可以配合使用babel-runtime和babel-plugin-transform-runtime。 比如当前运行环境不支持promise，可以通过引入babel-runtime&#x2F;core-js&#x2F;promise来获取promise， 或者通过babel-plugin-transform-runtime自动重写你的promise。也许有人会奇怪，为什么会有两个runtime插件，其实是有历史原因的：刚开始开始只有babel-runtime插件，但是用起来很不方便，在代码中直接引入helper 函数，意味着不能共享，造成最终打包出来的文件里有很多重复的helper代码。所以，Babel又开发了babel-plugin-transform-runtime，这个模块会将我们的代码重写，如将Promise重写成_Promise（只是打比方），然后引入_Promise helper函数。这样就避免了重复打包代码和手动引入模块的痛苦。</p>
<p>○ babel-runtime 不能转码实例方法</p>
</li>
</ol>
<h2 id="2-除了Webpack外，你还了解哪些模块管理工具"><a href="#2-除了Webpack外，你还了解哪些模块管理工具" class="headerlink" title="2. 除了Webpack外，你还了解哪些模块管理工具"></a>2. 除了Webpack外，你还了解哪些模块管理工具</h2><p>webpack:<br>就目前而言，webpack已是最常用的打包工具，webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。<br>gulp：<br>gulp是一个前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task，第一task处理的事情（如代码压缩，合并，编译以及浏览器实时更新等）。然后定义这些执行顺序，来让glup执行这些task，从而构建项目的整个开发流程。自动化构建工具并不能把所有的模块打包到一起，也不能构建不同模块之间的依赖关系。</p>
<p>grunt：<br>是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。<br>Rollup</p>
<ol>
<li>Rollup 是一款 ES Modules 打包器， 从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要小巧的多<br>现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等<br>Parcel<br>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序<br>Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用 HTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。<br>模块化是一种处理复杂系统分解为更好的可管理模块的方式。可以用来分割、组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体。<br>在前端领域中，除了Webpack外，比较流行的模块打包工具还包括Rollup、Parcel、snowpack和最近风靡的Vite。<br>2.1. Rollup<br>Rollup 是一款 ES Modules 打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多。现在很多苦都使用它进行打包，比如：Vue、React和three.js等。<br>使用之前，可以使用npm install —global rollup 命令进行安装。Rollup 可以通过命令行接口(command line interface)配合可选配置文件(optional configuration file)来调用，或者可以通过 JavaScript API来调用。运行 rollup —help 可以查看可用的选项和参数。<br>2.2. Parcel<br>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序。<br>2.3. Vite<br>Vite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。<br>Vite具有以下特点： - 快速的冷启动 - 即时热模块更新（HMR，Hot Module Replacement） - 真正按需编译<br>Vite由两部分组成： - 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR。 - 一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。<br>Vite在开发阶段可以直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块的时候，根据需要对模块的内容进行编译，大大缩短了编译时间。工作原理如下图所示。<br>在热模块HMR方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像Webpack那样需要把该模块的相关依赖模块全部编译一次，因此效率也更高。</li>
<li>webpack，rollup，parcel优劣？(了解)<br>对比<br>Webpack<br>Rollup<br>Parcel<br>功能</li>
</ol>
<p>为处理资源管理和分割代码而生，可以用来处理任何类型的文件，灵活，插件多。<br>用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。<br>用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。<br>配置<br>webpack需要配config文件，指明entry, output, plugin，transformations。<br>rollup需要配config文件，指明entry, output, plugin，transformations。rollup 有对import&#x2F;export所做的node polyfills，webpack没有。rollup支持相对路径，而webpack没有，所以得使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcel则是完全开箱可用的，不用配置。</span><br></pre></td></tr></table></figure>

<p>入口文件<br>webpack只支持js文件作为入口文件，如果要以其他格式的文件作为入口，比如html文件为入口，如要加第三方Plugin。<br>rollup可以用html作为入口文件，但也需要plugin，比如rollup-plugin-html-entry。<br>parcel可以用index.html作为入口文件，而且它会通过看index.html的script tag里包含的什么自己找到要打包生成哪些js文件。<br>transformations<br>transformations指的是把其他文件转化成js文件的过程，需要经过transformation才能够被打包。webpack使用Loaders来处理。<br>rollup使用plugins来处理。<br>parcel会自动去转换，当找到配置文件比如.babelrc, .postcssrc后就会自动转。<br>摇树优化<br>摇树优化是webpack的一大特性。需要1，用import&#x2F;export语法，2，在package.json中加副作用的入口，3，加上支持去除死代码的缩小器（uglifyjsplugin）。<br>rollup会统计引入的代码并排除掉那些没有被用到的。这使您可以在现有工具和模块的基础上构建，而无需添加额外的依赖项或膨胀项目的大小。<br>parcel不支持摇树优化。<br>dev server<br>webpack用webpack-dev-server。</p>
<p>rollup用rollup-plugin-serve和rollup-plugin-livereload共同作用。<br>parcel内置的有dev server<br>热更新<br>webpack的 wepack-dev-server支持hot模式。<br>rollup不支持hmr。<br>parcel有内置的hmr。<br>代码分割<br>webpack通过在entry中手动设置，使用CommonsChunkPlugin，和模块内的内联函数动态引入来做代码分割。<br>rollup有实验性的代码分割特性。它是用es模块在浏览器中的模块加载机制本身来分割代码的。需要把experimentalCodeSplitting 和 experimentalDynamicImport 设为true。<br>parcel支持0配置的代码分割。主要是通过动态improt。</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2020/12/03/webpack/webpack%E9%9D%A2%E8%AF%95%E9%A2%98/">Read More</a>
    </footer>
</div>



<ul class="cube-pagination cube-pagination-9">
    
    <li class="cube-pagination-prev">
        <a href="/page/3/">« Prev</a>
    </li>
    
    
        
                <li class="cube-pagination-index">
                    <a href="/">1</a>
                </li>
                <li class="cube-pagination-ellipses">
                    <span>...</span>
                </li>
            
                
                <li class="cube-pagination-index">
                    <a href="/page/3">3</a>
                </li>
                
            
                
                <li class="cube-pagination-index disabled">
                    <span>4</span>
                </li>
                
            
                
                <li class="cube-pagination-index">
                    <a href="/page/5">5</a>
                </li>
                
            
                <li class="cube-pagination-ellipses">
                    <span>...</span>
                </li>
                <li class="cube-pagination-index">
                    <a href="/page/19">19</a>
                </li>
        
    

    
    <li class="cube-pagination-next">
        <a href="/page/5/">Next »</a>
    </li>
    
</ul>

<!--其他组件后续添加-->
        </div>
        <div class="cube-right">
            

<div class="cube-search cube-sidebar" id="cube-search">
    <div class="search-container">
        <input type="text" placeholder="Search" class="cube-search-input" id="cube-search-input">
        <i class="cube-icon cube-icon-search cube-search-submit" aria-hidden="true"></i>
    </div>
    <!-- TODO 通过给window赋一个全局变量，通过脚本赋值 -->
</div>
<script>
    (function (window) {
        'use strict';
        window.searchModule = {}
        window.searchModule.JSONUrl = '/content.json'
        window.searchModule.rootUrl = '/'
    })(window)
</script>
<div class="cube-search-form">
    <div class="cube-search-control">
        <input type="text" placeholder="Search" class="search-input">
        <a class="close-button">
            <i class="cube-icon cube-close" aria-hidden="true"></i>
        </a>
    </div>
    <div class="cube-search-result"></div>
</div>


<div class="cube-author cube-sidebar" id="cube-author">
    
    
    <span>John Doe</span>
    
    
    <div class="count">
        <a class="count articles"><span>186</span>Article</a>
        <a class="count tags"><span>35</span>Tags</a>
        <a class="count categories"><span>23</span>Categories</a>
    </div>
</div>



<div class="cube-music cube-sidebar" id="cube-music">
    <div class="cube-player aplayer" id="cube-player"></div>
</div>
<script>
    (function (window) {
        window.musicModule = {}
        window.musicModule.musicConfig = '{"narrow":false,"autoplay":false,"showlrc":3,"theme":"#b7daff","mutex":true,"mode":"circulation","preload":"auto","listmaxheight":"513px","music":[{"title":"Dear friends","author":"TRIPLANE","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/TRIPLANE - Dear friends.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Dear friends - TRIPLANE.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/TRIPLANE - Dear friends.jpg"},{"title":"Butter-Fly","author":"和田光司","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/和田光司 - Butter-Fly (ピアノヴァージョン).mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Butter-Fly (ピアノヴァージョン) - 和田光司.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/和田光司 - Butter-Fly (ピアノヴァージョン).jpg"},{"title":"宵闇花火","author":"葉月ゆら","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/葉月ゆら - 宵闇花火.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/宵闇花火 - 葉月ゆら.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/葉月ゆら - 宵闇花火.jpg"}]}'
        window.musicModule.lrcConfig = {
            open: 'Open Lyrics',
            close: 'Close Lyrics'
        }
    })(window)
</script>



<div class="cube-recent-posts cube-sidebar" id="cube-recent-posts">
    <div class="title">
        <a>Recent Posts</a>
    </div>
    <ul class="list">
        
        
        <li>
            <!-- TODO 如果文章要显示图片，那么在front-matter上添加preview属性(url or path) -->
            
            <div class="normal">
                <p class="index first">
                    <span>1</span>
                </p>
                <p class="title">
                    <a href="/2022/08/25/Js%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="变量类型">变量类型</a>
                </p>
            </div>
            
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>2</span>
                </p>
                <p class="title">
                    <a href="/2022/06/09/html+css+js+ts/3-js%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/" title="js-常用代码操作实例">js-常用代码操作实例</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>3</span>
                </p>
                <p class="title">
                    <a href="/2022/05/28/html+css+js+ts/1-%E9%9F%B3%E8%A7%86%E9%A2%91/" title="html-原生音视频">html-原生音视频</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>4</span>
                </p>
                <p class="title">
                    <a href="/2022/04/25/http/DNS%E5%8D%8F%E8%AE%AE/" title="DNS协议">DNS协议</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>5</span>
                </p>
                <p class="title">
                    <a href="/2022/04/17/html+css+js+ts/4-%E8%A3%85%E9%A5%B0%E5%99%A8/" title="ES6 装饰器">ES6 装饰器</a>
                </p>
            </div>
        </li>
        
        
    </ul>
</div>



<div class="cube-categories cube-sidebar" id="cube-categories">
    <div class="title">
        <a href="/categories">Categories</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/categories/http/">#http</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/React/">#React</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">#架构模式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">#数据可视化</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/">#前端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">#移动端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E9%9F%B3%E8%A7%86%E9%A2%91/">#音视频</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/javascript/">#javascript</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">#问题</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/">#后端</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/">#框架</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">#前端工程化</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">#小程序</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E5%B7%A5%E5%85%B7/">#工具</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">#正则表达式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">#前端性能优化</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">#数据库</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/liunx/">#liunx</a>
        </div>
        
    </div>
</div>



<div class="cube-tagcloud cube-sidebar" id="cube-tagcloud">
    <div class="title">
        <a href="/tags">Tagcloud</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box-bg ">
            <a href="/tags/http/">#http</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/vue/">#vue</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/React/">#React</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Redux/">#Redux</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/vue3/">#vue3</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/react/">#react</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/echart/">#echart</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/html/">#html</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/xml/">#xml</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">#移动端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/css/">#css</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/javascript/">#javascript</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Promise/">#Promise</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/es6/">#es6</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/typescript/">#typescript</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/async-await/">#async/await</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/nodejs/">#nodejs</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/glup/">#glup</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/python/">#python</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/webpack/">#webpack</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">#小程序</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/git/">#git</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Mock/">#Mock</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/RESTful/">#RESTful</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/eslint/">#eslint</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/hexo/">#hexo</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/vs-code/">#vs code</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">#正则表达式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E4%BC%98%E5%8C%96/">#优化</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/mongodb/">#mongodb</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/mysql/">#mysql</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/nginx/">#nginx</a>
        </div>
        
    </div>
</div>



<div class="cube-links cube-sidebar" id="cube-links">
    <div class="title">
        <a>Links</a>
    </div>
    <ul class="list">
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/GitHub.png">
            
            <a href="https://github.com/ZEROKISEKI" target="_blank">GitHub</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/Coding.png">
            
            <a href="https://coding.net/u/SORA1" target="_blank">Coding</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/SF.png">
            
            <a href="https://segmentfault.com/u/aonosora" target="_blank">SF社区</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/开发者头条.png">
            
            <a href="https://toutiao.io/u/148070" target="_blank">开发者头条</a>
        </li>
        
    </ul>
</div>



<div class="cube-friend-links cube-sidebar" id="cube-friend-links">
    <div class="title">
        <a>Friend Links</a>
    </div>
    <ul class="list">
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/micblo.png">
            <a href="https://blog.micblo.com/" target="_blank">罗大佬</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/DIYgod.jpg">
            <a href="https://www.anotherhome.net/" target="_blank">DIYgod</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="/images/friend_links.jpg ">
            <a href="https://aonosora.com/" target="_blank">咪西西の部落格</a>
        </li>
        
    </ul>
</div>


        </div>
    </div>
</div>
<footer class="cube-footer">
    
© 2017 John Doe

<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.&nbsp;Theme by <a href="https://github.com/ZEROKISEKI" target="_blank">AONOSORA</a>
</footer>
<!-- inject:script -->
<script src="/js/script.js"></script>
<!-- endinject -->
<div class="cube-loading out"></div>
</body>
</html>